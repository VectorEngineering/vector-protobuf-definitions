package main

import (
	"time"

	leadScraperServiceProto "github.com/Vector/vector-lead-management/protobuf/api-definitions/pkg/generated/lead_scraper_service/v1"
	"gorm.io/gen"
)

// Querier is the interface of added queries that the various
// types should implement.
type Querier interface {
	// SELECT * FROM @@table
	//  {{where}}
	//      id=@id
	//  {{end}}
	GetRecordByID(id uint64) (gen.T, error) // returns struct and error

	// SELECT * FROM @@table
	//  {{where}}
	//      id IN (@ids)
	//  {{end}}
	GetRecordByIDs(ids []uint64) ([]gen.T, error) // returns slice of struct and error

	// DELETE FROM @@table
	//  {{where}}
	//      id=@id
	//  {{end}}
	DeleteRecordByID(id uint64) error // deletes a record by ID

	// SELECT * FROM @@table
	// ORDER BY @@orderColumn
	// LIMIT @limit
	// OFFSET @offset
	GetAllRecords(orderColumn string, limit, offset int) ([]gen.T, error)

	// Additional Operations
	// SELECT COUNT(*) FROM @@table
	CountAll() (int, error) // returns count of all records

	// SELECT * FROM @@table
	//  {{where}}
	//      id=@id
	//  {{end}}
	GetByID(id uint64) (gen.T, error) // returns struct and error

	// SELECT * FROM @@table
	//  {{where}}
	//      id IN (@ids)
	//  {{end}}
	GetByIDs(ids []uint64) ([]gen.T, error) // returns slice of struct and error

	// Enhanced Operations

	// SELECT * FROM @@table
	//  {{where}}
	//      deleted_at IS NULL
	//  {{end}}
	// ORDER BY @@orderColumn
	// LIMIT @limit OFFSET @offset
	GetActivePaginated(orderColumn string, limit, offset int) ([]gen.T, error)

	// SELECT * FROM @@table
	//  {{where}}
	//      deleted_at IS NOT NULL
	//  {{end}}
	GetDeleted() ([]gen.T, error)

	// UPDATE @@table SET deleted_at=CURRENT_TIMESTAMP
	//  {{where}}
	//      id=@id
	//  {{end}}
	SoftDelete(id uint64) error

	// UPDATE @@table SET deleted_at=NULL
	//  {{where}}
	//      id=@id
	//  {{end}}
	Restore(id uint64) error

	// INSERT INTO @@table (columns) VALUES (values...)
	CreateInBatch(items []gen.T, batchSize int) error

	// DELETE FROM @@table
	//  {{where}}
	//      id IN (@ids)
	//  {{end}}
	DeleteInBatch(ids []uint64) error

	// SELECT * FROM @@table
	//  {{where}}
	//      created_at BETWEEN @startTime AND @endTime
	//  {{end}}
	GetByTimeRange(startTime, endTime time.Time) ([]gen.T, error)

	// SELECT * FROM @@table
	//  {{where}}
	//      column_name @operator @value
	//  {{end}}
	FindBy(columnName string, operator string, value interface{}) ([]gen.T, error)

	// SELECT * FROM @@table
	//  {{where}}
	//      column_name LIKE @pattern
	//  {{end}}
	FindByPattern(columnName string, pattern string) ([]gen.T, error)

	// SELECT DISTINCT column_name FROM @@table
	GetDistinct(columnName string) ([]gen.T, error)

	// SELECT * FROM @@table
	//  {{where}}
	//      @conditions
	//  {{end}}
	// ORDER BY @orderBy
	// LIMIT @limit OFFSET @offset
	FindWithFilters(conditions map[string]interface{}, orderBy string, limit, offset int) ([]gen.T, error)

	// UPDATE @@table SET updated_at=CURRENT_TIMESTAMP
	//  {{where}}
	//      id=@id
	//  {{end}}
	Touch(id uint64) error

	// SELECT EXISTS(
	//    SELECT 1 FROM @@table
	//     {{where}}
	//         @column = @value
	//     {{end}}
	// )
	Exists(column string, value interface{}) (bool, error)

	// SELECT EXISTS(
	//    SELECT 1 FROM @@table
	//     {{where}}
	//         id = @id
	//     {{end}}
	// )
	ExistsById(id uint64) (bool, error)

	// SELECT * FROM @@table
	//  {{where}}
	//      @column IN (SELECT @foreignKey FROM @foreignTable)
	//  {{end}}
	FindBySubquery(column string, foreignTable string, foreignKey string) ([]gen.T, error)

	// SELECT EXISTS(
	//    SELECT 1 FROM @@table
	//     {{where}}
	//         @column = @value
	//     {{end}}
	// ), COALESCE((
	//    SELECT @column FROM @@table
	//     {{where}}
	//         @column = @value
	//     {{end}}
	//    LIMIT 1
	// ), NULL)
	ExistsAndGet(column string, value interface{}) (gen.T, error)

	// SELECT EXISTS(
	//    SELECT 1 FROM @@table
	//     {{where}}
	//         @column = @value AND deleted_at IS NULL
	//     {{end}}
	// ), COALESCE((
	//    SELECT @column FROM @@table
	//     {{where}}
	//         @column = @value AND deleted_at IS NULL
	//     {{end}}
	//    LIMIT 1
	// ), NULL)
	ExistsAndGetActive(column string, value interface{}) (gen.T, error)
}

func main() {
	leadScraperOutputPath := "../../pkg/generated/lead_scraper_service/dal"
	leadScraperModels := getAllLeadScraperModels()
	autogenerateDal(&leadScraperOutputPath, leadScraperModels)
}


func getAllLeadScraperModels() []interface{} {
	models := leadScraperServiceProto.GetDatabaseSchemas()
	return models
}

// autogenerateDal generates data access layer for provided models.
func autogenerateDal(outputPath *string, models []interface{}) {
	if outputPath == nil {
		return
	}

	g := createGenerator(*outputPath)
	g.ApplyBasic(models...)
	g.ApplyInterface(func(Querier) {}, models...)
	g.Execute()
}

// createGenerator initializes a new gen.Generator with the given configuration.
func createGenerator(outputPath string) *gen.Generator {
	// define the generator configuration
	return gen.NewGenerator(gen.Config{
		OutPath:           outputPath,
		WithUnitTest:      true,
		FieldNullable:     true,
		FieldCoverable:    true,
		FieldSignable:     false,
		FieldWithIndexTag: true,
		FieldWithTypeTag:  true,
		Mode:              gen.WithoutContext | gen.WithDefaultQuery | gen.WithQueryInterface,
	})
}
