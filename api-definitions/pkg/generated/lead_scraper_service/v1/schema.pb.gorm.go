package lead_scraper_servicev1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/v2/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type AccountORM struct {
	AccountStatus      string
	AuthPlatformUserId string `gorm:"index:idx_user_auth_platform_user_id"`
	ConcurrentJobLimit int32
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	Email              string `gorm:"index:idx_accounts_email"`
	Id                 uint64 `gorm:"primaryKey"`
	LastLoginAt        *time.Time
	MfaEnabled         bool
	MonthlyJobLimit    int32
	OrgId              string              `gorm:"index:idx_accounts_org_id"`
	Permissions        pq.StringArray      `gorm:"type:text[]"`
	Roles              pq.StringArray      `gorm:"type:text[]"`
	Settings           *AccountSettingsORM `gorm:"foreignKey:AccountId;references:Id"`
	TenantId           string              `gorm:"index:idx_accounts_tenant_id"`
	Timezone           string
	TotalJobsRun       int32
	Workspaces         []*WorkspaceORM `gorm:"foreignKey:AccountId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (AccountORM) TableName() string {
	return "accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Account) ToORM(ctx context.Context) (AccountORM, error) {
	to := AccountORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AuthPlatformUserId = m.AuthPlatformUserId
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	to.Email = m.Email
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.AccountStatus = Account_AccountStatus_name[int32(m.AccountStatus)]
	if m.Roles != nil {
		to.Roles = make(pq.StringArray, len(m.Roles))
		copy(to.Roles, m.Roles)
	}
	if m.Permissions != nil {
		to.Permissions = make(pq.StringArray, len(m.Permissions))
		copy(to.Permissions, m.Permissions)
	}
	to.MfaEnabled = m.MfaEnabled
	if m.LastLoginAt != nil {
		t := m.LastLoginAt.AsTime()
		to.LastLoginAt = &t
	}
	to.Timezone = m.Timezone
	to.TotalJobsRun = m.TotalJobsRun
	to.MonthlyJobLimit = m.MonthlyJobLimit
	to.ConcurrentJobLimit = m.ConcurrentJobLimit
	for _, v := range m.Workspaces {
		if v != nil {
			if tempWorkspaces, cErr := v.ToORM(ctx); cErr == nil {
				to.Workspaces = append(to.Workspaces, &tempWorkspaces)
			} else {
				return to, cErr
			}
		} else {
			to.Workspaces = append(to.Workspaces, nil)
		}
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	if posthook, ok := interface{}(m).(AccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountORM) ToPB(ctx context.Context) (Account, error) {
	to := Account{}
	var err error
	if prehook, ok := interface{}(m).(AccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AuthPlatformUserId = m.AuthPlatformUserId
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	to.Email = m.Email
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.AccountStatus = Account_AccountStatus(Account_AccountStatus_value[m.AccountStatus])
	if m.Roles != nil {
		to.Roles = make(pq.StringArray, len(m.Roles))
		copy(to.Roles, m.Roles)
	}
	if m.Permissions != nil {
		to.Permissions = make(pq.StringArray, len(m.Permissions))
		copy(to.Permissions, m.Permissions)
	}
	to.MfaEnabled = m.MfaEnabled
	if m.LastLoginAt != nil {
		to.LastLoginAt = timestamppb.New(*m.LastLoginAt)
	}
	to.Timezone = m.Timezone
	to.TotalJobsRun = m.TotalJobsRun
	to.MonthlyJobLimit = m.MonthlyJobLimit
	to.ConcurrentJobLimit = m.ConcurrentJobLimit
	for _, v := range m.Workspaces {
		if v != nil {
			if tempWorkspaces, cErr := v.ToPB(ctx); cErr == nil {
				to.Workspaces = append(to.Workspaces, &tempWorkspaces)
			} else {
				return to, cErr
			}
		} else {
			to.Workspaces = append(to.Workspaces, nil)
		}
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	if posthook, ok := interface{}(m).(AccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Account the arg will be the target, the caller the one being converted from

// AccountBeforeToORM called before default ToORM code
type AccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountORM) error
}

// AccountAfterToORM called after default ToORM code
type AccountWithAfterToORM interface {
	AfterToORM(context.Context, *AccountORM) error
}

// AccountBeforeToPB called before default ToPB code
type AccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *Account) error
}

// AccountAfterToPB called after default ToPB code
type AccountWithAfterToPB interface {
	AfterToPB(context.Context, *Account) error
}

type WorkspaceORM struct {
	AccountId           *uint64
	ActiveScrapers      int32
	ApiKeys             []*APIKeyORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	CreatedAt           *time.Time
	DailyJobQuota       int32
	DeletedAt           *time.Time
	Domain              string `gorm:"index:idx_workspaces_domain"`
	GdprCompliant       bool
	HipaaCompliant      bool
	Id                  uint64 `gorm:"primaryKey"`
	Industry            string
	JobsRunThisMonth    int32
	LastJobRun          *time.Time
	Name                string            `gorm:"index:idx_workspaces_name"`
	ScrapingJobs        []*ScrapingJobORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	Soc2Compliant       bool
	StorageQuota        int64
	TotalLeadsCollected int32
	UpdatedAt           *time.Time
	UsedStorage         int64
	Workflows           []*ScrapingWorkflowORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	WorkspaceJobLimit   int32
}

// TableName overrides the default tablename generated by GORM
func (WorkspaceORM) TableName() string {
	return "workspaces"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Workspace) ToORM(ctx context.Context) (WorkspaceORM, error) {
	to := WorkspaceORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Industry = m.Industry
	to.Domain = m.Domain
	to.GdprCompliant = m.GdprCompliant
	to.HipaaCompliant = m.HipaaCompliant
	to.Soc2Compliant = m.Soc2Compliant
	to.StorageQuota = m.StorageQuota
	to.UsedStorage = m.UsedStorage
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.Workflows {
		if v != nil {
			if tempWorkflows, cErr := v.ToORM(ctx); cErr == nil {
				to.Workflows = append(to.Workflows, &tempWorkflows)
			} else {
				return to, cErr
			}
		} else {
			to.Workflows = append(to.Workflows, nil)
		}
	}
	to.JobsRunThisMonth = m.JobsRunThisMonth
	to.WorkspaceJobLimit = m.WorkspaceJobLimit
	to.DailyJobQuota = m.DailyJobQuota
	to.ActiveScrapers = m.ActiveScrapers
	to.TotalLeadsCollected = m.TotalLeadsCollected
	if m.LastJobRun != nil {
		t := m.LastJobRun.AsTime()
		to.LastJobRun = &t
	}
	for _, v := range m.ScrapingJobs {
		if v != nil {
			if tempScrapingJobs, cErr := v.ToORM(ctx); cErr == nil {
				to.ScrapingJobs = append(to.ScrapingJobs, &tempScrapingJobs)
			} else {
				return to, cErr
			}
		} else {
			to.ScrapingJobs = append(to.ScrapingJobs, nil)
		}
	}
	for _, v := range m.ApiKeys {
		if v != nil {
			if tempApiKeys, cErr := v.ToORM(ctx); cErr == nil {
				to.ApiKeys = append(to.ApiKeys, &tempApiKeys)
			} else {
				return to, cErr
			}
		} else {
			to.ApiKeys = append(to.ApiKeys, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkspaceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkspaceORM) ToPB(ctx context.Context) (Workspace, error) {
	to := Workspace{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Industry = m.Industry
	to.Domain = m.Domain
	to.GdprCompliant = m.GdprCompliant
	to.HipaaCompliant = m.HipaaCompliant
	to.Soc2Compliant = m.Soc2Compliant
	to.StorageQuota = m.StorageQuota
	to.UsedStorage = m.UsedStorage
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.Workflows {
		if v != nil {
			if tempWorkflows, cErr := v.ToPB(ctx); cErr == nil {
				to.Workflows = append(to.Workflows, &tempWorkflows)
			} else {
				return to, cErr
			}
		} else {
			to.Workflows = append(to.Workflows, nil)
		}
	}
	to.JobsRunThisMonth = m.JobsRunThisMonth
	to.WorkspaceJobLimit = m.WorkspaceJobLimit
	to.DailyJobQuota = m.DailyJobQuota
	to.ActiveScrapers = m.ActiveScrapers
	to.TotalLeadsCollected = m.TotalLeadsCollected
	if m.LastJobRun != nil {
		to.LastJobRun = timestamppb.New(*m.LastJobRun)
	}
	for _, v := range m.ScrapingJobs {
		if v != nil {
			if tempScrapingJobs, cErr := v.ToPB(ctx); cErr == nil {
				to.ScrapingJobs = append(to.ScrapingJobs, &tempScrapingJobs)
			} else {
				return to, cErr
			}
		} else {
			to.ScrapingJobs = append(to.ScrapingJobs, nil)
		}
	}
	for _, v := range m.ApiKeys {
		if v != nil {
			if tempApiKeys, cErr := v.ToPB(ctx); cErr == nil {
				to.ApiKeys = append(to.ApiKeys, &tempApiKeys)
			} else {
				return to, cErr
			}
		} else {
			to.ApiKeys = append(to.ApiKeys, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkspaceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Workspace the arg will be the target, the caller the one being converted from

// WorkspaceBeforeToORM called before default ToORM code
type WorkspaceWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkspaceORM) error
}

// WorkspaceAfterToORM called after default ToORM code
type WorkspaceWithAfterToORM interface {
	AfterToORM(context.Context, *WorkspaceORM) error
}

// WorkspaceBeforeToPB called before default ToPB code
type WorkspaceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Workspace) error
}

// WorkspaceAfterToPB called after default ToPB code
type WorkspaceWithAfterToPB interface {
	AfterToPB(context.Context, *Workspace) error
}

type ScrapingJobORM struct {
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	Depth              int32
	Email              bool
	FastMode           bool
	Id                 uint64         `gorm:"primaryKey"`
	Keywords           pq.StringArray `gorm:"type:text[]"`
	Lang               string
	Lat                string
	Leads              []*LeadORM `gorm:"foreignKey:ScrapingJobId;references:Id"`
	Lon                string
	MaxTime            int32
	Name               string `gorm:"index:idx_scraping_jobs_name"`
	Payload            []byte `gorm:"type:bytea"`
	PayloadType        string
	Priority           int32
	Proxies            pq.StringArray `gorm:"type:text[]"`
	Radius             int32
	ScrapingWorkflowId *uint64
	Status             string
	UpdatedAt          *time.Time
	WorkspaceId        *uint64
	Zoom               int32
}

// TableName overrides the default tablename generated by GORM
func (ScrapingJobORM) TableName() string {
	return "gmaps_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ScrapingJob) ToORM(ctx context.Context) (ScrapingJobORM, error) {
	to := ScrapingJobORM{}
	var err error
	if prehook, ok := interface{}(m).(ScrapingJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Priority = m.Priority
	to.PayloadType = m.PayloadType
	to.Payload = m.Payload
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.Status = BackgroundJobStatus_name[int32(m.Status)]
	to.Name = m.Name
	if m.Keywords != nil {
		to.Keywords = make(pq.StringArray, len(m.Keywords))
		copy(to.Keywords, m.Keywords)
	}
	to.Lang = m.Lang
	to.Zoom = m.Zoom
	to.Lat = m.Lat
	to.Lon = m.Lon
	to.FastMode = m.FastMode
	to.Radius = m.Radius
	to.Depth = m.Depth
	to.Email = m.Email
	to.MaxTime = m.MaxTime
	if m.Proxies != nil {
		to.Proxies = make(pq.StringArray, len(m.Proxies))
		copy(to.Proxies, m.Proxies)
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.Leads {
		if v != nil {
			if tempLeads, cErr := v.ToORM(ctx); cErr == nil {
				to.Leads = append(to.Leads, &tempLeads)
			} else {
				return to, cErr
			}
		} else {
			to.Leads = append(to.Leads, nil)
		}
	}
	if posthook, ok := interface{}(m).(ScrapingJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ScrapingJobORM) ToPB(ctx context.Context) (ScrapingJob, error) {
	to := ScrapingJob{}
	var err error
	if prehook, ok := interface{}(m).(ScrapingJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Priority = m.Priority
	to.PayloadType = m.PayloadType
	to.Payload = m.Payload
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.Status = BackgroundJobStatus(BackgroundJobStatus_value[m.Status])
	to.Name = m.Name
	if m.Keywords != nil {
		to.Keywords = make(pq.StringArray, len(m.Keywords))
		copy(to.Keywords, m.Keywords)
	}
	to.Lang = m.Lang
	to.Zoom = m.Zoom
	to.Lat = m.Lat
	to.Lon = m.Lon
	to.FastMode = m.FastMode
	to.Radius = m.Radius
	to.Depth = m.Depth
	to.Email = m.Email
	to.MaxTime = m.MaxTime
	if m.Proxies != nil {
		to.Proxies = make(pq.StringArray, len(m.Proxies))
		copy(to.Proxies, m.Proxies)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.Leads {
		if v != nil {
			if tempLeads, cErr := v.ToPB(ctx); cErr == nil {
				to.Leads = append(to.Leads, &tempLeads)
			} else {
				return to, cErr
			}
		} else {
			to.Leads = append(to.Leads, nil)
		}
	}
	if posthook, ok := interface{}(m).(ScrapingJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ScrapingJob the arg will be the target, the caller the one being converted from

// ScrapingJobBeforeToORM called before default ToORM code
type ScrapingJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *ScrapingJobORM) error
}

// ScrapingJobAfterToORM called after default ToORM code
type ScrapingJobWithAfterToORM interface {
	AfterToORM(context.Context, *ScrapingJobORM) error
}

// ScrapingJobBeforeToPB called before default ToPB code
type ScrapingJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *ScrapingJob) error
}

// ScrapingJobAfterToPB called after default ToPB code
type ScrapingJobWithAfterToPB interface {
	AfterToPB(context.Context, *ScrapingJob) error
}

type ScrapingWorkflowORM struct {
	AcceptTermsOfService          bool
	AlertEmails                   string
	AnonymizePii                  bool
	ContentFilterAllowedCountries pq.StringArray `gorm:"type:text[]"`
	ContentFilterExcludedTypes    pq.StringArray `gorm:"type:text[]"`
	ContentFilterMinimumRating    float32
	ContentFilterMinimumReviews   int32
	CreatedAt                     *time.Time
	CronExpression                string
	DataRetention                 *time.Duration
	DeletedAt                     *time.Time
	GeoFencingLat                 float64
	GeoFencingLon                 float64
	GeoFencingRadius              float32
	GeoFencingZoomMax             int32
	GeoFencingZoomMin             int32
	Id                            uint64 `gorm:"primaryKey"`
	IncludeBusinessHours          bool
	IncludePhotos                 bool
	IncludeReviews                bool
	Jobs                          []*ScrapingJobORM `gorm:"foreignKey:ScrapingWorkflowId;references:Id"`
	LastRunTime                   *time.Time
	MaxRetries                    int32
	MaxReviewsPerBusiness         int32
	NextRunTime                   *time.Time
	NotificationEmailGroup        string
	NotificationNotifyOnComplete  bool
	NotificationNotifyOnFailure   bool
	NotificationNotifyOnStart     bool
	NotificationSlackChannel      string
	NotificationWebhookUrl        string
	OrgId                         string
	OutputDestination             string
	OutputFormat                  string
	QosEnableJavascript           bool
	QosMaxConcurrentRequests      int32
	QosMaxRetries                 int32
	QosRequestTimeout             *time.Duration
	RespectRobotsTxt              bool
	RetryCount                    int32
	Status                        string
	TenantId                      string
	UpdatedAt                     *time.Time
	UserAgent                     string
	Workspace                     *WorkspaceORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	WorkspaceId                   *uint64
}

// TableName overrides the default tablename generated by GORM
func (ScrapingWorkflowORM) TableName() string {
	return "scraping_workflows"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ScrapingWorkflow) ToORM(ctx context.Context) (ScrapingWorkflowORM, error) {
	to := ScrapingWorkflowORM{}
	var err error
	if prehook, ok := interface{}(m).(ScrapingWorkflowWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CronExpression = m.CronExpression
	if m.NextRunTime != nil {
		t := m.NextRunTime.AsTime()
		to.NextRunTime = &t
	}
	if m.LastRunTime != nil {
		t := m.LastRunTime.AsTime()
		to.LastRunTime = &t
	}
	to.Status = WorkflowStatus_name[int32(m.Status)]
	to.RetryCount = m.RetryCount
	to.MaxRetries = m.MaxRetries
	to.AlertEmails = m.AlertEmails
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.Jobs {
		if v != nil {
			if tempJobs, cErr := v.ToORM(ctx); cErr == nil {
				to.Jobs = append(to.Jobs, &tempJobs)
			} else {
				return to, cErr
			}
		} else {
			to.Jobs = append(to.Jobs, nil)
		}
	}
	if m.Workspace != nil {
		tempWorkspace, err := m.Workspace.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Workspace = &tempWorkspace
	}
	to.GeoFencingRadius = m.GeoFencingRadius
	to.GeoFencingLat = m.GeoFencingLat
	to.GeoFencingLon = m.GeoFencingLon
	to.GeoFencingZoomMin = m.GeoFencingZoomMin
	to.GeoFencingZoomMax = m.GeoFencingZoomMax
	to.IncludeReviews = m.IncludeReviews
	to.IncludePhotos = m.IncludePhotos
	to.IncludeBusinessHours = m.IncludeBusinessHours
	to.MaxReviewsPerBusiness = m.MaxReviewsPerBusiness
	to.OutputFormat = ScrapingWorkflow_OutputFormat_name[int32(m.OutputFormat)]
	to.OutputDestination = m.OutputDestination
	if m.DataRetention != nil {
		t := m.DataRetention.AsDuration()
		to.DataRetention = &t
	}
	to.AnonymizePii = m.AnonymizePii
	to.NotificationWebhookUrl = m.NotificationWebhookUrl
	to.NotificationSlackChannel = m.NotificationSlackChannel
	to.NotificationEmailGroup = m.NotificationEmailGroup
	to.NotificationNotifyOnStart = m.NotificationNotifyOnStart
	to.NotificationNotifyOnComplete = m.NotificationNotifyOnComplete
	to.NotificationNotifyOnFailure = m.NotificationNotifyOnFailure
	if m.ContentFilterAllowedCountries != nil {
		to.ContentFilterAllowedCountries = make(pq.StringArray, len(m.ContentFilterAllowedCountries))
		copy(to.ContentFilterAllowedCountries, m.ContentFilterAllowedCountries)
	}
	if m.ContentFilterExcludedTypes != nil {
		to.ContentFilterExcludedTypes = make(pq.StringArray, len(m.ContentFilterExcludedTypes))
		copy(to.ContentFilterExcludedTypes, m.ContentFilterExcludedTypes)
	}
	to.ContentFilterMinimumRating = m.ContentFilterMinimumRating
	to.ContentFilterMinimumReviews = m.ContentFilterMinimumReviews
	to.QosMaxConcurrentRequests = m.QosMaxConcurrentRequests
	to.QosMaxRetries = m.QosMaxRetries
	if m.QosRequestTimeout != nil {
		t := m.QosRequestTimeout.AsDuration()
		to.QosRequestTimeout = &t
	}
	to.QosEnableJavascript = m.QosEnableJavascript
	to.RespectRobotsTxt = m.RespectRobotsTxt
	to.AcceptTermsOfService = m.AcceptTermsOfService
	to.UserAgent = m.UserAgent
	if posthook, ok := interface{}(m).(ScrapingWorkflowWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ScrapingWorkflowORM) ToPB(ctx context.Context) (ScrapingWorkflow, error) {
	to := ScrapingWorkflow{}
	var err error
	if prehook, ok := interface{}(m).(ScrapingWorkflowWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CronExpression = m.CronExpression
	if m.NextRunTime != nil {
		to.NextRunTime = timestamppb.New(*m.NextRunTime)
	}
	if m.LastRunTime != nil {
		to.LastRunTime = timestamppb.New(*m.LastRunTime)
	}
	to.Status = WorkflowStatus(WorkflowStatus_value[m.Status])
	to.RetryCount = m.RetryCount
	to.MaxRetries = m.MaxRetries
	to.AlertEmails = m.AlertEmails
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.Jobs {
		if v != nil {
			if tempJobs, cErr := v.ToPB(ctx); cErr == nil {
				to.Jobs = append(to.Jobs, &tempJobs)
			} else {
				return to, cErr
			}
		} else {
			to.Jobs = append(to.Jobs, nil)
		}
	}
	if m.Workspace != nil {
		tempWorkspace, err := m.Workspace.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Workspace = &tempWorkspace
	}
	to.GeoFencingRadius = m.GeoFencingRadius
	to.GeoFencingLat = m.GeoFencingLat
	to.GeoFencingLon = m.GeoFencingLon
	to.GeoFencingZoomMin = m.GeoFencingZoomMin
	to.GeoFencingZoomMax = m.GeoFencingZoomMax
	to.IncludeReviews = m.IncludeReviews
	to.IncludePhotos = m.IncludePhotos
	to.IncludeBusinessHours = m.IncludeBusinessHours
	to.MaxReviewsPerBusiness = m.MaxReviewsPerBusiness
	to.OutputFormat = ScrapingWorkflow_OutputFormat(ScrapingWorkflow_OutputFormat_value[m.OutputFormat])
	to.OutputDestination = m.OutputDestination
	if m.DataRetention != nil {
		to.DataRetention = durationpb.New(*m.DataRetention)
	}
	to.AnonymizePii = m.AnonymizePii
	to.NotificationWebhookUrl = m.NotificationWebhookUrl
	to.NotificationSlackChannel = m.NotificationSlackChannel
	to.NotificationEmailGroup = m.NotificationEmailGroup
	to.NotificationNotifyOnStart = m.NotificationNotifyOnStart
	to.NotificationNotifyOnComplete = m.NotificationNotifyOnComplete
	to.NotificationNotifyOnFailure = m.NotificationNotifyOnFailure
	if m.ContentFilterAllowedCountries != nil {
		to.ContentFilterAllowedCountries = make(pq.StringArray, len(m.ContentFilterAllowedCountries))
		copy(to.ContentFilterAllowedCountries, m.ContentFilterAllowedCountries)
	}
	if m.ContentFilterExcludedTypes != nil {
		to.ContentFilterExcludedTypes = make(pq.StringArray, len(m.ContentFilterExcludedTypes))
		copy(to.ContentFilterExcludedTypes, m.ContentFilterExcludedTypes)
	}
	to.ContentFilterMinimumRating = m.ContentFilterMinimumRating
	to.ContentFilterMinimumReviews = m.ContentFilterMinimumReviews
	to.QosMaxConcurrentRequests = m.QosMaxConcurrentRequests
	to.QosMaxRetries = m.QosMaxRetries
	if m.QosRequestTimeout != nil {
		to.QosRequestTimeout = durationpb.New(*m.QosRequestTimeout)
	}
	to.QosEnableJavascript = m.QosEnableJavascript
	to.RespectRobotsTxt = m.RespectRobotsTxt
	to.AcceptTermsOfService = m.AcceptTermsOfService
	to.UserAgent = m.UserAgent
	if posthook, ok := interface{}(m).(ScrapingWorkflowWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ScrapingWorkflow the arg will be the target, the caller the one being converted from

// ScrapingWorkflowBeforeToORM called before default ToORM code
type ScrapingWorkflowWithBeforeToORM interface {
	BeforeToORM(context.Context, *ScrapingWorkflowORM) error
}

// ScrapingWorkflowAfterToORM called after default ToORM code
type ScrapingWorkflowWithAfterToORM interface {
	AfterToORM(context.Context, *ScrapingWorkflowORM) error
}

// ScrapingWorkflowBeforeToPB called before default ToPB code
type ScrapingWorkflowWithBeforeToPB interface {
	BeforeToPB(context.Context, *ScrapingWorkflow) error
}

// ScrapingWorkflowAfterToPB called after default ToPB code
type ScrapingWorkflowWithAfterToPB interface {
	AfterToPB(context.Context, *ScrapingWorkflow) error
}

type LeadORM struct {
	Address                  string
	AlternatePhones          pq.StringArray `gorm:"type:text[]"`
	Amenities                pq.StringArray `gorm:"type:text[]"`
	BusinessStatus           string
	BusinessType             string         `gorm:"type:text"`
	Certifications           pq.StringArray `gorm:"type:text[]"`
	City                     string         `gorm:"index:idx_leads_city"`
	CmsUsed                  string
	ContactEmail             string
	ContactPersonName        string
	ContactPersonTitle       string
	Count                    int32
	Country                  string     `gorm:"index:idx_leads_country"`
	CreatedAt                *time.Time `gorm:"index:idx_leads_created_at"`
	DataSourceVersion        string
	DeletedAt                *time.Time
	EcommercePlatforms       pq.StringArray `gorm:"type:text[]"`
	EmployeeCount            int32
	EnergySources            pq.StringArray `gorm:"type:text[]"`
	EstimatedRevenue         int64
	ExportControlStatus      string
	FoundedYear              int32
	FundingStage             string
	GoogleMapsUrl            string
	GoogleMyBusinessCategory string
	GoogleRating             float32
	HasLitigationHistory     bool
	HasSslCertificate        bool
	Id                       uint64 `gorm:"primaryKey"`
	Industry                 string
	IsFranchise              bool
	IsGreenCertified         bool
	IsPublicCompany          bool
	Job                      *ScrapingJobORM `gorm:"foreignKey:ScrapingJobId;references:Id"`
	LastProductLaunch        *time.Time
	LastUpdated              *time.Time
	Latitude                 float64
	LicenseNumber            string
	Longitude                float64
	MainPhotoUrl             string
	NaicsCode                string
	Name                     string         `gorm:"index:idx_leads_name"`
	NearbyLandmarks          pq.StringArray `gorm:"type:text[]"`
	Neighborhood             string
	OrgId                    string `gorm:"index:idx_leads_org_id"`
	OutdoorSeating           bool
	ParentCompany            string
	ParkingAvailable         bool
	PaymentMethods           pq.StringArray `gorm:"type:text[]"`
	Phone                    string         `gorm:"index:idx_leads_phone"`
	PhotoReferences          pq.StringArray `gorm:"type:text[]"`
	PlaceId                  string         `gorm:"unique;index:idx_leads_place_id"`
	Rating                   float32
	RatingCategory           string
	RecentAnnouncements      pq.StringArray      `gorm:"type:text[]"`
	RegularHours             []*BusinessHoursORM `gorm:"foreignKey:RegularHoursLeadId;references:Id"`
	RevenueRange             string
	ReviewCount              int32
	Reviews                  []*ReviewORM `gorm:"foreignKey:LeadId;references:Id"`
	ScrapingJobId            *uint64
	ScrapingSessionId        string
	SeoKeywords              pq.StringArray `gorm:"type:text[]"`
	ServesVegetarianFood     bool
	SicCode                  string
	SpecialHours             []*BusinessHoursORM `gorm:"foreignKey:SpecialHoursLeadId;references:Id"`
	State                    string              `gorm:"index:idx_leads_state"`
	Subsidiaries             pq.StringArray      `gorm:"type:text[]"`
	SustainabilityRating     string
	TenantId                 string `gorm:"index:idx_leads_tenant_id"`
	Timezone                 string
	TransportationAccess     string
	Types                    pq.StringArray `gorm:"type:text[]"`
	UnspscCode               string
	UpdatedAt                *time.Time
	UsesGoogleAds            bool
	Website                  string
	WebsiteLoadSpeed         float32
	WheelchairAccessible     bool
	Workspace                *WorkspaceORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	WorkspaceId              *uint64
}

// TableName overrides the default tablename generated by GORM
func (LeadORM) TableName() string {
	return "leads"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Lead) ToORM(ctx context.Context) (LeadORM, error) {
	to := LeadORM{}
	var err error
	if prehook, ok := interface{}(m).(LeadWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Website = m.Website
	to.Phone = m.Phone
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.Country = m.Country
	to.Latitude = m.Latitude
	to.Longitude = m.Longitude
	to.GoogleRating = m.GoogleRating
	to.ReviewCount = m.ReviewCount
	to.Industry = m.Industry
	to.EmployeeCount = m.EmployeeCount
	to.EstimatedRevenue = m.EstimatedRevenue
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if m.Job != nil {
		tempJob, err := m.Job.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Job = &tempJob
	}
	if m.Workspace != nil {
		tempWorkspace, err := m.Workspace.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Workspace = &tempWorkspace
	}
	to.PlaceId = m.PlaceId
	to.GoogleMapsUrl = m.GoogleMapsUrl
	to.BusinessStatus = m.BusinessStatus
	for _, v := range m.RegularHours {
		if v != nil {
			if tempRegularHours, cErr := v.ToORM(ctx); cErr == nil {
				to.RegularHours = append(to.RegularHours, &tempRegularHours)
			} else {
				return to, cErr
			}
		} else {
			to.RegularHours = append(to.RegularHours, nil)
		}
	}
	for _, v := range m.SpecialHours {
		if v != nil {
			if tempSpecialHours, cErr := v.ToORM(ctx); cErr == nil {
				to.SpecialHours = append(to.SpecialHours, &tempSpecialHours)
			} else {
				return to, cErr
			}
		} else {
			to.SpecialHours = append(to.SpecialHours, nil)
		}
	}
	if m.PhotoReferences != nil {
		to.PhotoReferences = make(pq.StringArray, len(m.PhotoReferences))
		copy(to.PhotoReferences, m.PhotoReferences)
	}
	to.MainPhotoUrl = m.MainPhotoUrl
	for _, v := range m.Reviews {
		if v != nil {
			if tempReviews, cErr := v.ToORM(ctx); cErr == nil {
				to.Reviews = append(to.Reviews, &tempReviews)
			} else {
				return to, cErr
			}
		} else {
			to.Reviews = append(to.Reviews, nil)
		}
	}
	if m.Types != nil {
		to.Types = make(pq.StringArray, len(m.Types))
		copy(to.Types, m.Types)
	}
	if m.Amenities != nil {
		to.Amenities = make(pq.StringArray, len(m.Amenities))
		copy(to.Amenities, m.Amenities)
	}
	to.ServesVegetarianFood = m.ServesVegetarianFood
	to.OutdoorSeating = m.OutdoorSeating
	if m.PaymentMethods != nil {
		to.PaymentMethods = make(pq.StringArray, len(m.PaymentMethods))
		copy(to.PaymentMethods, m.PaymentMethods)
	}
	to.WheelchairAccessible = m.WheelchairAccessible
	to.ParkingAvailable = m.ParkingAvailable
	// Repeated type SocialMediaEntry is not an ORMable message type
	to.RatingCategory = m.RatingCategory
	to.Rating = m.Rating
	to.Count = m.Count
	if m.LastUpdated != nil {
		t := m.LastUpdated.AsTime()
		to.LastUpdated = &t
	}
	to.DataSourceVersion = m.DataSourceVersion
	to.ScrapingSessionId = m.ScrapingSessionId
	if m.AlternatePhones != nil {
		to.AlternatePhones = make(pq.StringArray, len(m.AlternatePhones))
		copy(to.AlternatePhones, m.AlternatePhones)
	}
	to.ContactPersonName = m.ContactPersonName
	to.ContactPersonTitle = m.ContactPersonTitle
	to.ContactEmail = m.ContactEmail
	to.FoundedYear = m.FoundedYear
	to.BusinessType = m.BusinessType
	if m.Certifications != nil {
		to.Certifications = make(pq.StringArray, len(m.Certifications))
		copy(to.Certifications, m.Certifications)
	}
	to.LicenseNumber = m.LicenseNumber
	to.RevenueRange = Lead_RevenueRange_name[int32(m.RevenueRange)]
	to.FundingStage = m.FundingStage
	to.IsPublicCompany = m.IsPublicCompany
	to.WebsiteLoadSpeed = m.WebsiteLoadSpeed
	to.HasSslCertificate = m.HasSslCertificate
	to.CmsUsed = m.CmsUsed
	if m.EcommercePlatforms != nil {
		to.EcommercePlatforms = make(pq.StringArray, len(m.EcommercePlatforms))
		copy(to.EcommercePlatforms, m.EcommercePlatforms)
	}
	to.Timezone = m.Timezone
	to.Neighborhood = m.Neighborhood
	if m.NearbyLandmarks != nil {
		to.NearbyLandmarks = make(pq.StringArray, len(m.NearbyLandmarks))
		copy(to.NearbyLandmarks, m.NearbyLandmarks)
	}
	to.TransportationAccess = m.TransportationAccess
	// Repeated type enum is not an ORMable message type
	to.ParentCompany = m.ParentCompany
	if m.Subsidiaries != nil {
		to.Subsidiaries = make(pq.StringArray, len(m.Subsidiaries))
		copy(to.Subsidiaries, m.Subsidiaries)
	}
	to.IsFranchise = m.IsFranchise
	if m.SeoKeywords != nil {
		to.SeoKeywords = make(pq.StringArray, len(m.SeoKeywords))
		copy(to.SeoKeywords, m.SeoKeywords)
	}
	to.UsesGoogleAds = m.UsesGoogleAds
	to.GoogleMyBusinessCategory = m.GoogleMyBusinessCategory
	to.NaicsCode = m.NaicsCode
	to.SicCode = m.SicCode
	to.UnspscCode = m.UnspscCode
	to.IsGreenCertified = m.IsGreenCertified
	if m.EnergySources != nil {
		to.EnergySources = make(pq.StringArray, len(m.EnergySources))
		copy(to.EnergySources, m.EnergySources)
	}
	to.SustainabilityRating = m.SustainabilityRating
	if m.RecentAnnouncements != nil {
		to.RecentAnnouncements = make(pq.StringArray, len(m.RecentAnnouncements))
		copy(to.RecentAnnouncements, m.RecentAnnouncements)
	}
	if m.LastProductLaunch != nil {
		t := m.LastProductLaunch.AsTime()
		to.LastProductLaunch = &t
	}
	to.HasLitigationHistory = m.HasLitigationHistory
	to.ExportControlStatus = m.ExportControlStatus
	if posthook, ok := interface{}(m).(LeadWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LeadORM) ToPB(ctx context.Context) (Lead, error) {
	to := Lead{}
	var err error
	if prehook, ok := interface{}(m).(LeadWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Website = m.Website
	to.Phone = m.Phone
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.Country = m.Country
	to.Latitude = m.Latitude
	to.Longitude = m.Longitude
	to.GoogleRating = m.GoogleRating
	to.ReviewCount = m.ReviewCount
	to.Industry = m.Industry
	to.EmployeeCount = m.EmployeeCount
	to.EstimatedRevenue = m.EstimatedRevenue
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if m.Job != nil {
		tempJob, err := m.Job.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Job = &tempJob
	}
	if m.Workspace != nil {
		tempWorkspace, err := m.Workspace.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Workspace = &tempWorkspace
	}
	to.PlaceId = m.PlaceId
	to.GoogleMapsUrl = m.GoogleMapsUrl
	to.BusinessStatus = m.BusinessStatus
	for _, v := range m.RegularHours {
		if v != nil {
			if tempRegularHours, cErr := v.ToPB(ctx); cErr == nil {
				to.RegularHours = append(to.RegularHours, &tempRegularHours)
			} else {
				return to, cErr
			}
		} else {
			to.RegularHours = append(to.RegularHours, nil)
		}
	}
	for _, v := range m.SpecialHours {
		if v != nil {
			if tempSpecialHours, cErr := v.ToPB(ctx); cErr == nil {
				to.SpecialHours = append(to.SpecialHours, &tempSpecialHours)
			} else {
				return to, cErr
			}
		} else {
			to.SpecialHours = append(to.SpecialHours, nil)
		}
	}
	if m.PhotoReferences != nil {
		to.PhotoReferences = make(pq.StringArray, len(m.PhotoReferences))
		copy(to.PhotoReferences, m.PhotoReferences)
	}
	to.MainPhotoUrl = m.MainPhotoUrl
	for _, v := range m.Reviews {
		if v != nil {
			if tempReviews, cErr := v.ToPB(ctx); cErr == nil {
				to.Reviews = append(to.Reviews, &tempReviews)
			} else {
				return to, cErr
			}
		} else {
			to.Reviews = append(to.Reviews, nil)
		}
	}
	if m.Types != nil {
		to.Types = make(pq.StringArray, len(m.Types))
		copy(to.Types, m.Types)
	}
	if m.Amenities != nil {
		to.Amenities = make(pq.StringArray, len(m.Amenities))
		copy(to.Amenities, m.Amenities)
	}
	to.ServesVegetarianFood = m.ServesVegetarianFood
	to.OutdoorSeating = m.OutdoorSeating
	if m.PaymentMethods != nil {
		to.PaymentMethods = make(pq.StringArray, len(m.PaymentMethods))
		copy(to.PaymentMethods, m.PaymentMethods)
	}
	to.WheelchairAccessible = m.WheelchairAccessible
	to.ParkingAvailable = m.ParkingAvailable
	// Repeated type SocialMediaEntry is not an ORMable message type
	to.RatingCategory = m.RatingCategory
	to.Rating = m.Rating
	to.Count = m.Count
	if m.LastUpdated != nil {
		to.LastUpdated = timestamppb.New(*m.LastUpdated)
	}
	to.DataSourceVersion = m.DataSourceVersion
	to.ScrapingSessionId = m.ScrapingSessionId
	if m.AlternatePhones != nil {
		to.AlternatePhones = make(pq.StringArray, len(m.AlternatePhones))
		copy(to.AlternatePhones, m.AlternatePhones)
	}
	to.ContactPersonName = m.ContactPersonName
	to.ContactPersonTitle = m.ContactPersonTitle
	to.ContactEmail = m.ContactEmail
	to.FoundedYear = m.FoundedYear
	to.BusinessType = m.BusinessType
	if m.Certifications != nil {
		to.Certifications = make(pq.StringArray, len(m.Certifications))
		copy(to.Certifications, m.Certifications)
	}
	to.LicenseNumber = m.LicenseNumber
	to.RevenueRange = Lead_RevenueRange(Lead_RevenueRange_value[m.RevenueRange])
	to.FundingStage = m.FundingStage
	to.IsPublicCompany = m.IsPublicCompany
	to.WebsiteLoadSpeed = m.WebsiteLoadSpeed
	to.HasSslCertificate = m.HasSslCertificate
	to.CmsUsed = m.CmsUsed
	if m.EcommercePlatforms != nil {
		to.EcommercePlatforms = make(pq.StringArray, len(m.EcommercePlatforms))
		copy(to.EcommercePlatforms, m.EcommercePlatforms)
	}
	to.Timezone = m.Timezone
	to.Neighborhood = m.Neighborhood
	if m.NearbyLandmarks != nil {
		to.NearbyLandmarks = make(pq.StringArray, len(m.NearbyLandmarks))
		copy(to.NearbyLandmarks, m.NearbyLandmarks)
	}
	to.TransportationAccess = m.TransportationAccess
	// Repeated type enum is not an ORMable message type
	to.ParentCompany = m.ParentCompany
	if m.Subsidiaries != nil {
		to.Subsidiaries = make(pq.StringArray, len(m.Subsidiaries))
		copy(to.Subsidiaries, m.Subsidiaries)
	}
	to.IsFranchise = m.IsFranchise
	if m.SeoKeywords != nil {
		to.SeoKeywords = make(pq.StringArray, len(m.SeoKeywords))
		copy(to.SeoKeywords, m.SeoKeywords)
	}
	to.UsesGoogleAds = m.UsesGoogleAds
	to.GoogleMyBusinessCategory = m.GoogleMyBusinessCategory
	to.NaicsCode = m.NaicsCode
	to.SicCode = m.SicCode
	to.UnspscCode = m.UnspscCode
	to.IsGreenCertified = m.IsGreenCertified
	if m.EnergySources != nil {
		to.EnergySources = make(pq.StringArray, len(m.EnergySources))
		copy(to.EnergySources, m.EnergySources)
	}
	to.SustainabilityRating = m.SustainabilityRating
	if m.RecentAnnouncements != nil {
		to.RecentAnnouncements = make(pq.StringArray, len(m.RecentAnnouncements))
		copy(to.RecentAnnouncements, m.RecentAnnouncements)
	}
	if m.LastProductLaunch != nil {
		to.LastProductLaunch = timestamppb.New(*m.LastProductLaunch)
	}
	to.HasLitigationHistory = m.HasLitigationHistory
	to.ExportControlStatus = m.ExportControlStatus
	if posthook, ok := interface{}(m).(LeadWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Lead the arg will be the target, the caller the one being converted from

// LeadBeforeToORM called before default ToORM code
type LeadWithBeforeToORM interface {
	BeforeToORM(context.Context, *LeadORM) error
}

// LeadAfterToORM called after default ToORM code
type LeadWithAfterToORM interface {
	AfterToORM(context.Context, *LeadORM) error
}

// LeadBeforeToPB called before default ToPB code
type LeadWithBeforeToPB interface {
	BeforeToPB(context.Context, *Lead) error
}

// LeadAfterToPB called after default ToPB code
type LeadWithAfterToPB interface {
	AfterToPB(context.Context, *Lead) error
}

type ReviewORM struct {
	Author          string `gorm:"index:idx_reviews_author"`
	CreatedAt       *time.Time
	DeletedAt       *time.Time
	Id              uint64 `gorm:"primaryKey"`
	Language        string
	LeadId          *uint64
	ProfilePhotoUrl string
	Rating          float32
	ReviewCount     int32
	Text            string
	Time            *time.Time `gorm:"index:idx_reviews_time"`
	UpdatedAt       *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ReviewORM) TableName() string {
	return "reviews"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Review) ToORM(ctx context.Context) (ReviewORM, error) {
	to := ReviewORM{}
	var err error
	if prehook, ok := interface{}(m).(ReviewWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Author = m.Author
	to.Rating = m.Rating
	to.Text = m.Text
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	to.Language = m.Language
	to.ProfilePhotoUrl = m.ProfilePhotoUrl
	to.ReviewCount = m.ReviewCount
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(ReviewWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReviewORM) ToPB(ctx context.Context) (Review, error) {
	to := Review{}
	var err error
	if prehook, ok := interface{}(m).(ReviewWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Author = m.Author
	to.Rating = m.Rating
	to.Text = m.Text
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	to.Language = m.Language
	to.ProfilePhotoUrl = m.ProfilePhotoUrl
	to.ReviewCount = m.ReviewCount
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(ReviewWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Review the arg will be the target, the caller the one being converted from

// ReviewBeforeToORM called before default ToORM code
type ReviewWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReviewORM) error
}

// ReviewAfterToORM called after default ToORM code
type ReviewWithAfterToORM interface {
	AfterToORM(context.Context, *ReviewORM) error
}

// ReviewBeforeToPB called before default ToPB code
type ReviewWithBeforeToPB interface {
	BeforeToPB(context.Context, *Review) error
}

// ReviewAfterToPB called after default ToPB code
type ReviewWithAfterToPB interface {
	AfterToPB(context.Context, *Review) error
}

type BusinessHoursORM struct {
	CloseTime          string
	Closed             bool
	CreatedAt          *time.Time
	Day                string
	DeletedAt          *time.Time
	Id                 uint64 `gorm:"primaryKey"`
	OpenTime           string
	RegularHoursLeadId *uint64
	SpecialHoursLeadId *uint64
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (BusinessHoursORM) TableName() string {
	return "business_hours"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessHours) ToORM(ctx context.Context) (BusinessHoursORM, error) {
	to := BusinessHoursORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessHoursWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Day = BusinessHours_DayOfWeek_name[int32(m.Day)]
	to.OpenTime = m.OpenTime
	to.CloseTime = m.CloseTime
	to.Closed = m.Closed
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(BusinessHoursWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessHoursORM) ToPB(ctx context.Context) (BusinessHours, error) {
	to := BusinessHours{}
	var err error
	if prehook, ok := interface{}(m).(BusinessHoursWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Day = BusinessHours_DayOfWeek(BusinessHours_DayOfWeek_value[m.Day])
	to.OpenTime = m.OpenTime
	to.CloseTime = m.CloseTime
	to.Closed = m.Closed
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(BusinessHoursWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessHours the arg will be the target, the caller the one being converted from

// BusinessHoursBeforeToORM called before default ToORM code
type BusinessHoursWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessHoursORM) error
}

// BusinessHoursAfterToORM called after default ToORM code
type BusinessHoursWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessHoursORM) error
}

// BusinessHoursBeforeToPB called before default ToPB code
type BusinessHoursWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessHours) error
}

// BusinessHoursAfterToPB called after default ToPB code
type BusinessHoursWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessHours) error
}

type AccountSettingsORM struct {
	AccountId            *uint64
	AutoPurgeEnabled     bool
	CreatedAt            *time.Time
	DefaultDataRetention *time.Duration
	DeletedAt            *time.Time
	EmailNotifications   bool
	Id                   uint64 `gorm:"primaryKey"`
	Require_2Fa          bool
	SessionTimeout       *time.Duration
	SlackNotifications   bool
	UpdatedAt            *time.Time
}

// TableName overrides the default tablename generated by GORM
func (AccountSettingsORM) TableName() string {
	return "account_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountSettings) ToORM(ctx context.Context) (AccountSettingsORM, error) {
	to := AccountSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.EmailNotifications = m.EmailNotifications
	to.SlackNotifications = m.SlackNotifications
	if m.DefaultDataRetention != nil {
		t := m.DefaultDataRetention.AsDuration()
		to.DefaultDataRetention = &t
	}
	to.AutoPurgeEnabled = m.AutoPurgeEnabled
	to.Require_2Fa = m.Require_2Fa
	if m.SessionTimeout != nil {
		t := m.SessionTimeout.AsDuration()
		to.SessionTimeout = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(AccountSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountSettingsORM) ToPB(ctx context.Context) (AccountSettings, error) {
	to := AccountSettings{}
	var err error
	if prehook, ok := interface{}(m).(AccountSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.EmailNotifications = m.EmailNotifications
	to.SlackNotifications = m.SlackNotifications
	if m.DefaultDataRetention != nil {
		to.DefaultDataRetention = durationpb.New(*m.DefaultDataRetention)
	}
	to.AutoPurgeEnabled = m.AutoPurgeEnabled
	to.Require_2Fa = m.Require_2Fa
	if m.SessionTimeout != nil {
		to.SessionTimeout = durationpb.New(*m.SessionTimeout)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(AccountSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountSettings the arg will be the target, the caller the one being converted from

// AccountSettingsBeforeToORM called before default ToORM code
type AccountSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountSettingsORM) error
}

// AccountSettingsAfterToORM called after default ToORM code
type AccountSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *AccountSettingsORM) error
}

// AccountSettingsBeforeToPB called before default ToPB code
type AccountSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountSettings) error
}

// AccountSettingsAfterToPB called after default ToPB code
type AccountSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *AccountSettings) error
}

type APIKeyORM struct {
	Account                    *AccountORM `gorm:"foreignKey:AccountId;references:Id"`
	AccountId                  *uint64
	AlertEmails                pq.StringArray `gorm:"type:text[]"`
	AlertOnErrorSpike          bool
	AlertOnQuotaThreshold      bool
	AllowedDomains             pq.StringArray `gorm:"type:text[]"`
	AllowedEnvironments        pq.StringArray `gorm:"type:text[]"`
	AllowedIps                 pq.StringArray `gorm:"type:text[]"`
	AllowedSignatureAlgorithms pq.StringArray `gorm:"type:text[]"`
	ApiVersion                 string
	ApprovedIntegrations       pq.StringArray `gorm:"type:text[]"`
	AverageResponseTime        float32
	BillingTier                string
	ClientCertificateHash      string
	ClientSecretHash           string
	ComplianceStandards        pq.StringArray `gorm:"type:text[]"`
	ConcurrentRequests         int32
	CostPerRequest             float32
	CreatedAt                  *time.Time
	DataClassification         string
	DataResidency              string
	DeletedAt                  *time.Time
	Description                string
	DocumentationUrl           string
	Encrypted                  bool
	EndpointUsageJson          []byte `gorm:"type:bytea"`
	EnforceHttps               bool
	EnforceMutualTls           bool
	EnforceSigning             bool
	ErrorAlertThreshold        float32
	ErrorRatesJson             []byte     `gorm:"type:bytea"`
	ExpiresAt                  *time.Time `gorm:"index:idx_api_keys_expires"`
	Id                         uint64     `gorm:"primaryKey"`
	IsTestKey                  bool
	KeyHash                    string `gorm:"unique"`
	KeyPrefix                  string `gorm:"index:idx_api_keys_prefix"`
	LastRotatedAt              *time.Time
	LastRotationDate           *time.Time
	LastRotationReason         string
	LastSecurityReviewAt       *time.Time
	LastUsedAt                 *time.Time `gorm:"index:idx_api_keys_last_used"`
	LogAllRequests             bool
	MetadataJson               []byte         `gorm:"type:bytea"`
	MonitoringIntegrations     pq.StringArray `gorm:"type:text[]"`
	MonthlyRequestQuota        int64
	Name                       string `gorm:"index:idx_api_keys_name"`
	OrgId                      string `gorm:"index:idx_api_keys_org_id"`
	QuotaAlertThreshold        float32
	RecentErrors               []byte `gorm:"type:bytea"`
	RequestsPerDay             int32
	RequestsPerSecond          int32
	RequireRequestSigning      bool
	RequiresAuditLogging       bool
	RequiresClientSecret       bool
	RotationFrequencyDays      int32
	Scopes                     pq.StringArray `gorm:"type:text[]"`
	Status                     string         `gorm:"index:idx_api_keys_status"`
	SuccessRate                float32
	SuccessfulRequestsCount    int32
	SupportContact             string
	SupportedFeatures          pq.StringArray `gorm:"type:text[]"`
	Tags                       pq.StringArray `gorm:"type:text[]"`
	TenantId                   string         `gorm:"index:idx_api_keys_tenant_id"`
	TotalErrors                int64
	TotalRequests              int64
	UpdatedAt                  *time.Time
	WebhookUrl                 string
	Workspace                  *WorkspaceORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	WorkspaceId                *uint64
}

// TableName overrides the default tablename generated by GORM
func (APIKeyORM) TableName() string {
	return "api_keys"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *APIKey) ToORM(ctx context.Context) (APIKeyORM, error) {
	to := APIKeyORM{}
	var err error
	if prehook, ok := interface{}(m).(APIKeyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.KeyHash = m.KeyHash
	to.KeyPrefix = m.KeyPrefix
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.Scopes != nil {
		to.Scopes = make(pq.StringArray, len(m.Scopes))
		copy(to.Scopes, m.Scopes)
	}
	if m.AllowedIps != nil {
		to.AllowedIps = make(pq.StringArray, len(m.AllowedIps))
		copy(to.AllowedIps, m.AllowedIps)
	}
	if m.AllowedDomains != nil {
		to.AllowedDomains = make(pq.StringArray, len(m.AllowedDomains))
		copy(to.AllowedDomains, m.AllowedDomains)
	}
	if m.AllowedEnvironments != nil {
		to.AllowedEnvironments = make(pq.StringArray, len(m.AllowedEnvironments))
		copy(to.AllowedEnvironments, m.AllowedEnvironments)
	}
	to.IsTestKey = m.IsTestKey
	to.RequestsPerSecond = m.RequestsPerSecond
	to.RequestsPerDay = m.RequestsPerDay
	to.ConcurrentRequests = m.ConcurrentRequests
	to.MonthlyRequestQuota = m.MonthlyRequestQuota
	to.CostPerRequest = m.CostPerRequest
	to.BillingTier = m.BillingTier
	to.TotalRequests = m.TotalRequests
	to.TotalErrors = m.TotalErrors
	if m.LastUsedAt != nil {
		t := m.LastUsedAt.AsTime()
		to.LastUsedAt = &t
	}
	to.AverageResponseTime = m.AverageResponseTime
	to.EndpointUsageJson = m.EndpointUsageJson
	to.ErrorRatesJson = m.ErrorRatesJson
	to.RecentErrors = m.RecentErrors
	to.SuccessfulRequestsCount = m.SuccessfulRequestsCount
	to.SuccessRate = m.SuccessRate
	to.Status = APIKey_Status_name[int32(m.Status)]
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.ExpiresAt != nil {
		t := m.ExpiresAt.AsTime()
		to.ExpiresAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if m.LastRotatedAt != nil {
		t := m.LastRotatedAt.AsTime()
		to.LastRotatedAt = &t
	}
	if m.LastSecurityReviewAt != nil {
		t := m.LastSecurityReviewAt.AsTime()
		to.LastSecurityReviewAt = &t
	}
	to.RequiresClientSecret = m.RequiresClientSecret
	to.ClientSecretHash = m.ClientSecretHash
	to.EnforceHttps = m.EnforceHttps
	to.EnforceSigning = m.EnforceSigning
	if m.AllowedSignatureAlgorithms != nil {
		to.AllowedSignatureAlgorithms = make(pq.StringArray, len(m.AllowedSignatureAlgorithms))
		copy(to.AllowedSignatureAlgorithms, m.AllowedSignatureAlgorithms)
	}
	to.EnforceMutualTls = m.EnforceMutualTls
	to.ClientCertificateHash = m.ClientCertificateHash
	to.RequireRequestSigning = m.RequireRequestSigning
	to.Description = m.Description
	to.MetadataJson = m.MetadataJson
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.ApiVersion = m.ApiVersion
	if m.SupportedFeatures != nil {
		to.SupportedFeatures = make(pq.StringArray, len(m.SupportedFeatures))
		copy(to.SupportedFeatures, m.SupportedFeatures)
	}
	to.DocumentationUrl = m.DocumentationUrl
	to.SupportContact = m.SupportContact
	if m.Account != nil {
		tempAccount, err := m.Account.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	if m.Workspace != nil {
		tempWorkspace, err := m.Workspace.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Workspace = &tempWorkspace
	}
	to.LogAllRequests = m.LogAllRequests
	to.LastRotationReason = m.LastRotationReason
	if m.LastRotationDate != nil {
		t := m.LastRotationDate.AsTime()
		to.LastRotationDate = &t
	}
	to.RotationFrequencyDays = m.RotationFrequencyDays
	if m.ComplianceStandards != nil {
		to.ComplianceStandards = make(pq.StringArray, len(m.ComplianceStandards))
		copy(to.ComplianceStandards, m.ComplianceStandards)
	}
	to.RequiresAuditLogging = m.RequiresAuditLogging
	to.DataResidency = m.DataResidency
	if m.ApprovedIntegrations != nil {
		to.ApprovedIntegrations = make(pq.StringArray, len(m.ApprovedIntegrations))
		copy(to.ApprovedIntegrations, m.ApprovedIntegrations)
	}
	if m.AlertEmails != nil {
		to.AlertEmails = make(pq.StringArray, len(m.AlertEmails))
		copy(to.AlertEmails, m.AlertEmails)
	}
	to.WebhookUrl = m.WebhookUrl
	to.AlertOnQuotaThreshold = m.AlertOnQuotaThreshold
	to.QuotaAlertThreshold = m.QuotaAlertThreshold
	to.AlertOnErrorSpike = m.AlertOnErrorSpike
	to.ErrorAlertThreshold = m.ErrorAlertThreshold
	if m.MonitoringIntegrations != nil {
		to.MonitoringIntegrations = make(pq.StringArray, len(m.MonitoringIntegrations))
		copy(to.MonitoringIntegrations, m.MonitoringIntegrations)
	}
	to.Encrypted = m.Encrypted
	to.DataClassification = m.DataClassification
	if posthook, ok := interface{}(m).(APIKeyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *APIKeyORM) ToPB(ctx context.Context) (APIKey, error) {
	to := APIKey{}
	var err error
	if prehook, ok := interface{}(m).(APIKeyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.KeyHash = m.KeyHash
	to.KeyPrefix = m.KeyPrefix
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.Scopes != nil {
		to.Scopes = make(pq.StringArray, len(m.Scopes))
		copy(to.Scopes, m.Scopes)
	}
	if m.AllowedIps != nil {
		to.AllowedIps = make(pq.StringArray, len(m.AllowedIps))
		copy(to.AllowedIps, m.AllowedIps)
	}
	if m.AllowedDomains != nil {
		to.AllowedDomains = make(pq.StringArray, len(m.AllowedDomains))
		copy(to.AllowedDomains, m.AllowedDomains)
	}
	if m.AllowedEnvironments != nil {
		to.AllowedEnvironments = make(pq.StringArray, len(m.AllowedEnvironments))
		copy(to.AllowedEnvironments, m.AllowedEnvironments)
	}
	to.IsTestKey = m.IsTestKey
	to.RequestsPerSecond = m.RequestsPerSecond
	to.RequestsPerDay = m.RequestsPerDay
	to.ConcurrentRequests = m.ConcurrentRequests
	to.MonthlyRequestQuota = m.MonthlyRequestQuota
	to.CostPerRequest = m.CostPerRequest
	to.BillingTier = m.BillingTier
	to.TotalRequests = m.TotalRequests
	to.TotalErrors = m.TotalErrors
	if m.LastUsedAt != nil {
		to.LastUsedAt = timestamppb.New(*m.LastUsedAt)
	}
	to.AverageResponseTime = m.AverageResponseTime
	to.EndpointUsageJson = m.EndpointUsageJson
	to.ErrorRatesJson = m.ErrorRatesJson
	to.RecentErrors = m.RecentErrors
	to.SuccessfulRequestsCount = m.SuccessfulRequestsCount
	to.SuccessRate = m.SuccessRate
	to.Status = APIKey_Status(APIKey_Status_value[m.Status])
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.ExpiresAt != nil {
		to.ExpiresAt = timestamppb.New(*m.ExpiresAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if m.LastRotatedAt != nil {
		to.LastRotatedAt = timestamppb.New(*m.LastRotatedAt)
	}
	if m.LastSecurityReviewAt != nil {
		to.LastSecurityReviewAt = timestamppb.New(*m.LastSecurityReviewAt)
	}
	to.RequiresClientSecret = m.RequiresClientSecret
	to.ClientSecretHash = m.ClientSecretHash
	to.EnforceHttps = m.EnforceHttps
	to.EnforceSigning = m.EnforceSigning
	if m.AllowedSignatureAlgorithms != nil {
		to.AllowedSignatureAlgorithms = make(pq.StringArray, len(m.AllowedSignatureAlgorithms))
		copy(to.AllowedSignatureAlgorithms, m.AllowedSignatureAlgorithms)
	}
	to.EnforceMutualTls = m.EnforceMutualTls
	to.ClientCertificateHash = m.ClientCertificateHash
	to.RequireRequestSigning = m.RequireRequestSigning
	to.Description = m.Description
	to.MetadataJson = m.MetadataJson
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.ApiVersion = m.ApiVersion
	if m.SupportedFeatures != nil {
		to.SupportedFeatures = make(pq.StringArray, len(m.SupportedFeatures))
		copy(to.SupportedFeatures, m.SupportedFeatures)
	}
	to.DocumentationUrl = m.DocumentationUrl
	to.SupportContact = m.SupportContact
	if m.Account != nil {
		tempAccount, err := m.Account.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	if m.Workspace != nil {
		tempWorkspace, err := m.Workspace.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Workspace = &tempWorkspace
	}
	to.LogAllRequests = m.LogAllRequests
	to.LastRotationReason = m.LastRotationReason
	if m.LastRotationDate != nil {
		to.LastRotationDate = timestamppb.New(*m.LastRotationDate)
	}
	to.RotationFrequencyDays = m.RotationFrequencyDays
	if m.ComplianceStandards != nil {
		to.ComplianceStandards = make(pq.StringArray, len(m.ComplianceStandards))
		copy(to.ComplianceStandards, m.ComplianceStandards)
	}
	to.RequiresAuditLogging = m.RequiresAuditLogging
	to.DataResidency = m.DataResidency
	if m.ApprovedIntegrations != nil {
		to.ApprovedIntegrations = make(pq.StringArray, len(m.ApprovedIntegrations))
		copy(to.ApprovedIntegrations, m.ApprovedIntegrations)
	}
	if m.AlertEmails != nil {
		to.AlertEmails = make(pq.StringArray, len(m.AlertEmails))
		copy(to.AlertEmails, m.AlertEmails)
	}
	to.WebhookUrl = m.WebhookUrl
	to.AlertOnQuotaThreshold = m.AlertOnQuotaThreshold
	to.QuotaAlertThreshold = m.QuotaAlertThreshold
	to.AlertOnErrorSpike = m.AlertOnErrorSpike
	to.ErrorAlertThreshold = m.ErrorAlertThreshold
	if m.MonitoringIntegrations != nil {
		to.MonitoringIntegrations = make(pq.StringArray, len(m.MonitoringIntegrations))
		copy(to.MonitoringIntegrations, m.MonitoringIntegrations)
	}
	to.Encrypted = m.Encrypted
	to.DataClassification = m.DataClassification
	if posthook, ok := interface{}(m).(APIKeyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type APIKey the arg will be the target, the caller the one being converted from

// APIKeyBeforeToORM called before default ToORM code
type APIKeyWithBeforeToORM interface {
	BeforeToORM(context.Context, *APIKeyORM) error
}

// APIKeyAfterToORM called after default ToORM code
type APIKeyWithAfterToORM interface {
	AfterToORM(context.Context, *APIKeyORM) error
}

// APIKeyBeforeToPB called before default ToPB code
type APIKeyWithBeforeToPB interface {
	BeforeToPB(context.Context, *APIKey) error
}

// APIKeyAfterToPB called after default ToPB code
type APIKeyWithAfterToPB interface {
	AfterToPB(context.Context, *APIKey) error
}

type ResultORM struct {
	Data []byte `gorm:"type:bytea"`
	Id   int32  `gorm:"primaryKey"`
}

// TableName overrides the default tablename generated by GORM
func (ResultORM) TableName() string {
	return "results"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Result) ToORM(ctx context.Context) (ResultORM, error) {
	to := ResultORM{}
	var err error
	if prehook, ok := interface{}(m).(ResultWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Data = m.Data
	if posthook, ok := interface{}(m).(ResultWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ResultORM) ToPB(ctx context.Context) (Result, error) {
	to := Result{}
	var err error
	if prehook, ok := interface{}(m).(ResultWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Data = m.Data
	if posthook, ok := interface{}(m).(ResultWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Result the arg will be the target, the caller the one being converted from

// ResultBeforeToORM called before default ToORM code
type ResultWithBeforeToORM interface {
	BeforeToORM(context.Context, *ResultORM) error
}

// ResultAfterToORM called after default ToORM code
type ResultWithAfterToORM interface {
	AfterToORM(context.Context, *ResultORM) error
}

// ResultBeforeToPB called before default ToPB code
type ResultWithBeforeToPB interface {
	BeforeToPB(context.Context, *Result) error
}

// ResultAfterToPB called after default ToPB code
type ResultWithAfterToPB interface {
	AfterToPB(context.Context, *Result) error
}

// DefaultCreateAccount executes a basic gorm create call
func DefaultCreateAccount(ctx context.Context, in *Account, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("Workspaces").Preload("Settings").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccount(ctx context.Context, in *Account, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccount(ctx context.Context, in *Account, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountSet(ctx context.Context, in []*Account, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountORM{})).(AccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountORM{})).(AccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Account, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Account, *gorm.DB) error
}

// DefaultStrictUpdateAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccount(ctx context.Context, in *Account, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSettings := AccountSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSettings.AccountId = new(uint64)
	*filterSettings.AccountId = ormObj.Id
	if err = db.Where(filterSettings).Delete(AccountSettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkspaces := WorkspaceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterWorkspaces.AccountId = new(uint64)
	*filterWorkspaces.AccountId = ormObj.Id
	if err = db.Where(filterWorkspaces).Delete(WorkspaceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("Workspaces").Preload("Settings").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccount executes a basic gorm update call with patch behavior
func DefaultPatchAccount(ctx context.Context, in *Account, updateMask *field_mask.FieldMask, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Account
	var err error
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccount(ctx, &Account{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccount(ctx context.Context, objects []*Account, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Account, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Account, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccount(ctx context.Context, patchee *Account, patcher *Account, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Account, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDeletedAt bool
	var updatedCreatedAt bool
	var updatedLastLoginAt bool
	var updatedSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AuthPlatformUserId" {
			patchee.AuthPlatformUserId = patcher.AuthPlatformUserId
			continue
		}
		if f == prefix+"OrgId" {
			patchee.OrgId = patcher.OrgId
			continue
		}
		if f == prefix+"TenantId" {
			patchee.TenantId = patcher.TenantId
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"AccountStatus" {
			patchee.AccountStatus = patcher.AccountStatus
			continue
		}
		if f == prefix+"Roles" {
			patchee.Roles = patcher.Roles
			continue
		}
		if f == prefix+"Permissions" {
			patchee.Permissions = patcher.Permissions
			continue
		}
		if f == prefix+"MfaEnabled" {
			patchee.MfaEnabled = patcher.MfaEnabled
			continue
		}
		if !updatedLastLoginAt && strings.HasPrefix(f, prefix+"LastLoginAt.") {
			if patcher.LastLoginAt == nil {
				patchee.LastLoginAt = nil
				continue
			}
			if patchee.LastLoginAt == nil {
				patchee.LastLoginAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastLoginAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastLoginAt, patchee.LastLoginAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastLoginAt" {
			updatedLastLoginAt = true
			patchee.LastLoginAt = patcher.LastLoginAt
			continue
		}
		if f == prefix+"Timezone" {
			patchee.Timezone = patcher.Timezone
			continue
		}
		if f == prefix+"TotalJobsRun" {
			patchee.TotalJobsRun = patcher.TotalJobsRun
			continue
		}
		if f == prefix+"MonthlyJobLimit" {
			patchee.MonthlyJobLimit = patcher.MonthlyJobLimit
			continue
		}
		if f == prefix+"ConcurrentJobLimit" {
			patchee.ConcurrentJobLimit = patcher.ConcurrentJobLimit
			continue
		}
		if f == prefix+"Workspaces" {
			patchee.Workspaces = patcher.Workspaces
			continue
		}
		if !updatedSettings && strings.HasPrefix(f, prefix+"Settings.") {
			updatedSettings = true
			if patcher.Settings == nil {
				patchee.Settings = nil
				continue
			}
			if patchee.Settings == nil {
				patchee.Settings = &AccountSettings{}
			}
			if o, err := DefaultApplyFieldMaskAccountSettings(ctx, patchee.Settings, patcher.Settings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Settings.", db); err != nil {
				return nil, err
			} else {
				patchee.Settings = o
			}
			continue
		}
		if f == prefix+"Settings" {
			updatedSettings = true
			patchee.Settings = patcher.Settings
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccount executes a gorm list call
func DefaultListAccount(ctx context.Context, db *gorm.DB) ([]*Account, error) {
	in := Account{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Account{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountORM) error
}

// DefaultCreateWorkspace executes a basic gorm create call
func DefaultCreateWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkspaceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkspaceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkspaceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkspaceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceSet(ctx context.Context, in []*Workspace, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&WorkspaceORM{})).(WorkspaceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&WorkspaceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkspaceORM{})).(WorkspaceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkspaceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Workspace, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Workspace, *gorm.DB) error
}

// DefaultStrictUpdateWorkspace clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkspace")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkspaceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterApiKeys := APIKeyORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterApiKeys.WorkspaceId = new(uint64)
	*filterApiKeys.WorkspaceId = ormObj.Id
	if err = db.Where(filterApiKeys).Delete(APIKeyORM{}).Error; err != nil {
		return nil, err
	}
	filterScrapingJobs := ScrapingJobORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterScrapingJobs.WorkspaceId = new(uint64)
	*filterScrapingJobs.WorkspaceId = ormObj.Id
	if err = db.Where(filterScrapingJobs).Delete(ScrapingJobORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkflows := ScrapingWorkflowORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterWorkflows.WorkspaceId = new(uint64)
	*filterWorkflows.WorkspaceId = ormObj.Id
	if err = db.Where(filterWorkflows).Delete(ScrapingWorkflowORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkspaceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkspace executes a basic gorm update call with patch behavior
func DefaultPatchWorkspace(ctx context.Context, in *Workspace, updateMask *field_mask.FieldMask, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Workspace
	var err error
	if hook, ok := interface{}(&pbObj).(WorkspaceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadWorkspace(ctx, &Workspace{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(WorkspaceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkspace(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkspaceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkspace(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkspaceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkspaceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkspace executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkspace(ctx context.Context, objects []*Workspace, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Workspace, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Workspace, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkspace(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkspace patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkspace(ctx context.Context, patchee *Workspace, patcher *Workspace, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Workspace, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	var updatedLastJobRun bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Industry" {
			patchee.Industry = patcher.Industry
			continue
		}
		if f == prefix+"Domain" {
			patchee.Domain = patcher.Domain
			continue
		}
		if f == prefix+"GdprCompliant" {
			patchee.GdprCompliant = patcher.GdprCompliant
			continue
		}
		if f == prefix+"HipaaCompliant" {
			patchee.HipaaCompliant = patcher.HipaaCompliant
			continue
		}
		if f == prefix+"Soc2Compliant" {
			patchee.Soc2Compliant = patcher.Soc2Compliant
			continue
		}
		if f == prefix+"StorageQuota" {
			patchee.StorageQuota = patcher.StorageQuota
			continue
		}
		if f == prefix+"UsedStorage" {
			patchee.UsedStorage = patcher.UsedStorage
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Workflows" {
			patchee.Workflows = patcher.Workflows
			continue
		}
		if f == prefix+"JobsRunThisMonth" {
			patchee.JobsRunThisMonth = patcher.JobsRunThisMonth
			continue
		}
		if f == prefix+"WorkspaceJobLimit" {
			patchee.WorkspaceJobLimit = patcher.WorkspaceJobLimit
			continue
		}
		if f == prefix+"DailyJobQuota" {
			patchee.DailyJobQuota = patcher.DailyJobQuota
			continue
		}
		if f == prefix+"ActiveScrapers" {
			patchee.ActiveScrapers = patcher.ActiveScrapers
			continue
		}
		if f == prefix+"TotalLeadsCollected" {
			patchee.TotalLeadsCollected = patcher.TotalLeadsCollected
			continue
		}
		if !updatedLastJobRun && strings.HasPrefix(f, prefix+"LastJobRun.") {
			if patcher.LastJobRun == nil {
				patchee.LastJobRun = nil
				continue
			}
			if patchee.LastJobRun == nil {
				patchee.LastJobRun = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastJobRun."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastJobRun, patchee.LastJobRun, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastJobRun" {
			updatedLastJobRun = true
			patchee.LastJobRun = patcher.LastJobRun
			continue
		}
		if f == prefix+"ScrapingJobs" {
			patchee.ScrapingJobs = patcher.ScrapingJobs
			continue
		}
		if f == prefix+"ApiKeys" {
			patchee.ApiKeys = patcher.ApiKeys
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkspace executes a gorm list call
func DefaultListWorkspace(ctx context.Context, db *gorm.DB) ([]*Workspace, error) {
	in := Workspace{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []WorkspaceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Workspace{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkspaceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkspaceORM) error
}

// DefaultCreateScrapingJob executes a basic gorm create call
func DefaultCreateScrapingJob(ctx context.Context, in *ScrapingJob, db *gorm.DB) (*ScrapingJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ScrapingJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadScrapingJob(ctx context.Context, in *ScrapingJob, db *gorm.DB) (*ScrapingJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ScrapingJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ScrapingJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ScrapingJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteScrapingJob(ctx context.Context, in *ScrapingJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ScrapingJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ScrapingJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteScrapingJobSet(ctx context.Context, in []*ScrapingJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ScrapingJobORM{})).(ScrapingJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ScrapingJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ScrapingJobORM{})).(ScrapingJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ScrapingJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ScrapingJob, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ScrapingJob, *gorm.DB) error
}

// DefaultStrictUpdateScrapingJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateScrapingJob(ctx context.Context, in *ScrapingJob, db *gorm.DB) (*ScrapingJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateScrapingJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ScrapingJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLeads := LeadORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLeads.ScrapingJobId = new(uint64)
	*filterLeads.ScrapingJobId = ormObj.Id
	if err = db.Where(filterLeads).Delete(LeadORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ScrapingJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchScrapingJob executes a basic gorm update call with patch behavior
func DefaultPatchScrapingJob(ctx context.Context, in *ScrapingJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*ScrapingJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ScrapingJob
	var err error
	if hook, ok := interface{}(&pbObj).(ScrapingJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadScrapingJob(ctx, &ScrapingJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ScrapingJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskScrapingJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ScrapingJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateScrapingJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ScrapingJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ScrapingJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ScrapingJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ScrapingJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ScrapingJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ScrapingJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetScrapingJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetScrapingJob(ctx context.Context, objects []*ScrapingJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ScrapingJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ScrapingJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchScrapingJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskScrapingJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskScrapingJob(ctx context.Context, patchee *ScrapingJob, patcher *ScrapingJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ScrapingJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Priority" {
			patchee.Priority = patcher.Priority
			continue
		}
		if f == prefix+"PayloadType" {
			patchee.PayloadType = patcher.PayloadType
			continue
		}
		if f == prefix+"Payload" {
			patchee.Payload = patcher.Payload
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Keywords" {
			patchee.Keywords = patcher.Keywords
			continue
		}
		if f == prefix+"Lang" {
			patchee.Lang = patcher.Lang
			continue
		}
		if f == prefix+"Zoom" {
			patchee.Zoom = patcher.Zoom
			continue
		}
		if f == prefix+"Lat" {
			patchee.Lat = patcher.Lat
			continue
		}
		if f == prefix+"Lon" {
			patchee.Lon = patcher.Lon
			continue
		}
		if f == prefix+"FastMode" {
			patchee.FastMode = patcher.FastMode
			continue
		}
		if f == prefix+"Radius" {
			patchee.Radius = patcher.Radius
			continue
		}
		if f == prefix+"Depth" {
			patchee.Depth = patcher.Depth
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"MaxTime" {
			patchee.MaxTime = patcher.MaxTime
			continue
		}
		if f == prefix+"Proxies" {
			patchee.Proxies = patcher.Proxies
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Leads" {
			patchee.Leads = patcher.Leads
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListScrapingJob executes a gorm list call
func DefaultListScrapingJob(ctx context.Context, db *gorm.DB) ([]*ScrapingJob, error) {
	in := ScrapingJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ScrapingJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ScrapingJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ScrapingJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ScrapingJobORM) error
}

// DefaultCreateScrapingWorkflow executes a basic gorm create call
func DefaultCreateScrapingWorkflow(ctx context.Context, in *ScrapingWorkflow, db *gorm.DB) (*ScrapingWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ScrapingWorkflowORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadScrapingWorkflow(ctx context.Context, in *ScrapingWorkflow, db *gorm.DB) (*ScrapingWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ScrapingWorkflowORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ScrapingWorkflowORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ScrapingWorkflowORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteScrapingWorkflow(ctx context.Context, in *ScrapingWorkflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ScrapingWorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ScrapingWorkflowORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteScrapingWorkflowSet(ctx context.Context, in []*ScrapingWorkflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ScrapingWorkflowORM{})).(ScrapingWorkflowORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ScrapingWorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ScrapingWorkflowORM{})).(ScrapingWorkflowORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ScrapingWorkflowORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ScrapingWorkflow, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ScrapingWorkflow, *gorm.DB) error
}

// DefaultStrictUpdateScrapingWorkflow clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateScrapingWorkflow(ctx context.Context, in *ScrapingWorkflow, db *gorm.DB) (*ScrapingWorkflow, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateScrapingWorkflow")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ScrapingWorkflowORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterJobs := ScrapingJobORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterJobs.ScrapingWorkflowId = new(uint64)
	*filterJobs.ScrapingWorkflowId = ormObj.Id
	if err = db.Where(filterJobs).Delete(ScrapingJobORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ScrapingWorkflowORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchScrapingWorkflow executes a basic gorm update call with patch behavior
func DefaultPatchScrapingWorkflow(ctx context.Context, in *ScrapingWorkflow, updateMask *field_mask.FieldMask, db *gorm.DB) (*ScrapingWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ScrapingWorkflow
	var err error
	if hook, ok := interface{}(&pbObj).(ScrapingWorkflowWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadScrapingWorkflow(ctx, &ScrapingWorkflow{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ScrapingWorkflowWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskScrapingWorkflow(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ScrapingWorkflowWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateScrapingWorkflow(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ScrapingWorkflowWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ScrapingWorkflowWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ScrapingWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ScrapingWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ScrapingWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ScrapingWorkflow, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetScrapingWorkflow executes a bulk gorm update call with patch behavior
func DefaultPatchSetScrapingWorkflow(ctx context.Context, objects []*ScrapingWorkflow, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ScrapingWorkflow, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ScrapingWorkflow, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchScrapingWorkflow(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskScrapingWorkflow patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskScrapingWorkflow(ctx context.Context, patchee *ScrapingWorkflow, patcher *ScrapingWorkflow, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ScrapingWorkflow, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNextRunTime bool
	var updatedLastRunTime bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	var updatedWorkspace bool
	var updatedDataRetention bool
	var updatedQosRequestTimeout bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CronExpression" {
			patchee.CronExpression = patcher.CronExpression
			continue
		}
		if !updatedNextRunTime && strings.HasPrefix(f, prefix+"NextRunTime.") {
			if patcher.NextRunTime == nil {
				patchee.NextRunTime = nil
				continue
			}
			if patchee.NextRunTime == nil {
				patchee.NextRunTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"NextRunTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.NextRunTime, patchee.NextRunTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"NextRunTime" {
			updatedNextRunTime = true
			patchee.NextRunTime = patcher.NextRunTime
			continue
		}
		if !updatedLastRunTime && strings.HasPrefix(f, prefix+"LastRunTime.") {
			if patcher.LastRunTime == nil {
				patchee.LastRunTime = nil
				continue
			}
			if patchee.LastRunTime == nil {
				patchee.LastRunTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastRunTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastRunTime, patchee.LastRunTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastRunTime" {
			updatedLastRunTime = true
			patchee.LastRunTime = patcher.LastRunTime
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"RetryCount" {
			patchee.RetryCount = patcher.RetryCount
			continue
		}
		if f == prefix+"MaxRetries" {
			patchee.MaxRetries = patcher.MaxRetries
			continue
		}
		if f == prefix+"AlertEmails" {
			patchee.AlertEmails = patcher.AlertEmails
			continue
		}
		if f == prefix+"OrgId" {
			patchee.OrgId = patcher.OrgId
			continue
		}
		if f == prefix+"TenantId" {
			patchee.TenantId = patcher.TenantId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Jobs" {
			patchee.Jobs = patcher.Jobs
			continue
		}
		if !updatedWorkspace && strings.HasPrefix(f, prefix+"Workspace.") {
			updatedWorkspace = true
			if patcher.Workspace == nil {
				patchee.Workspace = nil
				continue
			}
			if patchee.Workspace == nil {
				patchee.Workspace = &Workspace{}
			}
			if o, err := DefaultApplyFieldMaskWorkspace(ctx, patchee.Workspace, patcher.Workspace, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Workspace.", db); err != nil {
				return nil, err
			} else {
				patchee.Workspace = o
			}
			continue
		}
		if f == prefix+"Workspace" {
			updatedWorkspace = true
			patchee.Workspace = patcher.Workspace
			continue
		}
		if f == prefix+"GeoFencingRadius" {
			patchee.GeoFencingRadius = patcher.GeoFencingRadius
			continue
		}
		if f == prefix+"GeoFencingLat" {
			patchee.GeoFencingLat = patcher.GeoFencingLat
			continue
		}
		if f == prefix+"GeoFencingLon" {
			patchee.GeoFencingLon = patcher.GeoFencingLon
			continue
		}
		if f == prefix+"GeoFencingZoomMin" {
			patchee.GeoFencingZoomMin = patcher.GeoFencingZoomMin
			continue
		}
		if f == prefix+"GeoFencingZoomMax" {
			patchee.GeoFencingZoomMax = patcher.GeoFencingZoomMax
			continue
		}
		if f == prefix+"IncludeReviews" {
			patchee.IncludeReviews = patcher.IncludeReviews
			continue
		}
		if f == prefix+"IncludePhotos" {
			patchee.IncludePhotos = patcher.IncludePhotos
			continue
		}
		if f == prefix+"IncludeBusinessHours" {
			patchee.IncludeBusinessHours = patcher.IncludeBusinessHours
			continue
		}
		if f == prefix+"MaxReviewsPerBusiness" {
			patchee.MaxReviewsPerBusiness = patcher.MaxReviewsPerBusiness
			continue
		}
		if f == prefix+"OutputFormat" {
			patchee.OutputFormat = patcher.OutputFormat
			continue
		}
		if f == prefix+"OutputDestination" {
			patchee.OutputDestination = patcher.OutputDestination
			continue
		}
		if !updatedDataRetention && strings.HasPrefix(f, prefix+"DataRetention.") {
			if patcher.DataRetention == nil {
				patchee.DataRetention = nil
				continue
			}
			if patchee.DataRetention == nil {
				patchee.DataRetention = &durationpb.Duration{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DataRetention."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DataRetention, patchee.DataRetention, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DataRetention" {
			updatedDataRetention = true
			patchee.DataRetention = patcher.DataRetention
			continue
		}
		if f == prefix+"AnonymizePii" {
			patchee.AnonymizePii = patcher.AnonymizePii
			continue
		}
		if f == prefix+"NotificationWebhookUrl" {
			patchee.NotificationWebhookUrl = patcher.NotificationWebhookUrl
			continue
		}
		if f == prefix+"NotificationSlackChannel" {
			patchee.NotificationSlackChannel = patcher.NotificationSlackChannel
			continue
		}
		if f == prefix+"NotificationEmailGroup" {
			patchee.NotificationEmailGroup = patcher.NotificationEmailGroup
			continue
		}
		if f == prefix+"NotificationNotifyOnStart" {
			patchee.NotificationNotifyOnStart = patcher.NotificationNotifyOnStart
			continue
		}
		if f == prefix+"NotificationNotifyOnComplete" {
			patchee.NotificationNotifyOnComplete = patcher.NotificationNotifyOnComplete
			continue
		}
		if f == prefix+"NotificationNotifyOnFailure" {
			patchee.NotificationNotifyOnFailure = patcher.NotificationNotifyOnFailure
			continue
		}
		if f == prefix+"ContentFilterAllowedCountries" {
			patchee.ContentFilterAllowedCountries = patcher.ContentFilterAllowedCountries
			continue
		}
		if f == prefix+"ContentFilterExcludedTypes" {
			patchee.ContentFilterExcludedTypes = patcher.ContentFilterExcludedTypes
			continue
		}
		if f == prefix+"ContentFilterMinimumRating" {
			patchee.ContentFilterMinimumRating = patcher.ContentFilterMinimumRating
			continue
		}
		if f == prefix+"ContentFilterMinimumReviews" {
			patchee.ContentFilterMinimumReviews = patcher.ContentFilterMinimumReviews
			continue
		}
		if f == prefix+"QosMaxConcurrentRequests" {
			patchee.QosMaxConcurrentRequests = patcher.QosMaxConcurrentRequests
			continue
		}
		if f == prefix+"QosMaxRetries" {
			patchee.QosMaxRetries = patcher.QosMaxRetries
			continue
		}
		if !updatedQosRequestTimeout && strings.HasPrefix(f, prefix+"QosRequestTimeout.") {
			if patcher.QosRequestTimeout == nil {
				patchee.QosRequestTimeout = nil
				continue
			}
			if patchee.QosRequestTimeout == nil {
				patchee.QosRequestTimeout = &durationpb.Duration{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"QosRequestTimeout."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.QosRequestTimeout, patchee.QosRequestTimeout, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"QosRequestTimeout" {
			updatedQosRequestTimeout = true
			patchee.QosRequestTimeout = patcher.QosRequestTimeout
			continue
		}
		if f == prefix+"QosEnableJavascript" {
			patchee.QosEnableJavascript = patcher.QosEnableJavascript
			continue
		}
		if f == prefix+"RespectRobotsTxt" {
			patchee.RespectRobotsTxt = patcher.RespectRobotsTxt
			continue
		}
		if f == prefix+"AcceptTermsOfService" {
			patchee.AcceptTermsOfService = patcher.AcceptTermsOfService
			continue
		}
		if f == prefix+"UserAgent" {
			patchee.UserAgent = patcher.UserAgent
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListScrapingWorkflow executes a gorm list call
func DefaultListScrapingWorkflow(ctx context.Context, db *gorm.DB) ([]*ScrapingWorkflow, error) {
	in := ScrapingWorkflow{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ScrapingWorkflowORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ScrapingWorkflowORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ScrapingWorkflow{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ScrapingWorkflowORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ScrapingWorkflowORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ScrapingWorkflowORM) error
}

// DefaultCreateLead executes a basic gorm create call
func DefaultCreateLead(ctx context.Context, in *Lead, db *gorm.DB) (*Lead, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ApiKeys").Preload("ScrapingJobs").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LeadORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLead(ctx context.Context, in *Lead, db *gorm.DB) (*Lead, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LeadORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LeadORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LeadORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLead(ctx context.Context, in *Lead, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LeadORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LeadORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLeadSet(ctx context.Context, in []*Lead, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LeadORM{})).(LeadORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LeadORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LeadORM{})).(LeadORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LeadORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Lead, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Lead, *gorm.DB) error
}

// DefaultStrictUpdateLead clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLead(ctx context.Context, in *Lead, db *gorm.DB) (*Lead, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLead")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LeadORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterRegularHours := BusinessHoursORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRegularHours.RegularHoursLeadId = new(uint64)
	*filterRegularHours.RegularHoursLeadId = ormObj.Id
	if err = db.Where(filterRegularHours).Delete(BusinessHoursORM{}).Error; err != nil {
		return nil, err
	}
	filterReviews := ReviewORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterReviews.LeadId = new(uint64)
	*filterReviews.LeadId = ormObj.Id
	if err = db.Where(filterReviews).Delete(ReviewORM{}).Error; err != nil {
		return nil, err
	}
	filterSpecialHours := BusinessHoursORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSpecialHours.SpecialHoursLeadId = new(uint64)
	*filterSpecialHours.SpecialHoursLeadId = ormObj.Id
	if err = db.Where(filterSpecialHours).Delete(BusinessHoursORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LeadORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLead executes a basic gorm update call with patch behavior
func DefaultPatchLead(ctx context.Context, in *Lead, updateMask *field_mask.FieldMask, db *gorm.DB) (*Lead, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Lead
	var err error
	if hook, ok := interface{}(&pbObj).(LeadWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLead(ctx, &Lead{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LeadWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLead(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LeadWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLead(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LeadWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LeadWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Lead, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LeadWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Lead, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LeadWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Lead, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LeadWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Lead, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLead executes a bulk gorm update call with patch behavior
func DefaultPatchSetLead(ctx context.Context, objects []*Lead, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Lead, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Lead, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLead(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLead patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLead(ctx context.Context, patchee *Lead, patcher *Lead, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Lead, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	var updatedJob bool
	var updatedWorkspace bool
	var updatedLastUpdated bool
	var updatedLastProductLaunch bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Website" {
			patchee.Website = patcher.Website
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"Latitude" {
			patchee.Latitude = patcher.Latitude
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"GoogleRating" {
			patchee.GoogleRating = patcher.GoogleRating
			continue
		}
		if f == prefix+"ReviewCount" {
			patchee.ReviewCount = patcher.ReviewCount
			continue
		}
		if f == prefix+"Industry" {
			patchee.Industry = patcher.Industry
			continue
		}
		if f == prefix+"EmployeeCount" {
			patchee.EmployeeCount = patcher.EmployeeCount
			continue
		}
		if f == prefix+"EstimatedRevenue" {
			patchee.EstimatedRevenue = patcher.EstimatedRevenue
			continue
		}
		if f == prefix+"OrgId" {
			patchee.OrgId = patcher.OrgId
			continue
		}
		if f == prefix+"TenantId" {
			patchee.TenantId = patcher.TenantId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedJob && strings.HasPrefix(f, prefix+"Job.") {
			updatedJob = true
			if patcher.Job == nil {
				patchee.Job = nil
				continue
			}
			if patchee.Job == nil {
				patchee.Job = &ScrapingJob{}
			}
			if o, err := DefaultApplyFieldMaskScrapingJob(ctx, patchee.Job, patcher.Job, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Job.", db); err != nil {
				return nil, err
			} else {
				patchee.Job = o
			}
			continue
		}
		if f == prefix+"Job" {
			updatedJob = true
			patchee.Job = patcher.Job
			continue
		}
		if !updatedWorkspace && strings.HasPrefix(f, prefix+"Workspace.") {
			updatedWorkspace = true
			if patcher.Workspace == nil {
				patchee.Workspace = nil
				continue
			}
			if patchee.Workspace == nil {
				patchee.Workspace = &Workspace{}
			}
			if o, err := DefaultApplyFieldMaskWorkspace(ctx, patchee.Workspace, patcher.Workspace, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Workspace.", db); err != nil {
				return nil, err
			} else {
				patchee.Workspace = o
			}
			continue
		}
		if f == prefix+"Workspace" {
			updatedWorkspace = true
			patchee.Workspace = patcher.Workspace
			continue
		}
		if f == prefix+"PlaceId" {
			patchee.PlaceId = patcher.PlaceId
			continue
		}
		if f == prefix+"GoogleMapsUrl" {
			patchee.GoogleMapsUrl = patcher.GoogleMapsUrl
			continue
		}
		if f == prefix+"BusinessStatus" {
			patchee.BusinessStatus = patcher.BusinessStatus
			continue
		}
		if f == prefix+"RegularHours" {
			patchee.RegularHours = patcher.RegularHours
			continue
		}
		if f == prefix+"SpecialHours" {
			patchee.SpecialHours = patcher.SpecialHours
			continue
		}
		if f == prefix+"PhotoReferences" {
			patchee.PhotoReferences = patcher.PhotoReferences
			continue
		}
		if f == prefix+"MainPhotoUrl" {
			patchee.MainPhotoUrl = patcher.MainPhotoUrl
			continue
		}
		if f == prefix+"Reviews" {
			patchee.Reviews = patcher.Reviews
			continue
		}
		if f == prefix+"Types" {
			patchee.Types = patcher.Types
			continue
		}
		if f == prefix+"Amenities" {
			patchee.Amenities = patcher.Amenities
			continue
		}
		if f == prefix+"ServesVegetarianFood" {
			patchee.ServesVegetarianFood = patcher.ServesVegetarianFood
			continue
		}
		if f == prefix+"OutdoorSeating" {
			patchee.OutdoorSeating = patcher.OutdoorSeating
			continue
		}
		if f == prefix+"PaymentMethods" {
			patchee.PaymentMethods = patcher.PaymentMethods
			continue
		}
		if f == prefix+"WheelchairAccessible" {
			patchee.WheelchairAccessible = patcher.WheelchairAccessible
			continue
		}
		if f == prefix+"ParkingAvailable" {
			patchee.ParkingAvailable = patcher.ParkingAvailable
			continue
		}
		if f == prefix+"SocialMedia" {
			patchee.SocialMedia = patcher.SocialMedia
			continue
		}
		if f == prefix+"RatingCategory" {
			patchee.RatingCategory = patcher.RatingCategory
			continue
		}
		if f == prefix+"Rating" {
			patchee.Rating = patcher.Rating
			continue
		}
		if f == prefix+"Count" {
			patchee.Count = patcher.Count
			continue
		}
		if !updatedLastUpdated && strings.HasPrefix(f, prefix+"LastUpdated.") {
			if patcher.LastUpdated == nil {
				patchee.LastUpdated = nil
				continue
			}
			if patchee.LastUpdated == nil {
				patchee.LastUpdated = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUpdated."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUpdated, patchee.LastUpdated, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUpdated" {
			updatedLastUpdated = true
			patchee.LastUpdated = patcher.LastUpdated
			continue
		}
		if f == prefix+"DataSourceVersion" {
			patchee.DataSourceVersion = patcher.DataSourceVersion
			continue
		}
		if f == prefix+"ScrapingSessionId" {
			patchee.ScrapingSessionId = patcher.ScrapingSessionId
			continue
		}
		if f == prefix+"AlternatePhones" {
			patchee.AlternatePhones = patcher.AlternatePhones
			continue
		}
		if f == prefix+"ContactPersonName" {
			patchee.ContactPersonName = patcher.ContactPersonName
			continue
		}
		if f == prefix+"ContactPersonTitle" {
			patchee.ContactPersonTitle = patcher.ContactPersonTitle
			continue
		}
		if f == prefix+"ContactEmail" {
			patchee.ContactEmail = patcher.ContactEmail
			continue
		}
		if f == prefix+"FoundedYear" {
			patchee.FoundedYear = patcher.FoundedYear
			continue
		}
		if f == prefix+"BusinessType" {
			patchee.BusinessType = patcher.BusinessType
			continue
		}
		if f == prefix+"Certifications" {
			patchee.Certifications = patcher.Certifications
			continue
		}
		if f == prefix+"LicenseNumber" {
			patchee.LicenseNumber = patcher.LicenseNumber
			continue
		}
		if f == prefix+"RevenueRange" {
			patchee.RevenueRange = patcher.RevenueRange
			continue
		}
		if f == prefix+"FundingStage" {
			patchee.FundingStage = patcher.FundingStage
			continue
		}
		if f == prefix+"IsPublicCompany" {
			patchee.IsPublicCompany = patcher.IsPublicCompany
			continue
		}
		if f == prefix+"WebsiteLoadSpeed" {
			patchee.WebsiteLoadSpeed = patcher.WebsiteLoadSpeed
			continue
		}
		if f == prefix+"HasSslCertificate" {
			patchee.HasSslCertificate = patcher.HasSslCertificate
			continue
		}
		if f == prefix+"CmsUsed" {
			patchee.CmsUsed = patcher.CmsUsed
			continue
		}
		if f == prefix+"EcommercePlatforms" {
			patchee.EcommercePlatforms = patcher.EcommercePlatforms
			continue
		}
		if f == prefix+"Timezone" {
			patchee.Timezone = patcher.Timezone
			continue
		}
		if f == prefix+"Neighborhood" {
			patchee.Neighborhood = patcher.Neighborhood
			continue
		}
		if f == prefix+"NearbyLandmarks" {
			patchee.NearbyLandmarks = patcher.NearbyLandmarks
			continue
		}
		if f == prefix+"TransportationAccess" {
			patchee.TransportationAccess = patcher.TransportationAccess
			continue
		}
		if f == prefix+"EmployeeBenefits" {
			patchee.EmployeeBenefits = patcher.EmployeeBenefits
			continue
		}
		if f == prefix+"ParentCompany" {
			patchee.ParentCompany = patcher.ParentCompany
			continue
		}
		if f == prefix+"Subsidiaries" {
			patchee.Subsidiaries = patcher.Subsidiaries
			continue
		}
		if f == prefix+"IsFranchise" {
			patchee.IsFranchise = patcher.IsFranchise
			continue
		}
		if f == prefix+"SeoKeywords" {
			patchee.SeoKeywords = patcher.SeoKeywords
			continue
		}
		if f == prefix+"UsesGoogleAds" {
			patchee.UsesGoogleAds = patcher.UsesGoogleAds
			continue
		}
		if f == prefix+"GoogleMyBusinessCategory" {
			patchee.GoogleMyBusinessCategory = patcher.GoogleMyBusinessCategory
			continue
		}
		if f == prefix+"NaicsCode" {
			patchee.NaicsCode = patcher.NaicsCode
			continue
		}
		if f == prefix+"SicCode" {
			patchee.SicCode = patcher.SicCode
			continue
		}
		if f == prefix+"UnspscCode" {
			patchee.UnspscCode = patcher.UnspscCode
			continue
		}
		if f == prefix+"IsGreenCertified" {
			patchee.IsGreenCertified = patcher.IsGreenCertified
			continue
		}
		if f == prefix+"EnergySources" {
			patchee.EnergySources = patcher.EnergySources
			continue
		}
		if f == prefix+"SustainabilityRating" {
			patchee.SustainabilityRating = patcher.SustainabilityRating
			continue
		}
		if f == prefix+"RecentAnnouncements" {
			patchee.RecentAnnouncements = patcher.RecentAnnouncements
			continue
		}
		if !updatedLastProductLaunch && strings.HasPrefix(f, prefix+"LastProductLaunch.") {
			if patcher.LastProductLaunch == nil {
				patchee.LastProductLaunch = nil
				continue
			}
			if patchee.LastProductLaunch == nil {
				patchee.LastProductLaunch = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastProductLaunch."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastProductLaunch, patchee.LastProductLaunch, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastProductLaunch" {
			updatedLastProductLaunch = true
			patchee.LastProductLaunch = patcher.LastProductLaunch
			continue
		}
		if f == prefix+"HasLitigationHistory" {
			patchee.HasLitigationHistory = patcher.HasLitigationHistory
			continue
		}
		if f == prefix+"ExportControlStatus" {
			patchee.ExportControlStatus = patcher.ExportControlStatus
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLead executes a gorm list call
func DefaultListLead(ctx context.Context, db *gorm.DB) ([]*Lead, error) {
	in := Lead{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LeadORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LeadORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Lead{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LeadORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LeadORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LeadORM) error
}

// DefaultCreateReview executes a basic gorm create call
func DefaultCreateReview(ctx context.Context, in *Review, db *gorm.DB) (*Review, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReviewORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReview(ctx context.Context, in *Review, db *gorm.DB) (*Review, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReviewORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReviewORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReviewORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReview(ctx context.Context, in *Review, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReviewORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReviewORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReviewSet(ctx context.Context, in []*Review, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReviewORM{})).(ReviewORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReviewORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReviewORM{})).(ReviewORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReviewORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Review, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Review, *gorm.DB) error
}

// DefaultStrictUpdateReview clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReview(ctx context.Context, in *Review, db *gorm.DB) (*Review, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReview")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReviewORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReviewORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReview executes a basic gorm update call with patch behavior
func DefaultPatchReview(ctx context.Context, in *Review, updateMask *field_mask.FieldMask, db *gorm.DB) (*Review, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Review
	var err error
	if hook, ok := interface{}(&pbObj).(ReviewWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReview(ctx, &Review{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReviewWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReview(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReviewWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReview(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReviewWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReviewWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Review, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReviewWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Review, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReviewWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Review, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReviewWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Review, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReview executes a bulk gorm update call with patch behavior
func DefaultPatchSetReview(ctx context.Context, objects []*Review, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Review, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Review, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReview(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReview patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReview(ctx context.Context, patchee *Review, patcher *Review, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Review, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTime bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Author" {
			patchee.Author = patcher.Author
			continue
		}
		if f == prefix+"Rating" {
			patchee.Rating = patcher.Rating
			continue
		}
		if f == prefix+"Text" {
			patchee.Text = patcher.Text
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if f == prefix+"Language" {
			patchee.Language = patcher.Language
			continue
		}
		if f == prefix+"ProfilePhotoUrl" {
			patchee.ProfilePhotoUrl = patcher.ProfilePhotoUrl
			continue
		}
		if f == prefix+"ReviewCount" {
			patchee.ReviewCount = patcher.ReviewCount
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReview executes a gorm list call
func DefaultListReview(ctx context.Context, db *gorm.DB) ([]*Review, error) {
	in := Review{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReviewORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Review{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReviewORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReviewORM) error
}

// DefaultCreateBusinessHours executes a basic gorm create call
func DefaultCreateBusinessHours(ctx context.Context, in *BusinessHours, db *gorm.DB) (*BusinessHours, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessHoursORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessHours(ctx context.Context, in *BusinessHours, db *gorm.DB) (*BusinessHours, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessHoursORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessHoursORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessHoursORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessHours(ctx context.Context, in *BusinessHours, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessHoursORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessHoursORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessHoursSet(ctx context.Context, in []*BusinessHours, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessHoursORM{})).(BusinessHoursORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessHoursORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessHoursORM{})).(BusinessHoursORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessHoursORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessHours, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessHours, *gorm.DB) error
}

// DefaultStrictUpdateBusinessHours clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessHours(ctx context.Context, in *BusinessHours, db *gorm.DB) (*BusinessHours, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessHours")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessHoursORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessHoursORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessHours executes a basic gorm update call with patch behavior
func DefaultPatchBusinessHours(ctx context.Context, in *BusinessHours, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessHours, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessHours
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessHoursWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessHours(ctx, &BusinessHours{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessHoursWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessHours(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessHoursWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessHours(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessHoursWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessHoursWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessHours, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessHours, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessHours, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessHours, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessHours executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessHours(ctx context.Context, objects []*BusinessHours, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessHours, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessHours, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessHours(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessHours patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessHours(ctx context.Context, patchee *BusinessHours, patcher *BusinessHours, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessHours, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Day" {
			patchee.Day = patcher.Day
			continue
		}
		if f == prefix+"OpenTime" {
			patchee.OpenTime = patcher.OpenTime
			continue
		}
		if f == prefix+"CloseTime" {
			patchee.CloseTime = patcher.CloseTime
			continue
		}
		if f == prefix+"Closed" {
			patchee.Closed = patcher.Closed
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessHours executes a gorm list call
func DefaultListBusinessHours(ctx context.Context, db *gorm.DB) ([]*BusinessHours, error) {
	in := BusinessHours{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessHoursORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessHoursORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessHours{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessHoursORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessHoursORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessHoursORM) error
}

// DefaultCreateAccountSettings executes a basic gorm create call
func DefaultCreateAccountSettings(ctx context.Context, in *AccountSettings, db *gorm.DB) (*AccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountSettings(ctx context.Context, in *AccountSettings, db *gorm.DB) (*AccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountSettings(ctx context.Context, in *AccountSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountSettingsSet(ctx context.Context, in []*AccountSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountSettingsORM{})).(AccountSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountSettingsORM{})).(AccountSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountSettings, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountSettings, *gorm.DB) error
}

// DefaultStrictUpdateAccountSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountSettings(ctx context.Context, in *AccountSettings, db *gorm.DB) (*AccountSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountSettings executes a basic gorm update call with patch behavior
func DefaultPatchAccountSettings(ctx context.Context, in *AccountSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountSettings
	var err error
	if hook, ok := interface{}(&pbObj).(AccountSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountSettings(ctx, &AccountSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountSettings(ctx context.Context, objects []*AccountSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountSettings(ctx context.Context, patchee *AccountSettings, patcher *AccountSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDefaultDataRetention bool
	var updatedSessionTimeout bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"EmailNotifications" {
			patchee.EmailNotifications = patcher.EmailNotifications
			continue
		}
		if f == prefix+"SlackNotifications" {
			patchee.SlackNotifications = patcher.SlackNotifications
			continue
		}
		if !updatedDefaultDataRetention && strings.HasPrefix(f, prefix+"DefaultDataRetention.") {
			if patcher.DefaultDataRetention == nil {
				patchee.DefaultDataRetention = nil
				continue
			}
			if patchee.DefaultDataRetention == nil {
				patchee.DefaultDataRetention = &durationpb.Duration{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DefaultDataRetention."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DefaultDataRetention, patchee.DefaultDataRetention, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DefaultDataRetention" {
			updatedDefaultDataRetention = true
			patchee.DefaultDataRetention = patcher.DefaultDataRetention
			continue
		}
		if f == prefix+"AutoPurgeEnabled" {
			patchee.AutoPurgeEnabled = patcher.AutoPurgeEnabled
			continue
		}
		if f == prefix+"Require_2Fa" {
			patchee.Require_2Fa = patcher.Require_2Fa
			continue
		}
		if !updatedSessionTimeout && strings.HasPrefix(f, prefix+"SessionTimeout.") {
			if patcher.SessionTimeout == nil {
				patchee.SessionTimeout = nil
				continue
			}
			if patchee.SessionTimeout == nil {
				patchee.SessionTimeout = &durationpb.Duration{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"SessionTimeout."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.SessionTimeout, patchee.SessionTimeout, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"SessionTimeout" {
			updatedSessionTimeout = true
			patchee.SessionTimeout = patcher.SessionTimeout
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountSettings executes a gorm list call
func DefaultListAccountSettings(ctx context.Context, db *gorm.DB) ([]*AccountSettings, error) {
	in := AccountSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountSettingsORM) error
}

// DefaultCreateAPIKey executes a basic gorm create call
func DefaultCreateAPIKey(ctx context.Context, in *APIKey, db *gorm.DB) (*APIKey, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("Workspaces").Preload("Settings").Preload("ApiKeys").Preload("ScrapingJobs").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type APIKeyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAPIKey(ctx context.Context, in *APIKey, db *gorm.DB) (*APIKey, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := APIKeyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(APIKeyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type APIKeyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAPIKey(ctx context.Context, in *APIKey, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&APIKeyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type APIKeyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAPIKeySet(ctx context.Context, in []*APIKey, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&APIKeyORM{})).(APIKeyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&APIKeyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&APIKeyORM{})).(APIKeyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type APIKeyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*APIKey, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*APIKey, *gorm.DB) error
}

// DefaultStrictUpdateAPIKey clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAPIKey(ctx context.Context, in *APIKey, db *gorm.DB) (*APIKey, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAPIKey")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &APIKeyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Preload("ScrapingJobs").Preload("ApiKeys").Preload("Workspaces").Preload("Settings").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type APIKeyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAPIKey executes a basic gorm update call with patch behavior
func DefaultPatchAPIKey(ctx context.Context, in *APIKey, updateMask *field_mask.FieldMask, db *gorm.DB) (*APIKey, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj APIKey
	var err error
	if hook, ok := interface{}(&pbObj).(APIKeyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAPIKey(ctx, &APIKey{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(APIKeyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAPIKey(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(APIKeyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAPIKey(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(APIKeyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type APIKeyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *APIKey, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type APIKeyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *APIKey, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type APIKeyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *APIKey, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type APIKeyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *APIKey, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAPIKey executes a bulk gorm update call with patch behavior
func DefaultPatchSetAPIKey(ctx context.Context, objects []*APIKey, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*APIKey, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*APIKey, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAPIKey(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAPIKey patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAPIKey(ctx context.Context, patchee *APIKey, patcher *APIKey, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*APIKey, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastUsedAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedExpiresAt bool
	var updatedDeletedAt bool
	var updatedLastRotatedAt bool
	var updatedLastSecurityReviewAt bool
	var updatedAccount bool
	var updatedWorkspace bool
	var updatedLastRotationDate bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"KeyHash" {
			patchee.KeyHash = patcher.KeyHash
			continue
		}
		if f == prefix+"KeyPrefix" {
			patchee.KeyPrefix = patcher.KeyPrefix
			continue
		}
		if f == prefix+"OrgId" {
			patchee.OrgId = patcher.OrgId
			continue
		}
		if f == prefix+"TenantId" {
			patchee.TenantId = patcher.TenantId
			continue
		}
		if f == prefix+"Scopes" {
			patchee.Scopes = patcher.Scopes
			continue
		}
		if f == prefix+"AllowedIps" {
			patchee.AllowedIps = patcher.AllowedIps
			continue
		}
		if f == prefix+"AllowedDomains" {
			patchee.AllowedDomains = patcher.AllowedDomains
			continue
		}
		if f == prefix+"AllowedEnvironments" {
			patchee.AllowedEnvironments = patcher.AllowedEnvironments
			continue
		}
		if f == prefix+"IsTestKey" {
			patchee.IsTestKey = patcher.IsTestKey
			continue
		}
		if f == prefix+"RequestsPerSecond" {
			patchee.RequestsPerSecond = patcher.RequestsPerSecond
			continue
		}
		if f == prefix+"RequestsPerDay" {
			patchee.RequestsPerDay = patcher.RequestsPerDay
			continue
		}
		if f == prefix+"ConcurrentRequests" {
			patchee.ConcurrentRequests = patcher.ConcurrentRequests
			continue
		}
		if f == prefix+"MonthlyRequestQuota" {
			patchee.MonthlyRequestQuota = patcher.MonthlyRequestQuota
			continue
		}
		if f == prefix+"CostPerRequest" {
			patchee.CostPerRequest = patcher.CostPerRequest
			continue
		}
		if f == prefix+"BillingTier" {
			patchee.BillingTier = patcher.BillingTier
			continue
		}
		if f == prefix+"TotalRequests" {
			patchee.TotalRequests = patcher.TotalRequests
			continue
		}
		if f == prefix+"TotalErrors" {
			patchee.TotalErrors = patcher.TotalErrors
			continue
		}
		if !updatedLastUsedAt && strings.HasPrefix(f, prefix+"LastUsedAt.") {
			if patcher.LastUsedAt == nil {
				patchee.LastUsedAt = nil
				continue
			}
			if patchee.LastUsedAt == nil {
				patchee.LastUsedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUsedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUsedAt, patchee.LastUsedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUsedAt" {
			updatedLastUsedAt = true
			patchee.LastUsedAt = patcher.LastUsedAt
			continue
		}
		if f == prefix+"AverageResponseTime" {
			patchee.AverageResponseTime = patcher.AverageResponseTime
			continue
		}
		if f == prefix+"EndpointUsageJson" {
			patchee.EndpointUsageJson = patcher.EndpointUsageJson
			continue
		}
		if f == prefix+"ErrorRatesJson" {
			patchee.ErrorRatesJson = patcher.ErrorRatesJson
			continue
		}
		if f == prefix+"RecentErrors" {
			patchee.RecentErrors = patcher.RecentErrors
			continue
		}
		if f == prefix+"SuccessfulRequestsCount" {
			patchee.SuccessfulRequestsCount = patcher.SuccessfulRequestsCount
			continue
		}
		if f == prefix+"SuccessRate" {
			patchee.SuccessRate = patcher.SuccessRate
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedExpiresAt && strings.HasPrefix(f, prefix+"ExpiresAt.") {
			if patcher.ExpiresAt == nil {
				patchee.ExpiresAt = nil
				continue
			}
			if patchee.ExpiresAt == nil {
				patchee.ExpiresAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiresAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiresAt, patchee.ExpiresAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiresAt" {
			updatedExpiresAt = true
			patchee.ExpiresAt = patcher.ExpiresAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedLastRotatedAt && strings.HasPrefix(f, prefix+"LastRotatedAt.") {
			if patcher.LastRotatedAt == nil {
				patchee.LastRotatedAt = nil
				continue
			}
			if patchee.LastRotatedAt == nil {
				patchee.LastRotatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastRotatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastRotatedAt, patchee.LastRotatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastRotatedAt" {
			updatedLastRotatedAt = true
			patchee.LastRotatedAt = patcher.LastRotatedAt
			continue
		}
		if !updatedLastSecurityReviewAt && strings.HasPrefix(f, prefix+"LastSecurityReviewAt.") {
			if patcher.LastSecurityReviewAt == nil {
				patchee.LastSecurityReviewAt = nil
				continue
			}
			if patchee.LastSecurityReviewAt == nil {
				patchee.LastSecurityReviewAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastSecurityReviewAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastSecurityReviewAt, patchee.LastSecurityReviewAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastSecurityReviewAt" {
			updatedLastSecurityReviewAt = true
			patchee.LastSecurityReviewAt = patcher.LastSecurityReviewAt
			continue
		}
		if f == prefix+"RequiresClientSecret" {
			patchee.RequiresClientSecret = patcher.RequiresClientSecret
			continue
		}
		if f == prefix+"ClientSecretHash" {
			patchee.ClientSecretHash = patcher.ClientSecretHash
			continue
		}
		if f == prefix+"EnforceHttps" {
			patchee.EnforceHttps = patcher.EnforceHttps
			continue
		}
		if f == prefix+"EnforceSigning" {
			patchee.EnforceSigning = patcher.EnforceSigning
			continue
		}
		if f == prefix+"AllowedSignatureAlgorithms" {
			patchee.AllowedSignatureAlgorithms = patcher.AllowedSignatureAlgorithms
			continue
		}
		if f == prefix+"EnforceMutualTls" {
			patchee.EnforceMutualTls = patcher.EnforceMutualTls
			continue
		}
		if f == prefix+"ClientCertificateHash" {
			patchee.ClientCertificateHash = patcher.ClientCertificateHash
			continue
		}
		if f == prefix+"RequireRequestSigning" {
			patchee.RequireRequestSigning = patcher.RequireRequestSigning
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"MetadataJson" {
			patchee.MetadataJson = patcher.MetadataJson
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"ApiVersion" {
			patchee.ApiVersion = patcher.ApiVersion
			continue
		}
		if f == prefix+"SupportedFeatures" {
			patchee.SupportedFeatures = patcher.SupportedFeatures
			continue
		}
		if f == prefix+"DocumentationUrl" {
			patchee.DocumentationUrl = patcher.DocumentationUrl
			continue
		}
		if f == prefix+"SupportContact" {
			patchee.SupportContact = patcher.SupportContact
			continue
		}
		if !updatedAccount && strings.HasPrefix(f, prefix+"Account.") {
			updatedAccount = true
			if patcher.Account == nil {
				patchee.Account = nil
				continue
			}
			if patchee.Account == nil {
				patchee.Account = &Account{}
			}
			if o, err := DefaultApplyFieldMaskAccount(ctx, patchee.Account, patcher.Account, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Account.", db); err != nil {
				return nil, err
			} else {
				patchee.Account = o
			}
			continue
		}
		if f == prefix+"Account" {
			updatedAccount = true
			patchee.Account = patcher.Account
			continue
		}
		if !updatedWorkspace && strings.HasPrefix(f, prefix+"Workspace.") {
			updatedWorkspace = true
			if patcher.Workspace == nil {
				patchee.Workspace = nil
				continue
			}
			if patchee.Workspace == nil {
				patchee.Workspace = &Workspace{}
			}
			if o, err := DefaultApplyFieldMaskWorkspace(ctx, patchee.Workspace, patcher.Workspace, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Workspace.", db); err != nil {
				return nil, err
			} else {
				patchee.Workspace = o
			}
			continue
		}
		if f == prefix+"Workspace" {
			updatedWorkspace = true
			patchee.Workspace = patcher.Workspace
			continue
		}
		if f == prefix+"LogAllRequests" {
			patchee.LogAllRequests = patcher.LogAllRequests
			continue
		}
		if f == prefix+"LastRotationReason" {
			patchee.LastRotationReason = patcher.LastRotationReason
			continue
		}
		if !updatedLastRotationDate && strings.HasPrefix(f, prefix+"LastRotationDate.") {
			if patcher.LastRotationDate == nil {
				patchee.LastRotationDate = nil
				continue
			}
			if patchee.LastRotationDate == nil {
				patchee.LastRotationDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastRotationDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastRotationDate, patchee.LastRotationDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastRotationDate" {
			updatedLastRotationDate = true
			patchee.LastRotationDate = patcher.LastRotationDate
			continue
		}
		if f == prefix+"RotationFrequencyDays" {
			patchee.RotationFrequencyDays = patcher.RotationFrequencyDays
			continue
		}
		if f == prefix+"ComplianceStandards" {
			patchee.ComplianceStandards = patcher.ComplianceStandards
			continue
		}
		if f == prefix+"RequiresAuditLogging" {
			patchee.RequiresAuditLogging = patcher.RequiresAuditLogging
			continue
		}
		if f == prefix+"DataResidency" {
			patchee.DataResidency = patcher.DataResidency
			continue
		}
		if f == prefix+"ApprovedIntegrations" {
			patchee.ApprovedIntegrations = patcher.ApprovedIntegrations
			continue
		}
		if f == prefix+"AlertEmails" {
			patchee.AlertEmails = patcher.AlertEmails
			continue
		}
		if f == prefix+"WebhookUrl" {
			patchee.WebhookUrl = patcher.WebhookUrl
			continue
		}
		if f == prefix+"AlertOnQuotaThreshold" {
			patchee.AlertOnQuotaThreshold = patcher.AlertOnQuotaThreshold
			continue
		}
		if f == prefix+"QuotaAlertThreshold" {
			patchee.QuotaAlertThreshold = patcher.QuotaAlertThreshold
			continue
		}
		if f == prefix+"AlertOnErrorSpike" {
			patchee.AlertOnErrorSpike = patcher.AlertOnErrorSpike
			continue
		}
		if f == prefix+"ErrorAlertThreshold" {
			patchee.ErrorAlertThreshold = patcher.ErrorAlertThreshold
			continue
		}
		if f == prefix+"MonitoringIntegrations" {
			patchee.MonitoringIntegrations = patcher.MonitoringIntegrations
			continue
		}
		if f == prefix+"Encrypted" {
			patchee.Encrypted = patcher.Encrypted
			continue
		}
		if f == prefix+"DataClassification" {
			patchee.DataClassification = patcher.DataClassification
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAPIKey executes a gorm list call
func DefaultListAPIKey(ctx context.Context, db *gorm.DB) ([]*APIKey, error) {
	in := APIKey{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []APIKeyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APIKeyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*APIKey{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type APIKeyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APIKeyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]APIKeyORM) error
}

// DefaultCreateResult executes a basic gorm create call
func DefaultCreateResult(ctx context.Context, in *Result, db *gorm.DB) (*Result, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ResultORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadResult(ctx context.Context, in *Result, db *gorm.DB) (*Result, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ResultORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ResultORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ResultORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteResult(ctx context.Context, in *Result, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ResultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ResultORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteResultSet(ctx context.Context, in []*Result, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ResultORM{})).(ResultORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ResultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ResultORM{})).(ResultORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ResultORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Result, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Result, *gorm.DB) error
}

// DefaultStrictUpdateResult clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateResult(ctx context.Context, in *Result, db *gorm.DB) (*Result, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateResult")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ResultORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ResultORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchResult executes a basic gorm update call with patch behavior
func DefaultPatchResult(ctx context.Context, in *Result, updateMask *field_mask.FieldMask, db *gorm.DB) (*Result, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Result
	var err error
	if hook, ok := interface{}(&pbObj).(ResultWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadResult(ctx, &Result{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ResultWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskResult(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ResultWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateResult(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ResultWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ResultWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Result, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ResultWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Result, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ResultWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Result, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ResultWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Result, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetResult executes a bulk gorm update call with patch behavior
func DefaultPatchSetResult(ctx context.Context, objects []*Result, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Result, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Result, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchResult(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskResult patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskResult(ctx context.Context, patchee *Result, patcher *Result, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Result, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListResult executes a gorm list call
func DefaultListResult(ctx context.Context, db *gorm.DB) ([]*Result, error) {
	in := Result{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ResultORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ResultORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Result{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ResultORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ResultORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ResultORM) error
}
