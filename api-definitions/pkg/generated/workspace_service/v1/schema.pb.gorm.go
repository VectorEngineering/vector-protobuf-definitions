package workspace_servicev1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/v2/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type AccountORM struct {
	ApiKeys         pq.StringArray `gorm:"type:text[]"`
	Auth0UserId     string         `gorm:"unique"`
	BaseDirectory   string
	BucketName      string
	ComplianceLevel string
	CreatedAt       *time.Time
	DataProfiles    []*DataProfileORM `gorm:"foreignKey:AccountId;references:Id"`
	DeletedAt       *time.Time
	Email           string
	Id              uint64 `gorm:"primaryKey"`
	MfaEnabled      bool
	OrgId           uint64
	Permissions     pq.StringArray `gorm:"type:text[]"`
	Region          string
	Roles           pq.StringArray `gorm:"type:text[]"`
	TenantId        uint64
	UpdatedAt       *time.Time
	Workspaces      []*WorkspaceORM `gorm:"foreignKey:AccountId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (AccountORM) TableName() string {
	return "accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Account) ToORM(ctx context.Context) (AccountORM, error) {
	to := AccountORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Auth0UserId = m.Auth0UserId
	to.Email = m.Email
	to.BaseDirectory = m.BaseDirectory
	to.BucketName = m.BucketName
	to.Region = m.Region
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.Roles != nil {
		to.Roles = make(pq.StringArray, len(m.Roles))
		copy(to.Roles, m.Roles)
	}
	if m.Permissions != nil {
		to.Permissions = make(pq.StringArray, len(m.Permissions))
		copy(to.Permissions, m.Permissions)
	}
	to.MfaEnabled = m.MfaEnabled
	to.ComplianceLevel = ComplianceLevel_name[int32(m.ComplianceLevel)]
	// Repeated type PreferencesEntry is not an ORMable message type
	if m.ApiKeys != nil {
		to.ApiKeys = make(pq.StringArray, len(m.ApiKeys))
		copy(to.ApiKeys, m.ApiKeys)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.Workspaces {
		if v != nil {
			if tempWorkspaces, cErr := v.ToORM(ctx); cErr == nil {
				to.Workspaces = append(to.Workspaces, &tempWorkspaces)
			} else {
				return to, cErr
			}
		} else {
			to.Workspaces = append(to.Workspaces, nil)
		}
	}
	for _, v := range m.DataProfiles {
		if v != nil {
			if tempDataProfiles, cErr := v.ToORM(ctx); cErr == nil {
				to.DataProfiles = append(to.DataProfiles, &tempDataProfiles)
			} else {
				return to, cErr
			}
		} else {
			to.DataProfiles = append(to.DataProfiles, nil)
		}
	}
	if posthook, ok := interface{}(m).(AccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountORM) ToPB(ctx context.Context) (Account, error) {
	to := Account{}
	var err error
	if prehook, ok := interface{}(m).(AccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Auth0UserId = m.Auth0UserId
	to.Email = m.Email
	to.BaseDirectory = m.BaseDirectory
	to.BucketName = m.BucketName
	to.Region = m.Region
	to.OrgId = m.OrgId
	to.TenantId = m.TenantId
	if m.Roles != nil {
		to.Roles = make(pq.StringArray, len(m.Roles))
		copy(to.Roles, m.Roles)
	}
	if m.Permissions != nil {
		to.Permissions = make(pq.StringArray, len(m.Permissions))
		copy(to.Permissions, m.Permissions)
	}
	to.MfaEnabled = m.MfaEnabled
	to.ComplianceLevel = ComplianceLevel(ComplianceLevel_value[m.ComplianceLevel])
	// Repeated type PreferencesEntry is not an ORMable message type
	if m.ApiKeys != nil {
		to.ApiKeys = make(pq.StringArray, len(m.ApiKeys))
		copy(to.ApiKeys, m.ApiKeys)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.Workspaces {
		if v != nil {
			if tempWorkspaces, cErr := v.ToPB(ctx); cErr == nil {
				to.Workspaces = append(to.Workspaces, &tempWorkspaces)
			} else {
				return to, cErr
			}
		} else {
			to.Workspaces = append(to.Workspaces, nil)
		}
	}
	for _, v := range m.DataProfiles {
		if v != nil {
			if tempDataProfiles, cErr := v.ToPB(ctx); cErr == nil {
				to.DataProfiles = append(to.DataProfiles, &tempDataProfiles)
			} else {
				return to, cErr
			}
		} else {
			to.DataProfiles = append(to.DataProfiles, nil)
		}
	}
	if posthook, ok := interface{}(m).(AccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Account the arg will be the target, the caller the one being converted from

// AccountBeforeToORM called before default ToORM code
type AccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountORM) error
}

// AccountAfterToORM called after default ToORM code
type AccountWithAfterToORM interface {
	AfterToORM(context.Context, *AccountORM) error
}

// AccountBeforeToPB called before default ToPB code
type AccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *Account) error
}

// AccountAfterToPB called after default ToPB code
type AccountWithAfterToPB interface {
	AfterToPB(context.Context, *Account) error
}

type DataProfileORM struct {
	AccountId   *uint64
	CreatedAt   *time.Time
	Id          uint64 `gorm:"primaryKey"`
	IsDefault   bool
	Name        string
	ProfileType string
	UpdatedAt   *time.Time
}

// TableName overrides the default tablename generated by GORM
func (DataProfileORM) TableName() string {
	return "data_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DataProfile) ToORM(ctx context.Context) (DataProfileORM, error) {
	to := DataProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(DataProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.ProfileType = m.ProfileType
	// Repeated type DataFieldsEntry is not an ORMable message type
	to.IsDefault = m.IsDefault
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(DataProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DataProfileORM) ToPB(ctx context.Context) (DataProfile, error) {
	to := DataProfile{}
	var err error
	if prehook, ok := interface{}(m).(DataProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.ProfileType = m.ProfileType
	// Repeated type DataFieldsEntry is not an ORMable message type
	to.IsDefault = m.IsDefault
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(DataProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DataProfile the arg will be the target, the caller the one being converted from

// DataProfileBeforeToORM called before default ToORM code
type DataProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *DataProfileORM) error
}

// DataProfileAfterToORM called after default ToORM code
type DataProfileWithAfterToORM interface {
	AfterToORM(context.Context, *DataProfileORM) error
}

// DataProfileBeforeToPB called before default ToPB code
type DataProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *DataProfile) error
}

// DataProfileAfterToPB called after default ToPB code
type DataProfileWithAfterToPB interface {
	AfterToPB(context.Context, *DataProfile) error
}

type WorkspaceORM struct {
	AccountId          *uint64
	Activities         []*WorkspaceActivityORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	AllowPublicSharing bool
	Compliance         []*WorkspaceComplianceORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	Folders            []*FolderMetadataORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	GdprCompliant      bool
	HipaaCompliant     bool
	Id                 uint64               `gorm:"primaryKey"`
	InstalledApps      []*MarketplaceAppORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	Name               string
	RequireApproval    bool
	S3BucketName       string
	S3FolderPath       string
	Sharing            []*WorkspaceSharingORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	StorageQuota       int64
	Templates          []*DocumentTemplateORM `gorm:"foreignKey:WorkspaceId;references:Id"`
	UniqueIdentifier   string
	UpdatedAt          *time.Time
	UsedStorage        int64
}

// TableName overrides the default tablename generated by GORM
func (WorkspaceORM) TableName() string {
	return "workspaces"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Workspace) ToORM(ctx context.Context) (WorkspaceORM, error) {
	to := WorkspaceORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.UniqueIdentifier = m.UniqueIdentifier
	to.S3BucketName = m.S3BucketName
	to.S3FolderPath = m.S3FolderPath
	to.StorageQuota = m.StorageQuota
	to.UsedStorage = m.UsedStorage
	to.AllowPublicSharing = m.AllowPublicSharing
	to.RequireApproval = m.RequireApproval
	to.GdprCompliant = m.GdprCompliant
	to.HipaaCompliant = m.HipaaCompliant
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.Folders {
		if v != nil {
			if tempFolders, cErr := v.ToORM(ctx); cErr == nil {
				to.Folders = append(to.Folders, &tempFolders)
			} else {
				return to, cErr
			}
		} else {
			to.Folders = append(to.Folders, nil)
		}
	}
	for _, v := range m.Templates {
		if v != nil {
			if tempTemplates, cErr := v.ToORM(ctx); cErr == nil {
				to.Templates = append(to.Templates, &tempTemplates)
			} else {
				return to, cErr
			}
		} else {
			to.Templates = append(to.Templates, nil)
		}
	}
	for _, v := range m.Sharing {
		if v != nil {
			if tempSharing, cErr := v.ToORM(ctx); cErr == nil {
				to.Sharing = append(to.Sharing, &tempSharing)
			} else {
				return to, cErr
			}
		} else {
			to.Sharing = append(to.Sharing, nil)
		}
	}
	for _, v := range m.Activities {
		if v != nil {
			if tempActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.Activities = append(to.Activities, &tempActivities)
			} else {
				return to, cErr
			}
		} else {
			to.Activities = append(to.Activities, nil)
		}
	}
	for _, v := range m.Compliance {
		if v != nil {
			if tempCompliance, cErr := v.ToORM(ctx); cErr == nil {
				to.Compliance = append(to.Compliance, &tempCompliance)
			} else {
				return to, cErr
			}
		} else {
			to.Compliance = append(to.Compliance, nil)
		}
	}
	for _, v := range m.InstalledApps {
		if v != nil {
			if tempInstalledApps, cErr := v.ToORM(ctx); cErr == nil {
				to.InstalledApps = append(to.InstalledApps, &tempInstalledApps)
			} else {
				return to, cErr
			}
		} else {
			to.InstalledApps = append(to.InstalledApps, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkspaceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkspaceORM) ToPB(ctx context.Context) (Workspace, error) {
	to := Workspace{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.UniqueIdentifier = m.UniqueIdentifier
	to.S3BucketName = m.S3BucketName
	to.S3FolderPath = m.S3FolderPath
	to.StorageQuota = m.StorageQuota
	to.UsedStorage = m.UsedStorage
	to.AllowPublicSharing = m.AllowPublicSharing
	to.RequireApproval = m.RequireApproval
	to.GdprCompliant = m.GdprCompliant
	to.HipaaCompliant = m.HipaaCompliant
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.Folders {
		if v != nil {
			if tempFolders, cErr := v.ToPB(ctx); cErr == nil {
				to.Folders = append(to.Folders, &tempFolders)
			} else {
				return to, cErr
			}
		} else {
			to.Folders = append(to.Folders, nil)
		}
	}
	for _, v := range m.Templates {
		if v != nil {
			if tempTemplates, cErr := v.ToPB(ctx); cErr == nil {
				to.Templates = append(to.Templates, &tempTemplates)
			} else {
				return to, cErr
			}
		} else {
			to.Templates = append(to.Templates, nil)
		}
	}
	for _, v := range m.Sharing {
		if v != nil {
			if tempSharing, cErr := v.ToPB(ctx); cErr == nil {
				to.Sharing = append(to.Sharing, &tempSharing)
			} else {
				return to, cErr
			}
		} else {
			to.Sharing = append(to.Sharing, nil)
		}
	}
	for _, v := range m.Activities {
		if v != nil {
			if tempActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.Activities = append(to.Activities, &tempActivities)
			} else {
				return to, cErr
			}
		} else {
			to.Activities = append(to.Activities, nil)
		}
	}
	for _, v := range m.Compliance {
		if v != nil {
			if tempCompliance, cErr := v.ToPB(ctx); cErr == nil {
				to.Compliance = append(to.Compliance, &tempCompliance)
			} else {
				return to, cErr
			}
		} else {
			to.Compliance = append(to.Compliance, nil)
		}
	}
	for _, v := range m.InstalledApps {
		if v != nil {
			if tempInstalledApps, cErr := v.ToPB(ctx); cErr == nil {
				to.InstalledApps = append(to.InstalledApps, &tempInstalledApps)
			} else {
				return to, cErr
			}
		} else {
			to.InstalledApps = append(to.InstalledApps, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkspaceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Workspace the arg will be the target, the caller the one being converted from

// WorkspaceBeforeToORM called before default ToORM code
type WorkspaceWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkspaceORM) error
}

// WorkspaceAfterToORM called after default ToORM code
type WorkspaceWithAfterToORM interface {
	AfterToORM(context.Context, *WorkspaceORM) error
}

// WorkspaceBeforeToPB called before default ToPB code
type WorkspaceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Workspace) error
}

// WorkspaceAfterToPB called after default ToPB code
type WorkspaceWithAfterToPB interface {
	AfterToPB(context.Context, *Workspace) error
}

type WorkspaceSharingORM struct {
	CreatedAt       *time.Time
	ExpiresAt       *time.Time
	Id              uint64 `gorm:"primaryKey"`
	PermissionLevel string
	SharedWithEmail string
	UpdatedAt       *time.Time
	WorkspaceId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (WorkspaceSharingORM) TableName() string {
	return "workspace_sharings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *WorkspaceSharing) ToORM(ctx context.Context) (WorkspaceSharingORM, error) {
	to := WorkspaceSharingORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceSharingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SharedWithEmail = m.SharedWithEmail
	to.PermissionLevel = m.PermissionLevel
	if m.ExpiresAt != nil {
		t := m.ExpiresAt.AsTime()
		to.ExpiresAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(WorkspaceSharingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkspaceSharingORM) ToPB(ctx context.Context) (WorkspaceSharing, error) {
	to := WorkspaceSharing{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceSharingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SharedWithEmail = m.SharedWithEmail
	to.PermissionLevel = m.PermissionLevel
	if m.ExpiresAt != nil {
		to.ExpiresAt = timestamppb.New(*m.ExpiresAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(WorkspaceSharingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type WorkspaceSharing the arg will be the target, the caller the one being converted from

// WorkspaceSharingBeforeToORM called before default ToORM code
type WorkspaceSharingWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkspaceSharingORM) error
}

// WorkspaceSharingAfterToORM called after default ToORM code
type WorkspaceSharingWithAfterToORM interface {
	AfterToORM(context.Context, *WorkspaceSharingORM) error
}

// WorkspaceSharingBeforeToPB called before default ToPB code
type WorkspaceSharingWithBeforeToPB interface {
	BeforeToPB(context.Context, *WorkspaceSharing) error
}

// WorkspaceSharingAfterToPB called after default ToPB code
type WorkspaceSharingWithAfterToPB interface {
	AfterToPB(context.Context, *WorkspaceSharing) error
}

type WorkspaceActivityORM struct {
	ActivityType string
	CreatedAt    *time.Time
	Description  string
	Id           uint64 `gorm:"primaryKey"`
	UserId       string
	WorkspaceId  *uint64
}

// TableName overrides the default tablename generated by GORM
func (WorkspaceActivityORM) TableName() string {
	return "workspace_activities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *WorkspaceActivity) ToORM(ctx context.Context) (WorkspaceActivityORM, error) {
	to := WorkspaceActivityORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceActivityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ActivityType = m.ActivityType
	to.UserId = m.UserId
	to.Description = m.Description
	// Repeated type MetadataEntry is not an ORMable message type
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(WorkspaceActivityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkspaceActivityORM) ToPB(ctx context.Context) (WorkspaceActivity, error) {
	to := WorkspaceActivity{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceActivityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ActivityType = m.ActivityType
	to.UserId = m.UserId
	to.Description = m.Description
	// Repeated type MetadataEntry is not an ORMable message type
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(WorkspaceActivityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type WorkspaceActivity the arg will be the target, the caller the one being converted from

// WorkspaceActivityBeforeToORM called before default ToORM code
type WorkspaceActivityWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkspaceActivityORM) error
}

// WorkspaceActivityAfterToORM called after default ToORM code
type WorkspaceActivityWithAfterToORM interface {
	AfterToORM(context.Context, *WorkspaceActivityORM) error
}

// WorkspaceActivityBeforeToPB called before default ToPB code
type WorkspaceActivityWithBeforeToPB interface {
	BeforeToPB(context.Context, *WorkspaceActivity) error
}

// WorkspaceActivityAfterToPB called after default ToPB code
type WorkspaceActivityWithAfterToPB interface {
	AfterToPB(context.Context, *WorkspaceActivity) error
}

type WorkspaceComplianceORM struct {
	CertificationId string
	ComplianceType  string
	CreatedAt       *time.Time
	Id              uint64 `gorm:"primaryKey"`
	Status          string
	UpdatedAt       *time.Time
	ValidUntil      *time.Time
	WorkspaceId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (WorkspaceComplianceORM) TableName() string {
	return "workspace_compliance"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *WorkspaceCompliance) ToORM(ctx context.Context) (WorkspaceComplianceORM, error) {
	to := WorkspaceComplianceORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceComplianceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ComplianceType = m.ComplianceType
	to.Status = m.Status
	to.CertificationId = m.CertificationId
	if m.ValidUntil != nil {
		t := m.ValidUntil.AsTime()
		to.ValidUntil = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(WorkspaceComplianceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkspaceComplianceORM) ToPB(ctx context.Context) (WorkspaceCompliance, error) {
	to := WorkspaceCompliance{}
	var err error
	if prehook, ok := interface{}(m).(WorkspaceComplianceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ComplianceType = m.ComplianceType
	to.Status = m.Status
	to.CertificationId = m.CertificationId
	if m.ValidUntil != nil {
		to.ValidUntil = timestamppb.New(*m.ValidUntil)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(WorkspaceComplianceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type WorkspaceCompliance the arg will be the target, the caller the one being converted from

// WorkspaceComplianceBeforeToORM called before default ToORM code
type WorkspaceComplianceWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkspaceComplianceORM) error
}

// WorkspaceComplianceAfterToORM called after default ToORM code
type WorkspaceComplianceWithAfterToORM interface {
	AfterToORM(context.Context, *WorkspaceComplianceORM) error
}

// WorkspaceComplianceBeforeToPB called before default ToPB code
type WorkspaceComplianceWithBeforeToPB interface {
	BeforeToPB(context.Context, *WorkspaceCompliance) error
}

// WorkspaceComplianceAfterToPB called after default ToPB code
type WorkspaceComplianceWithAfterToPB interface {
	AfterToPB(context.Context, *WorkspaceCompliance) error
}

type FolderMetadataORM struct {
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Id             uint64 `gorm:"primaryKey"`
	IsDeleted      bool
	Name           string
	ParentFolderId uint64
	S3BucketName   string
	S3FolderPath   string
	UpdatedAt      *time.Time
	WorkspaceId    *uint64
}

// TableName overrides the default tablename generated by GORM
func (FolderMetadataORM) TableName() string {
	return "folders"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FolderMetadata) ToORM(ctx context.Context) (FolderMetadataORM, error) {
	to := FolderMetadataORM{}
	var err error
	if prehook, ok := interface{}(m).(FolderMetadataWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.S3BucketName = m.S3BucketName
	to.S3FolderPath = m.S3FolderPath
	to.IsDeleted = m.IsDeleted
	to.ParentFolderId = m.ParentFolderId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	// Repeated type FileMetadata is not an ORMable message type
	if posthook, ok := interface{}(m).(FolderMetadataWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FolderMetadataORM) ToPB(ctx context.Context) (FolderMetadata, error) {
	to := FolderMetadata{}
	var err error
	if prehook, ok := interface{}(m).(FolderMetadataWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.S3BucketName = m.S3BucketName
	to.S3FolderPath = m.S3FolderPath
	to.IsDeleted = m.IsDeleted
	to.ParentFolderId = m.ParentFolderId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	// Repeated type FileMetadata is not an ORMable message type
	if posthook, ok := interface{}(m).(FolderMetadataWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FolderMetadata the arg will be the target, the caller the one being converted from

// FolderMetadataBeforeToORM called before default ToORM code
type FolderMetadataWithBeforeToORM interface {
	BeforeToORM(context.Context, *FolderMetadataORM) error
}

// FolderMetadataAfterToORM called after default ToORM code
type FolderMetadataWithAfterToORM interface {
	AfterToORM(context.Context, *FolderMetadataORM) error
}

// FolderMetadataBeforeToPB called before default ToPB code
type FolderMetadataWithBeforeToPB interface {
	BeforeToPB(context.Context, *FolderMetadata) error
}

// FolderMetadataAfterToPB called after default ToPB code
type FolderMetadataWithAfterToPB interface {
	AfterToPB(context.Context, *FolderMetadata) error
}

type FileEmbeddingsORM struct {
	CreatedAt    *time.Time
	Id           uint64 `gorm:"primaryKey"`
	ModelVersion string
	UpdatedAt    *time.Time
}

// TableName overrides the default tablename generated by GORM
func (FileEmbeddingsORM) TableName() string {
	return "file_embeddings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FileEmbeddings) ToORM(ctx context.Context) (FileEmbeddingsORM, error) {
	to := FileEmbeddingsORM{}
	var err error
	if prehook, ok := interface{}(m).(FileEmbeddingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	// Repeated type float is not an ORMable message type
	to.ModelVersion = m.ModelVersion
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(FileEmbeddingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FileEmbeddingsORM) ToPB(ctx context.Context) (FileEmbeddings, error) {
	to := FileEmbeddings{}
	var err error
	if prehook, ok := interface{}(m).(FileEmbeddingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	// Repeated type float is not an ORMable message type
	to.ModelVersion = m.ModelVersion
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(FileEmbeddingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FileEmbeddings the arg will be the target, the caller the one being converted from

// FileEmbeddingsBeforeToORM called before default ToORM code
type FileEmbeddingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *FileEmbeddingsORM) error
}

// FileEmbeddingsAfterToORM called after default ToORM code
type FileEmbeddingsWithAfterToORM interface {
	AfterToORM(context.Context, *FileEmbeddingsORM) error
}

// FileEmbeddingsBeforeToPB called before default ToPB code
type FileEmbeddingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *FileEmbeddings) error
}

// FileEmbeddingsAfterToPB called after default ToPB code
type FileEmbeddingsWithAfterToPB interface {
	AfterToPB(context.Context, *FileEmbeddings) error
}

type FileVersionORM struct {
	AuthorId      string
	CommitMessage string
	CreatedAt     *time.Time
	FileId        uint64
	Id            uint64 `gorm:"primaryKey"`
	S3Key         string
	Size          int64
	VersionNumber int32
}

// TableName overrides the default tablename generated by GORM
func (FileVersionORM) TableName() string {
	return "file_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FileVersion) ToORM(ctx context.Context) (FileVersionORM, error) {
	to := FileVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(FileVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FileId = m.FileId
	to.VersionNumber = m.VersionNumber
	to.S3Key = m.S3Key
	to.Size = m.Size
	to.CommitMessage = m.CommitMessage
	to.AuthorId = m.AuthorId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(FileVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FileVersionORM) ToPB(ctx context.Context) (FileVersion, error) {
	to := FileVersion{}
	var err error
	if prehook, ok := interface{}(m).(FileVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FileId = m.FileId
	to.VersionNumber = m.VersionNumber
	to.S3Key = m.S3Key
	to.Size = m.Size
	to.CommitMessage = m.CommitMessage
	to.AuthorId = m.AuthorId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(FileVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FileVersion the arg will be the target, the caller the one being converted from

// FileVersionBeforeToORM called before default ToORM code
type FileVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *FileVersionORM) error
}

// FileVersionAfterToORM called after default ToORM code
type FileVersionWithAfterToORM interface {
	AfterToORM(context.Context, *FileVersionORM) error
}

// FileVersionBeforeToPB called before default ToPB code
type FileVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *FileVersion) error
}

// FileVersionAfterToPB called after default ToPB code
type FileVersionWithAfterToPB interface {
	AfterToPB(context.Context, *FileVersion) error
}

type CommentThreadORM struct {
	AuthorId      string
	Content       string
	CreatedAt     *time.Time
	EndPosition   int32
	Id            uint64 `gorm:"primaryKey"`
	Resolved      bool
	StartPosition int32
	UpdatedAt     *time.Time
}

// TableName overrides the default tablename generated by GORM
func (CommentThreadORM) TableName() string {
	return "comment_threads"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CommentThread) ToORM(ctx context.Context) (CommentThreadORM, error) {
	to := CommentThreadORM{}
	var err error
	if prehook, ok := interface{}(m).(CommentThreadWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AuthorId = m.AuthorId
	to.Content = m.Content
	to.StartPosition = m.StartPosition
	to.EndPosition = m.EndPosition
	to.Resolved = m.Resolved
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(CommentThreadWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CommentThreadORM) ToPB(ctx context.Context) (CommentThread, error) {
	to := CommentThread{}
	var err error
	if prehook, ok := interface{}(m).(CommentThreadWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AuthorId = m.AuthorId
	to.Content = m.Content
	to.StartPosition = m.StartPosition
	to.EndPosition = m.EndPosition
	to.Resolved = m.Resolved
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(CommentThreadWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CommentThread the arg will be the target, the caller the one being converted from

// CommentThreadBeforeToORM called before default ToORM code
type CommentThreadWithBeforeToORM interface {
	BeforeToORM(context.Context, *CommentThreadORM) error
}

// CommentThreadAfterToORM called after default ToORM code
type CommentThreadWithAfterToORM interface {
	AfterToORM(context.Context, *CommentThreadORM) error
}

// CommentThreadBeforeToPB called before default ToPB code
type CommentThreadWithBeforeToPB interface {
	BeforeToPB(context.Context, *CommentThread) error
}

// CommentThreadAfterToPB called after default ToPB code
type CommentThreadWithAfterToPB interface {
	AfterToPB(context.Context, *CommentThread) error
}

type FileSharingORM struct {
	CreatedAt       *time.Time
	ExpiresAt       *time.Time
	Id              uint64 `gorm:"primaryKey"`
	PermissionLevel string
	SharedWithEmail string
	UpdatedAt       *time.Time
}

// TableName overrides the default tablename generated by GORM
func (FileSharingORM) TableName() string {
	return "file_sharings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FileSharing) ToORM(ctx context.Context) (FileSharingORM, error) {
	to := FileSharingORM{}
	var err error
	if prehook, ok := interface{}(m).(FileSharingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SharedWithEmail = m.SharedWithEmail
	to.PermissionLevel = m.PermissionLevel
	if m.ExpiresAt != nil {
		t := m.ExpiresAt.AsTime()
		to.ExpiresAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(FileSharingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FileSharingORM) ToPB(ctx context.Context) (FileSharing, error) {
	to := FileSharing{}
	var err error
	if prehook, ok := interface{}(m).(FileSharingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SharedWithEmail = m.SharedWithEmail
	to.PermissionLevel = m.PermissionLevel
	if m.ExpiresAt != nil {
		to.ExpiresAt = timestamppb.New(*m.ExpiresAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(FileSharingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FileSharing the arg will be the target, the caller the one being converted from

// FileSharingBeforeToORM called before default ToORM code
type FileSharingWithBeforeToORM interface {
	BeforeToORM(context.Context, *FileSharingORM) error
}

// FileSharingAfterToORM called after default ToORM code
type FileSharingWithAfterToORM interface {
	AfterToORM(context.Context, *FileSharingORM) error
}

// FileSharingBeforeToPB called before default ToPB code
type FileSharingWithBeforeToPB interface {
	BeforeToPB(context.Context, *FileSharing) error
}

// FileSharingAfterToPB called after default ToPB code
type FileSharingWithAfterToPB interface {
	AfterToPB(context.Context, *FileSharing) error
}

type DocumentTemplateORM struct {
	BaseContent         string
	ConditionalSections pq.StringArray `gorm:"type:text[]"`
	Content             string
	CreatedAt           *time.Time
	Description         string
	DetectedVariables   pq.StringArray `gorm:"type:text[]"`
	DocumentType        string
	Explanations        []*ExplanationBlockORM `gorm:"foreignKey:DocumentTemplateId;references:Id"`
	Id                  uint64                 `gorm:"primaryKey"`
	IndustryType        string
	Instances           []*DocumentInstanceORM     `gorm:"foreignKey:DocumentTemplateId;references:Id"`
	Intelligence        []*ContractIntelligenceORM `gorm:"foreignKey:DocumentTemplateId;references:Id"`
	IsAdaptive          bool
	IsContextAware      bool
	Name                string
	RequiredDataFields  pq.StringArray `gorm:"type:text[]"`
	SupportedContexts   pq.StringArray `gorm:"type:text[]"`
	SupportedLanguages  pq.StringArray `gorm:"type:text[]"`
	TemplateType        string
	UpdatedAt           *time.Time
	Variables           []*TemplateVariableORM `gorm:"foreignKey:DocumentTemplateId;references:Id"`
	Version             string
	Versions            []*TemplateVersionORM `gorm:"foreignKey:DocumentTemplateId;references:Id"`
	WorkspaceId         *uint64
}

// TableName overrides the default tablename generated by GORM
func (DocumentTemplateORM) TableName() string {
	return "document_templates"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DocumentTemplate) ToORM(ctx context.Context) (DocumentTemplateORM, error) {
	to := DocumentTemplateORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentTemplateWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.IndustryType = m.IndustryType
	to.DocumentType = m.DocumentType
	to.BaseContent = m.BaseContent
	to.IsAdaptive = m.IsAdaptive
	// Repeated type MetadataEntry is not an ORMable message type
	if m.SupportedLanguages != nil {
		to.SupportedLanguages = make(pq.StringArray, len(m.SupportedLanguages))
		copy(to.SupportedLanguages, m.SupportedLanguages)
	}
	if m.RequiredDataFields != nil {
		to.RequiredDataFields = make(pq.StringArray, len(m.RequiredDataFields))
		copy(to.RequiredDataFields, m.RequiredDataFields)
	}
	to.Version = m.Version
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.TemplateType = TemplateType_name[int32(m.TemplateType)]
	to.Content = m.Content
	if m.DetectedVariables != nil {
		to.DetectedVariables = make(pq.StringArray, len(m.DetectedVariables))
		copy(to.DetectedVariables, m.DetectedVariables)
	}
	// Repeated type VariableMappingsEntry is not an ORMable message type
	to.IsContextAware = m.IsContextAware
	if m.SupportedContexts != nil {
		to.SupportedContexts = make(pq.StringArray, len(m.SupportedContexts))
		copy(to.SupportedContexts, m.SupportedContexts)
	}
	// Repeated type FormattingRulesEntry is not an ORMable message type
	if m.ConditionalSections != nil {
		to.ConditionalSections = make(pq.StringArray, len(m.ConditionalSections))
		copy(to.ConditionalSections, m.ConditionalSections)
	}
	for _, v := range m.Versions {
		if v != nil {
			if tempVersions, cErr := v.ToORM(ctx); cErr == nil {
				to.Versions = append(to.Versions, &tempVersions)
			} else {
				return to, cErr
			}
		} else {
			to.Versions = append(to.Versions, nil)
		}
	}
	for _, v := range m.Variables {
		if v != nil {
			if tempVariables, cErr := v.ToORM(ctx); cErr == nil {
				to.Variables = append(to.Variables, &tempVariables)
			} else {
				return to, cErr
			}
		} else {
			to.Variables = append(to.Variables, nil)
		}
	}
	for _, v := range m.Instances {
		if v != nil {
			if tempInstances, cErr := v.ToORM(ctx); cErr == nil {
				to.Instances = append(to.Instances, &tempInstances)
			} else {
				return to, cErr
			}
		} else {
			to.Instances = append(to.Instances, nil)
		}
	}
	for _, v := range m.Explanations {
		if v != nil {
			if tempExplanations, cErr := v.ToORM(ctx); cErr == nil {
				to.Explanations = append(to.Explanations, &tempExplanations)
			} else {
				return to, cErr
			}
		} else {
			to.Explanations = append(to.Explanations, nil)
		}
	}
	for _, v := range m.Intelligence {
		if v != nil {
			if tempIntelligence, cErr := v.ToORM(ctx); cErr == nil {
				to.Intelligence = append(to.Intelligence, &tempIntelligence)
			} else {
				return to, cErr
			}
		} else {
			to.Intelligence = append(to.Intelligence, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentTemplateWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentTemplateORM) ToPB(ctx context.Context) (DocumentTemplate, error) {
	to := DocumentTemplate{}
	var err error
	if prehook, ok := interface{}(m).(DocumentTemplateWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.IndustryType = m.IndustryType
	to.DocumentType = m.DocumentType
	to.BaseContent = m.BaseContent
	to.IsAdaptive = m.IsAdaptive
	// Repeated type MetadataEntry is not an ORMable message type
	if m.SupportedLanguages != nil {
		to.SupportedLanguages = make(pq.StringArray, len(m.SupportedLanguages))
		copy(to.SupportedLanguages, m.SupportedLanguages)
	}
	if m.RequiredDataFields != nil {
		to.RequiredDataFields = make(pq.StringArray, len(m.RequiredDataFields))
		copy(to.RequiredDataFields, m.RequiredDataFields)
	}
	to.Version = m.Version
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.TemplateType = TemplateType(TemplateType_value[m.TemplateType])
	to.Content = m.Content
	if m.DetectedVariables != nil {
		to.DetectedVariables = make(pq.StringArray, len(m.DetectedVariables))
		copy(to.DetectedVariables, m.DetectedVariables)
	}
	// Repeated type VariableMappingsEntry is not an ORMable message type
	to.IsContextAware = m.IsContextAware
	if m.SupportedContexts != nil {
		to.SupportedContexts = make(pq.StringArray, len(m.SupportedContexts))
		copy(to.SupportedContexts, m.SupportedContexts)
	}
	// Repeated type FormattingRulesEntry is not an ORMable message type
	if m.ConditionalSections != nil {
		to.ConditionalSections = make(pq.StringArray, len(m.ConditionalSections))
		copy(to.ConditionalSections, m.ConditionalSections)
	}
	for _, v := range m.Versions {
		if v != nil {
			if tempVersions, cErr := v.ToPB(ctx); cErr == nil {
				to.Versions = append(to.Versions, &tempVersions)
			} else {
				return to, cErr
			}
		} else {
			to.Versions = append(to.Versions, nil)
		}
	}
	for _, v := range m.Variables {
		if v != nil {
			if tempVariables, cErr := v.ToPB(ctx); cErr == nil {
				to.Variables = append(to.Variables, &tempVariables)
			} else {
				return to, cErr
			}
		} else {
			to.Variables = append(to.Variables, nil)
		}
	}
	for _, v := range m.Instances {
		if v != nil {
			if tempInstances, cErr := v.ToPB(ctx); cErr == nil {
				to.Instances = append(to.Instances, &tempInstances)
			} else {
				return to, cErr
			}
		} else {
			to.Instances = append(to.Instances, nil)
		}
	}
	for _, v := range m.Explanations {
		if v != nil {
			if tempExplanations, cErr := v.ToPB(ctx); cErr == nil {
				to.Explanations = append(to.Explanations, &tempExplanations)
			} else {
				return to, cErr
			}
		} else {
			to.Explanations = append(to.Explanations, nil)
		}
	}
	for _, v := range m.Intelligence {
		if v != nil {
			if tempIntelligence, cErr := v.ToPB(ctx); cErr == nil {
				to.Intelligence = append(to.Intelligence, &tempIntelligence)
			} else {
				return to, cErr
			}
		} else {
			to.Intelligence = append(to.Intelligence, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentTemplateWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DocumentTemplate the arg will be the target, the caller the one being converted from

// DocumentTemplateBeforeToORM called before default ToORM code
type DocumentTemplateWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentTemplateORM) error
}

// DocumentTemplateAfterToORM called after default ToORM code
type DocumentTemplateWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentTemplateORM) error
}

// DocumentTemplateBeforeToPB called before default ToPB code
type DocumentTemplateWithBeforeToPB interface {
	BeforeToPB(context.Context, *DocumentTemplate) error
}

// DocumentTemplateAfterToPB called after default ToPB code
type DocumentTemplateWithAfterToPB interface {
	AfterToPB(context.Context, *DocumentTemplate) error
}

type TemplateVariableORM struct {
	AiExtractionRules  string
	Alternatives       pq.StringArray `gorm:"type:text[]"`
	DataSource         string
	DefaultValue       string
	Description        string
	DocumentTemplateId *uint64
	Id                 uint64 `gorm:"primaryKey"`
	IsRequired         bool
	Name               string
	TemplateId         uint64
	ValidationRules    string
	VariableType       string
}

// TableName overrides the default tablename generated by GORM
func (TemplateVariableORM) TableName() string {
	return "template_variables"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TemplateVariable) ToORM(ctx context.Context) (TemplateVariableORM, error) {
	to := TemplateVariableORM{}
	var err error
	if prehook, ok := interface{}(m).(TemplateVariableWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.VariableType = m.VariableType
	to.DefaultValue = m.DefaultValue
	to.IsRequired = m.IsRequired
	to.ValidationRules = m.ValidationRules
	to.DataSource = m.DataSource
	to.AiExtractionRules = m.AiExtractionRules
	if m.Alternatives != nil {
		to.Alternatives = make(pq.StringArray, len(m.Alternatives))
		copy(to.Alternatives, m.Alternatives)
	}
	to.TemplateId = m.TemplateId
	if posthook, ok := interface{}(m).(TemplateVariableWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TemplateVariableORM) ToPB(ctx context.Context) (TemplateVariable, error) {
	to := TemplateVariable{}
	var err error
	if prehook, ok := interface{}(m).(TemplateVariableWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.VariableType = m.VariableType
	to.DefaultValue = m.DefaultValue
	to.IsRequired = m.IsRequired
	to.ValidationRules = m.ValidationRules
	to.DataSource = m.DataSource
	to.AiExtractionRules = m.AiExtractionRules
	if m.Alternatives != nil {
		to.Alternatives = make(pq.StringArray, len(m.Alternatives))
		copy(to.Alternatives, m.Alternatives)
	}
	to.TemplateId = m.TemplateId
	if posthook, ok := interface{}(m).(TemplateVariableWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TemplateVariable the arg will be the target, the caller the one being converted from

// TemplateVariableBeforeToORM called before default ToORM code
type TemplateVariableWithBeforeToORM interface {
	BeforeToORM(context.Context, *TemplateVariableORM) error
}

// TemplateVariableAfterToORM called after default ToORM code
type TemplateVariableWithAfterToORM interface {
	AfterToORM(context.Context, *TemplateVariableORM) error
}

// TemplateVariableBeforeToPB called before default ToPB code
type TemplateVariableWithBeforeToPB interface {
	BeforeToPB(context.Context, *TemplateVariable) error
}

// TemplateVariableAfterToPB called after default ToPB code
type TemplateVariableWithAfterToPB interface {
	AfterToPB(context.Context, *TemplateVariable) error
}

type DocumentInstanceORM struct {
	AiAssistance       []*AIAssistanceLogORM `gorm:"foreignKey:DocumentInstanceId;references:Id"`
	Attachments        pq.StringArray        `gorm:"type:text[]"`
	CreatedAt          *time.Time
	DocumentTemplateId *uint64
	DueDate            *time.Time
	GeneratedContent   string
	Id                 uint64 `gorm:"primaryKey"`
	IsCompleted        bool
	Language           string
	Negotiation        *NegotiationHistoryORM `gorm:"foreignKey:DocumentInstanceId;references:Id"`
	SignatureRequests  []*SignatureRequestORM `gorm:"foreignKey:DocumentInstanceId;references:Id"`
	Signers            pq.StringArray         `gorm:"type:text[]"`
	Status             string
	TemplateId         uint64
	UpdatedAt          *time.Time
	Versions           []*DocumentVersionORM `gorm:"foreignKey:DocumentInstanceId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (DocumentInstanceORM) TableName() string {
	return "document_instances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DocumentInstance) ToORM(ctx context.Context) (DocumentInstanceORM, error) {
	to := DocumentInstanceORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentInstanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TemplateId = m.TemplateId
	to.Status = DocumentStatus_name[int32(m.Status)]
	// Repeated type FieldValuesEntry is not an ORMable message type
	if m.Signers != nil {
		to.Signers = make(pq.StringArray, len(m.Signers))
		copy(to.Signers, m.Signers)
	}
	to.Language = m.Language
	to.IsCompleted = m.IsCompleted
	if m.DueDate != nil {
		t := m.DueDate.AsTime()
		to.DueDate = &t
	}
	to.GeneratedContent = m.GeneratedContent
	if m.Attachments != nil {
		to.Attachments = make(pq.StringArray, len(m.Attachments))
		copy(to.Attachments, m.Attachments)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.SignatureRequests {
		if v != nil {
			if tempSignatureRequests, cErr := v.ToORM(ctx); cErr == nil {
				to.SignatureRequests = append(to.SignatureRequests, &tempSignatureRequests)
			} else {
				return to, cErr
			}
		} else {
			to.SignatureRequests = append(to.SignatureRequests, nil)
		}
	}
	for _, v := range m.AiAssistance {
		if v != nil {
			if tempAiAssistance, cErr := v.ToORM(ctx); cErr == nil {
				to.AiAssistance = append(to.AiAssistance, &tempAiAssistance)
			} else {
				return to, cErr
			}
		} else {
			to.AiAssistance = append(to.AiAssistance, nil)
		}
	}
	if m.Negotiation != nil {
		tempNegotiation, err := m.Negotiation.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Negotiation = &tempNegotiation
	}
	for _, v := range m.Versions {
		if v != nil {
			if tempVersions, cErr := v.ToORM(ctx); cErr == nil {
				to.Versions = append(to.Versions, &tempVersions)
			} else {
				return to, cErr
			}
		} else {
			to.Versions = append(to.Versions, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentInstanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentInstanceORM) ToPB(ctx context.Context) (DocumentInstance, error) {
	to := DocumentInstance{}
	var err error
	if prehook, ok := interface{}(m).(DocumentInstanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TemplateId = m.TemplateId
	to.Status = DocumentStatus(DocumentStatus_value[m.Status])
	// Repeated type FieldValuesEntry is not an ORMable message type
	if m.Signers != nil {
		to.Signers = make(pq.StringArray, len(m.Signers))
		copy(to.Signers, m.Signers)
	}
	to.Language = m.Language
	to.IsCompleted = m.IsCompleted
	if m.DueDate != nil {
		to.DueDate = timestamppb.New(*m.DueDate)
	}
	to.GeneratedContent = m.GeneratedContent
	if m.Attachments != nil {
		to.Attachments = make(pq.StringArray, len(m.Attachments))
		copy(to.Attachments, m.Attachments)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.SignatureRequests {
		if v != nil {
			if tempSignatureRequests, cErr := v.ToPB(ctx); cErr == nil {
				to.SignatureRequests = append(to.SignatureRequests, &tempSignatureRequests)
			} else {
				return to, cErr
			}
		} else {
			to.SignatureRequests = append(to.SignatureRequests, nil)
		}
	}
	for _, v := range m.AiAssistance {
		if v != nil {
			if tempAiAssistance, cErr := v.ToPB(ctx); cErr == nil {
				to.AiAssistance = append(to.AiAssistance, &tempAiAssistance)
			} else {
				return to, cErr
			}
		} else {
			to.AiAssistance = append(to.AiAssistance, nil)
		}
	}
	if m.Negotiation != nil {
		tempNegotiation, err := m.Negotiation.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Negotiation = &tempNegotiation
	}
	for _, v := range m.Versions {
		if v != nil {
			if tempVersions, cErr := v.ToPB(ctx); cErr == nil {
				to.Versions = append(to.Versions, &tempVersions)
			} else {
				return to, cErr
			}
		} else {
			to.Versions = append(to.Versions, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentInstanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DocumentInstance the arg will be the target, the caller the one being converted from

// DocumentInstanceBeforeToORM called before default ToORM code
type DocumentInstanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentInstanceORM) error
}

// DocumentInstanceAfterToORM called after default ToORM code
type DocumentInstanceWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentInstanceORM) error
}

// DocumentInstanceBeforeToPB called before default ToPB code
type DocumentInstanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *DocumentInstance) error
}

// DocumentInstanceAfterToPB called after default ToPB code
type DocumentInstanceWithAfterToPB interface {
	AfterToPB(context.Context, *DocumentInstance) error
}

type DocumentVersionORM struct {
	ApprovalChain      string
	AuthorId           string
	BranchName         string
	Branches           []*DocumentBranchORM `gorm:"foreignKey:DocumentVersionId;references:Id"`
	Changes            []*ChangeSetORM      `gorm:"foreignKey:DocumentVersionId;references:Id"`
	CommitMessage      string
	CreatedAt          *time.Time
	DocumentInstanceId *uint64
	Id                 uint64 `gorm:"primaryKey"`
	IsApproved         bool
	ParentHash         string
	Summaries          []*ContextualSummaryORM `gorm:"foreignKey:DocumentVersionId;references:Id"`
	Tags               pq.StringArray          `gorm:"type:text[]"`
	VersionHash        string
}

// TableName overrides the default tablename generated by GORM
func (DocumentVersionORM) TableName() string {
	return "document_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DocumentVersion) ToORM(ctx context.Context) (DocumentVersionORM, error) {
	to := DocumentVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.VersionHash = m.VersionHash
	to.ParentHash = m.ParentHash
	to.CommitMessage = m.CommitMessage
	to.AuthorId = m.AuthorId
	to.BranchName = m.BranchName
	// Repeated type MetadataEntry is not an ORMable message type
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.IsApproved = m.IsApproved
	to.ApprovalChain = m.ApprovalChain
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	for _, v := range m.Branches {
		if v != nil {
			if tempBranches, cErr := v.ToORM(ctx); cErr == nil {
				to.Branches = append(to.Branches, &tempBranches)
			} else {
				return to, cErr
			}
		} else {
			to.Branches = append(to.Branches, nil)
		}
	}
	for _, v := range m.Changes {
		if v != nil {
			if tempChanges, cErr := v.ToORM(ctx); cErr == nil {
				to.Changes = append(to.Changes, &tempChanges)
			} else {
				return to, cErr
			}
		} else {
			to.Changes = append(to.Changes, nil)
		}
	}
	for _, v := range m.Summaries {
		if v != nil {
			if tempSummaries, cErr := v.ToORM(ctx); cErr == nil {
				to.Summaries = append(to.Summaries, &tempSummaries)
			} else {
				return to, cErr
			}
		} else {
			to.Summaries = append(to.Summaries, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentVersionORM) ToPB(ctx context.Context) (DocumentVersion, error) {
	to := DocumentVersion{}
	var err error
	if prehook, ok := interface{}(m).(DocumentVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.VersionHash = m.VersionHash
	to.ParentHash = m.ParentHash
	to.CommitMessage = m.CommitMessage
	to.AuthorId = m.AuthorId
	to.BranchName = m.BranchName
	// Repeated type MetadataEntry is not an ORMable message type
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.IsApproved = m.IsApproved
	to.ApprovalChain = m.ApprovalChain
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	for _, v := range m.Branches {
		if v != nil {
			if tempBranches, cErr := v.ToPB(ctx); cErr == nil {
				to.Branches = append(to.Branches, &tempBranches)
			} else {
				return to, cErr
			}
		} else {
			to.Branches = append(to.Branches, nil)
		}
	}
	for _, v := range m.Changes {
		if v != nil {
			if tempChanges, cErr := v.ToPB(ctx); cErr == nil {
				to.Changes = append(to.Changes, &tempChanges)
			} else {
				return to, cErr
			}
		} else {
			to.Changes = append(to.Changes, nil)
		}
	}
	for _, v := range m.Summaries {
		if v != nil {
			if tempSummaries, cErr := v.ToPB(ctx); cErr == nil {
				to.Summaries = append(to.Summaries, &tempSummaries)
			} else {
				return to, cErr
			}
		} else {
			to.Summaries = append(to.Summaries, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DocumentVersion the arg will be the target, the caller the one being converted from

// DocumentVersionBeforeToORM called before default ToORM code
type DocumentVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentVersionORM) error
}

// DocumentVersionAfterToORM called after default ToORM code
type DocumentVersionWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentVersionORM) error
}

// DocumentVersionBeforeToPB called before default ToPB code
type DocumentVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *DocumentVersion) error
}

// DocumentVersionAfterToPB called after default ToPB code
type DocumentVersionWithAfterToPB interface {
	AfterToPB(context.Context, *DocumentVersion) error
}

type DocumentBranchORM struct {
	BaseVersionHash   string
	CurrentHeadHash   string
	DocumentVersionId *uint64
	Id                uint64 `gorm:"primaryKey"`
	IsLocked          bool
	LastUpdated       *time.Time
	MergeRequests     []*MergeRequestORM `gorm:"foreignKey:DocumentBranchId;references:Id"`
	Merges            []*BranchMergeORM  `gorm:"foreignKey:DocumentBranchId;references:Id"`
	Name              string
	Policy            *BranchPolicyORM `gorm:"foreignKey:DocumentBranchId;references:Id"`
	Purpose           string
	Reviewers         pq.StringArray `gorm:"type:text[]"`
	Status            string
}

// TableName overrides the default tablename generated by GORM
func (DocumentBranchORM) TableName() string {
	return "document_branches"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DocumentBranch) ToORM(ctx context.Context) (DocumentBranchORM, error) {
	to := DocumentBranchORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentBranchWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.BaseVersionHash = m.BaseVersionHash
	to.CurrentHeadHash = m.CurrentHeadHash
	to.Purpose = m.Purpose
	to.Status = m.Status
	if m.Reviewers != nil {
		to.Reviewers = make(pq.StringArray, len(m.Reviewers))
		copy(to.Reviewers, m.Reviewers)
	}
	// Repeated type BranchMetadataEntry is not an ORMable message type
	to.IsLocked = m.IsLocked
	if m.LastUpdated != nil {
		t := m.LastUpdated.AsTime()
		to.LastUpdated = &t
	}
	for _, v := range m.Merges {
		if v != nil {
			if tempMerges, cErr := v.ToORM(ctx); cErr == nil {
				to.Merges = append(to.Merges, &tempMerges)
			} else {
				return to, cErr
			}
		} else {
			to.Merges = append(to.Merges, nil)
		}
	}
	if m.Policy != nil {
		tempPolicy, err := m.Policy.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Policy = &tempPolicy
	}
	for _, v := range m.MergeRequests {
		if v != nil {
			if tempMergeRequests, cErr := v.ToORM(ctx); cErr == nil {
				to.MergeRequests = append(to.MergeRequests, &tempMergeRequests)
			} else {
				return to, cErr
			}
		} else {
			to.MergeRequests = append(to.MergeRequests, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentBranchWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentBranchORM) ToPB(ctx context.Context) (DocumentBranch, error) {
	to := DocumentBranch{}
	var err error
	if prehook, ok := interface{}(m).(DocumentBranchWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.BaseVersionHash = m.BaseVersionHash
	to.CurrentHeadHash = m.CurrentHeadHash
	to.Purpose = m.Purpose
	to.Status = m.Status
	if m.Reviewers != nil {
		to.Reviewers = make(pq.StringArray, len(m.Reviewers))
		copy(to.Reviewers, m.Reviewers)
	}
	// Repeated type BranchMetadataEntry is not an ORMable message type
	to.IsLocked = m.IsLocked
	if m.LastUpdated != nil {
		to.LastUpdated = timestamppb.New(*m.LastUpdated)
	}
	for _, v := range m.Merges {
		if v != nil {
			if tempMerges, cErr := v.ToPB(ctx); cErr == nil {
				to.Merges = append(to.Merges, &tempMerges)
			} else {
				return to, cErr
			}
		} else {
			to.Merges = append(to.Merges, nil)
		}
	}
	if m.Policy != nil {
		tempPolicy, err := m.Policy.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Policy = &tempPolicy
	}
	for _, v := range m.MergeRequests {
		if v != nil {
			if tempMergeRequests, cErr := v.ToPB(ctx); cErr == nil {
				to.MergeRequests = append(to.MergeRequests, &tempMergeRequests)
			} else {
				return to, cErr
			}
		} else {
			to.MergeRequests = append(to.MergeRequests, nil)
		}
	}
	if posthook, ok := interface{}(m).(DocumentBranchWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DocumentBranch the arg will be the target, the caller the one being converted from

// DocumentBranchBeforeToORM called before default ToORM code
type DocumentBranchWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentBranchORM) error
}

// DocumentBranchAfterToORM called after default ToORM code
type DocumentBranchWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentBranchORM) error
}

// DocumentBranchBeforeToPB called before default ToPB code
type DocumentBranchWithBeforeToPB interface {
	BeforeToPB(context.Context, *DocumentBranch) error
}

// DocumentBranchAfterToPB called after default ToPB code
type DocumentBranchWithAfterToPB interface {
	AfterToPB(context.Context, *DocumentBranch) error
}

type SignatureRequestORM struct {
	AuthenticationMethod string
	DocumentId           uint64
	DocumentInstanceId   *uint64
	ExpiresAt            *time.Time
	Id                   uint64         `gorm:"primaryKey"`
	ReminderSchedule     pq.StringArray `gorm:"type:text[]"`
	RequiresMfa          bool
	Role                 string
	SignatureBlocks      []*SignatureBlockORM `gorm:"foreignKey:SignatureRequestId;references:Id"`
	SignatureType        string
	SignerEmail          string
	SignerName           string
	Status               string
	Workflow             *SignatureWorkflowORM `gorm:"foreignKey:SignatureRequestId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (SignatureRequestORM) TableName() string {
	return "signature_requests"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SignatureRequest) ToORM(ctx context.Context) (SignatureRequestORM, error) {
	to := SignatureRequestORM{}
	var err error
	if prehook, ok := interface{}(m).(SignatureRequestWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Status = SignatureStatus_name[int32(m.Status)]
	to.SignerEmail = m.SignerEmail
	to.SignerName = m.SignerName
	to.Role = m.Role
	to.AuthenticationMethod = m.AuthenticationMethod
	if m.ExpiresAt != nil {
		t := m.ExpiresAt.AsTime()
		to.ExpiresAt = &t
	}
	to.RequiresMfa = m.RequiresMfa
	to.SignatureType = m.SignatureType
	if m.ReminderSchedule != nil {
		to.ReminderSchedule = make(pq.StringArray, len(m.ReminderSchedule))
		copy(to.ReminderSchedule, m.ReminderSchedule)
	}
	to.DocumentId = m.DocumentId
	for _, v := range m.SignatureBlocks {
		if v != nil {
			if tempSignatureBlocks, cErr := v.ToORM(ctx); cErr == nil {
				to.SignatureBlocks = append(to.SignatureBlocks, &tempSignatureBlocks)
			} else {
				return to, cErr
			}
		} else {
			to.SignatureBlocks = append(to.SignatureBlocks, nil)
		}
	}
	if m.Workflow != nil {
		tempWorkflow, err := m.Workflow.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Workflow = &tempWorkflow
	}
	if posthook, ok := interface{}(m).(SignatureRequestWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SignatureRequestORM) ToPB(ctx context.Context) (SignatureRequest, error) {
	to := SignatureRequest{}
	var err error
	if prehook, ok := interface{}(m).(SignatureRequestWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Status = SignatureStatus(SignatureStatus_value[m.Status])
	to.SignerEmail = m.SignerEmail
	to.SignerName = m.SignerName
	to.Role = m.Role
	to.AuthenticationMethod = m.AuthenticationMethod
	if m.ExpiresAt != nil {
		to.ExpiresAt = timestamppb.New(*m.ExpiresAt)
	}
	to.RequiresMfa = m.RequiresMfa
	to.SignatureType = m.SignatureType
	if m.ReminderSchedule != nil {
		to.ReminderSchedule = make(pq.StringArray, len(m.ReminderSchedule))
		copy(to.ReminderSchedule, m.ReminderSchedule)
	}
	to.DocumentId = m.DocumentId
	for _, v := range m.SignatureBlocks {
		if v != nil {
			if tempSignatureBlocks, cErr := v.ToPB(ctx); cErr == nil {
				to.SignatureBlocks = append(to.SignatureBlocks, &tempSignatureBlocks)
			} else {
				return to, cErr
			}
		} else {
			to.SignatureBlocks = append(to.SignatureBlocks, nil)
		}
	}
	if m.Workflow != nil {
		tempWorkflow, err := m.Workflow.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Workflow = &tempWorkflow
	}
	if posthook, ok := interface{}(m).(SignatureRequestWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SignatureRequest the arg will be the target, the caller the one being converted from

// SignatureRequestBeforeToORM called before default ToORM code
type SignatureRequestWithBeforeToORM interface {
	BeforeToORM(context.Context, *SignatureRequestORM) error
}

// SignatureRequestAfterToORM called after default ToORM code
type SignatureRequestWithAfterToORM interface {
	AfterToORM(context.Context, *SignatureRequestORM) error
}

// SignatureRequestBeforeToPB called before default ToPB code
type SignatureRequestWithBeforeToPB interface {
	BeforeToPB(context.Context, *SignatureRequest) error
}

// SignatureRequestAfterToPB called after default ToPB code
type SignatureRequestWithAfterToPB interface {
	AfterToPB(context.Context, *SignatureRequest) error
}

type ContractIntelligenceORM struct {
	AnalysisDate       *time.Time
	ComplianceChecks   []*ComplianceCheckORM `gorm:"foreignKey:ContractIntelligenceId;references:Id"`
	ContractType       string
	DocumentTemplateId *uint64
	GoverningLaws      pq.StringArray `gorm:"type:text[]"`
	Id                 uint64         `gorm:"primaryKey"`
	Jurisdiction       string
	KeyObligations     pq.StringArray       `gorm:"type:text[]"`
	RiskAssessments    []*RiskAssessmentORM `gorm:"foreignKey:ContractIntelligenceId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (ContractIntelligenceORM) TableName() string {
	return "contract_intelligence"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ContractIntelligence) ToORM(ctx context.Context) (ContractIntelligenceORM, error) {
	to := ContractIntelligenceORM{}
	var err error
	if prehook, ok := interface{}(m).(ContractIntelligenceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ContractType = m.ContractType
	// Repeated type RiskScoresEntry is not an ORMable message type
	// Repeated type DetectedClausesEntry is not an ORMable message type
	if m.KeyObligations != nil {
		to.KeyObligations = make(pq.StringArray, len(m.KeyObligations))
		copy(to.KeyObligations, m.KeyObligations)
	}
	// Repeated type ComplianceScoresEntry is not an ORMable message type
	to.Jurisdiction = m.Jurisdiction
	if m.GoverningLaws != nil {
		to.GoverningLaws = make(pq.StringArray, len(m.GoverningLaws))
		copy(to.GoverningLaws, m.GoverningLaws)
	}
	// Repeated type SemanticAnalysisEntry is not an ORMable message type
	if m.AnalysisDate != nil {
		t := m.AnalysisDate.AsTime()
		to.AnalysisDate = &t
	}
	for _, v := range m.RiskAssessments {
		if v != nil {
			if tempRiskAssessments, cErr := v.ToORM(ctx); cErr == nil {
				to.RiskAssessments = append(to.RiskAssessments, &tempRiskAssessments)
			} else {
				return to, cErr
			}
		} else {
			to.RiskAssessments = append(to.RiskAssessments, nil)
		}
	}
	for _, v := range m.ComplianceChecks {
		if v != nil {
			if tempComplianceChecks, cErr := v.ToORM(ctx); cErr == nil {
				to.ComplianceChecks = append(to.ComplianceChecks, &tempComplianceChecks)
			} else {
				return to, cErr
			}
		} else {
			to.ComplianceChecks = append(to.ComplianceChecks, nil)
		}
	}
	if posthook, ok := interface{}(m).(ContractIntelligenceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContractIntelligenceORM) ToPB(ctx context.Context) (ContractIntelligence, error) {
	to := ContractIntelligence{}
	var err error
	if prehook, ok := interface{}(m).(ContractIntelligenceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ContractType = m.ContractType
	// Repeated type RiskScoresEntry is not an ORMable message type
	// Repeated type DetectedClausesEntry is not an ORMable message type
	if m.KeyObligations != nil {
		to.KeyObligations = make(pq.StringArray, len(m.KeyObligations))
		copy(to.KeyObligations, m.KeyObligations)
	}
	// Repeated type ComplianceScoresEntry is not an ORMable message type
	to.Jurisdiction = m.Jurisdiction
	if m.GoverningLaws != nil {
		to.GoverningLaws = make(pq.StringArray, len(m.GoverningLaws))
		copy(to.GoverningLaws, m.GoverningLaws)
	}
	// Repeated type SemanticAnalysisEntry is not an ORMable message type
	if m.AnalysisDate != nil {
		to.AnalysisDate = timestamppb.New(*m.AnalysisDate)
	}
	for _, v := range m.RiskAssessments {
		if v != nil {
			if tempRiskAssessments, cErr := v.ToPB(ctx); cErr == nil {
				to.RiskAssessments = append(to.RiskAssessments, &tempRiskAssessments)
			} else {
				return to, cErr
			}
		} else {
			to.RiskAssessments = append(to.RiskAssessments, nil)
		}
	}
	for _, v := range m.ComplianceChecks {
		if v != nil {
			if tempComplianceChecks, cErr := v.ToPB(ctx); cErr == nil {
				to.ComplianceChecks = append(to.ComplianceChecks, &tempComplianceChecks)
			} else {
				return to, cErr
			}
		} else {
			to.ComplianceChecks = append(to.ComplianceChecks, nil)
		}
	}
	if posthook, ok := interface{}(m).(ContractIntelligenceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ContractIntelligence the arg will be the target, the caller the one being converted from

// ContractIntelligenceBeforeToORM called before default ToORM code
type ContractIntelligenceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContractIntelligenceORM) error
}

// ContractIntelligenceAfterToORM called after default ToORM code
type ContractIntelligenceWithAfterToORM interface {
	AfterToORM(context.Context, *ContractIntelligenceORM) error
}

// ContractIntelligenceBeforeToPB called before default ToPB code
type ContractIntelligenceWithBeforeToPB interface {
	BeforeToPB(context.Context, *ContractIntelligence) error
}

// ContractIntelligenceAfterToPB called after default ToPB code
type ContractIntelligenceWithAfterToPB interface {
	AfterToPB(context.Context, *ContractIntelligence) error
}

type MarketplaceAppORM struct {
	Analytics              []*AppAnalyticsORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	Category               string
	Description            string
	DeveloperId            string
	DocumentationUrl       string
	Features               pq.StringArray         `gorm:"type:text[]"`
	Id                     uint64                 `gorm:"primaryKey"`
	Info                   *AppDevelopmentInfoORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	InstallationCount      int32
	Installations          []*AppInstallationORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	IsVerified             bool
	LastUpdated            *time.Time
	Name                   string
	Permissions            []*AppPermissionORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	PricingModel           string
	PrivacyPolicyUrl       string
	PublishedAt            *time.Time
	Rating                 float32
	RequiredPermissions    pq.StringArray  `gorm:"type:text[]"`
	Reviews                []*AppReviewORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	Screenshots            pq.StringArray  `gorm:"type:text[]"`
	SupportEmail           string
	SupportedContractTypes pq.StringArray `gorm:"type:text[]"`
	SupportedIntegrations  pq.StringArray `gorm:"type:text[]"`
	TermsUrl               string
	Versions               []*AppVersionORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	Webhooks               []*AppWebhookORM `gorm:"foreignKey:MarketplaceAppId;references:Id"`
	WorkspaceId            *uint64
}

// TableName overrides the default tablename generated by GORM
func (MarketplaceAppORM) TableName() string {
	return "marketplace_apps"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MarketplaceApp) ToORM(ctx context.Context) (MarketplaceAppORM, error) {
	to := MarketplaceAppORM{}
	var err error
	if prehook, ok := interface{}(m).(MarketplaceAppWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.DeveloperId = m.DeveloperId
	to.Category = AppCategory_name[int32(m.Category)]
	if m.SupportedContractTypes != nil {
		to.SupportedContractTypes = make(pq.StringArray, len(m.SupportedContractTypes))
		copy(to.SupportedContractTypes, m.SupportedContractTypes)
	}
	if m.Features != nil {
		to.Features = make(pq.StringArray, len(m.Features))
		copy(to.Features, m.Features)
	}
	to.PricingModel = PricingModel_name[int32(m.PricingModel)]
	// Repeated type PricingTiersEntry is not an ORMable message type
	if m.SupportedIntegrations != nil {
		to.SupportedIntegrations = make(pq.StringArray, len(m.SupportedIntegrations))
		copy(to.SupportedIntegrations, m.SupportedIntegrations)
	}
	to.IsVerified = m.IsVerified
	to.Rating = m.Rating
	to.InstallationCount = m.InstallationCount
	if m.RequiredPermissions != nil {
		to.RequiredPermissions = make(pq.StringArray, len(m.RequiredPermissions))
		copy(to.RequiredPermissions, m.RequiredPermissions)
	}
	// Repeated type MetadataEntry is not an ORMable message type
	to.DocumentationUrl = m.DocumentationUrl
	to.SupportEmail = m.SupportEmail
	if m.Screenshots != nil {
		to.Screenshots = make(pq.StringArray, len(m.Screenshots))
		copy(to.Screenshots, m.Screenshots)
	}
	to.PrivacyPolicyUrl = m.PrivacyPolicyUrl
	to.TermsUrl = m.TermsUrl
	if m.PublishedAt != nil {
		t := m.PublishedAt.AsTime()
		to.PublishedAt = &t
	}
	if m.LastUpdated != nil {
		t := m.LastUpdated.AsTime()
		to.LastUpdated = &t
	}
	for _, v := range m.Versions {
		if v != nil {
			if tempVersions, cErr := v.ToORM(ctx); cErr == nil {
				to.Versions = append(to.Versions, &tempVersions)
			} else {
				return to, cErr
			}
		} else {
			to.Versions = append(to.Versions, nil)
		}
	}
	for _, v := range m.Installations {
		if v != nil {
			if tempInstallations, cErr := v.ToORM(ctx); cErr == nil {
				to.Installations = append(to.Installations, &tempInstallations)
			} else {
				return to, cErr
			}
		} else {
			to.Installations = append(to.Installations, nil)
		}
	}
	for _, v := range m.Analytics {
		if v != nil {
			if tempAnalytics, cErr := v.ToORM(ctx); cErr == nil {
				to.Analytics = append(to.Analytics, &tempAnalytics)
			} else {
				return to, cErr
			}
		} else {
			to.Analytics = append(to.Analytics, nil)
		}
	}
	for _, v := range m.Reviews {
		if v != nil {
			if tempReviews, cErr := v.ToORM(ctx); cErr == nil {
				to.Reviews = append(to.Reviews, &tempReviews)
			} else {
				return to, cErr
			}
		} else {
			to.Reviews = append(to.Reviews, nil)
		}
	}
	if m.Info != nil {
		tempInfo, err := m.Info.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Info = &tempInfo
	}
	for _, v := range m.Webhooks {
		if v != nil {
			if tempWebhooks, cErr := v.ToORM(ctx); cErr == nil {
				to.Webhooks = append(to.Webhooks, &tempWebhooks)
			} else {
				return to, cErr
			}
		} else {
			to.Webhooks = append(to.Webhooks, nil)
		}
	}
	for _, v := range m.Permissions {
		if v != nil {
			if tempPermissions, cErr := v.ToORM(ctx); cErr == nil {
				to.Permissions = append(to.Permissions, &tempPermissions)
			} else {
				return to, cErr
			}
		} else {
			to.Permissions = append(to.Permissions, nil)
		}
	}
	if posthook, ok := interface{}(m).(MarketplaceAppWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MarketplaceAppORM) ToPB(ctx context.Context) (MarketplaceApp, error) {
	to := MarketplaceApp{}
	var err error
	if prehook, ok := interface{}(m).(MarketplaceAppWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.DeveloperId = m.DeveloperId
	to.Category = AppCategory(AppCategory_value[m.Category])
	if m.SupportedContractTypes != nil {
		to.SupportedContractTypes = make(pq.StringArray, len(m.SupportedContractTypes))
		copy(to.SupportedContractTypes, m.SupportedContractTypes)
	}
	if m.Features != nil {
		to.Features = make(pq.StringArray, len(m.Features))
		copy(to.Features, m.Features)
	}
	to.PricingModel = PricingModel(PricingModel_value[m.PricingModel])
	// Repeated type PricingTiersEntry is not an ORMable message type
	if m.SupportedIntegrations != nil {
		to.SupportedIntegrations = make(pq.StringArray, len(m.SupportedIntegrations))
		copy(to.SupportedIntegrations, m.SupportedIntegrations)
	}
	to.IsVerified = m.IsVerified
	to.Rating = m.Rating
	to.InstallationCount = m.InstallationCount
	if m.RequiredPermissions != nil {
		to.RequiredPermissions = make(pq.StringArray, len(m.RequiredPermissions))
		copy(to.RequiredPermissions, m.RequiredPermissions)
	}
	// Repeated type MetadataEntry is not an ORMable message type
	to.DocumentationUrl = m.DocumentationUrl
	to.SupportEmail = m.SupportEmail
	if m.Screenshots != nil {
		to.Screenshots = make(pq.StringArray, len(m.Screenshots))
		copy(to.Screenshots, m.Screenshots)
	}
	to.PrivacyPolicyUrl = m.PrivacyPolicyUrl
	to.TermsUrl = m.TermsUrl
	if m.PublishedAt != nil {
		to.PublishedAt = timestamppb.New(*m.PublishedAt)
	}
	if m.LastUpdated != nil {
		to.LastUpdated = timestamppb.New(*m.LastUpdated)
	}
	for _, v := range m.Versions {
		if v != nil {
			if tempVersions, cErr := v.ToPB(ctx); cErr == nil {
				to.Versions = append(to.Versions, &tempVersions)
			} else {
				return to, cErr
			}
		} else {
			to.Versions = append(to.Versions, nil)
		}
	}
	for _, v := range m.Installations {
		if v != nil {
			if tempInstallations, cErr := v.ToPB(ctx); cErr == nil {
				to.Installations = append(to.Installations, &tempInstallations)
			} else {
				return to, cErr
			}
		} else {
			to.Installations = append(to.Installations, nil)
		}
	}
	for _, v := range m.Analytics {
		if v != nil {
			if tempAnalytics, cErr := v.ToPB(ctx); cErr == nil {
				to.Analytics = append(to.Analytics, &tempAnalytics)
			} else {
				return to, cErr
			}
		} else {
			to.Analytics = append(to.Analytics, nil)
		}
	}
	for _, v := range m.Reviews {
		if v != nil {
			if tempReviews, cErr := v.ToPB(ctx); cErr == nil {
				to.Reviews = append(to.Reviews, &tempReviews)
			} else {
				return to, cErr
			}
		} else {
			to.Reviews = append(to.Reviews, nil)
		}
	}
	if m.Info != nil {
		tempInfo, err := m.Info.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Info = &tempInfo
	}
	for _, v := range m.Webhooks {
		if v != nil {
			if tempWebhooks, cErr := v.ToPB(ctx); cErr == nil {
				to.Webhooks = append(to.Webhooks, &tempWebhooks)
			} else {
				return to, cErr
			}
		} else {
			to.Webhooks = append(to.Webhooks, nil)
		}
	}
	for _, v := range m.Permissions {
		if v != nil {
			if tempPermissions, cErr := v.ToPB(ctx); cErr == nil {
				to.Permissions = append(to.Permissions, &tempPermissions)
			} else {
				return to, cErr
			}
		} else {
			to.Permissions = append(to.Permissions, nil)
		}
	}
	if posthook, ok := interface{}(m).(MarketplaceAppWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MarketplaceApp the arg will be the target, the caller the one being converted from

// MarketplaceAppBeforeToORM called before default ToORM code
type MarketplaceAppWithBeforeToORM interface {
	BeforeToORM(context.Context, *MarketplaceAppORM) error
}

// MarketplaceAppAfterToORM called after default ToORM code
type MarketplaceAppWithAfterToORM interface {
	AfterToORM(context.Context, *MarketplaceAppORM) error
}

// MarketplaceAppBeforeToPB called before default ToPB code
type MarketplaceAppWithBeforeToPB interface {
	BeforeToPB(context.Context, *MarketplaceApp) error
}

// MarketplaceAppAfterToPB called after default ToPB code
type MarketplaceAppWithAfterToPB interface {
	AfterToPB(context.Context, *MarketplaceApp) error
}

type DocumentSnapshotORM struct {
	AuthorId     string
	Content      []byte `gorm:"type:bytea"`
	CreatedAt    *time.Time
	FileId       uint64
	Id           uint64 `gorm:"primaryKey"`
	Reason       string
	SnapshotHash string
}

// TableName overrides the default tablename generated by GORM
func (DocumentSnapshotORM) TableName() string {
	return "document_snapshots"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DocumentSnapshot) ToORM(ctx context.Context) (DocumentSnapshotORM, error) {
	to := DocumentSnapshotORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentSnapshotWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FileId = m.FileId
	to.SnapshotHash = m.SnapshotHash
	to.Content = m.Content
	to.AuthorId = m.AuthorId
	to.Reason = m.Reason
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(DocumentSnapshotWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentSnapshotORM) ToPB(ctx context.Context) (DocumentSnapshot, error) {
	to := DocumentSnapshot{}
	var err error
	if prehook, ok := interface{}(m).(DocumentSnapshotWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FileId = m.FileId
	to.SnapshotHash = m.SnapshotHash
	to.Content = m.Content
	to.AuthorId = m.AuthorId
	to.Reason = m.Reason
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(DocumentSnapshotWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DocumentSnapshot the arg will be the target, the caller the one being converted from

// DocumentSnapshotBeforeToORM called before default ToORM code
type DocumentSnapshotWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentSnapshotORM) error
}

// DocumentSnapshotAfterToORM called after default ToORM code
type DocumentSnapshotWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentSnapshotORM) error
}

// DocumentSnapshotBeforeToPB called before default ToPB code
type DocumentSnapshotWithBeforeToPB interface {
	BeforeToPB(context.Context, *DocumentSnapshot) error
}

// DocumentSnapshotAfterToPB called after default ToPB code
type DocumentSnapshotWithAfterToPB interface {
	AfterToPB(context.Context, *DocumentSnapshot) error
}

type TemplateVersionORM struct {
	AuthorId           string
	BaseContent        string
	ChangeDescription  string
	CreatedAt          *time.Time
	DocumentTemplateId *uint64
	Id                 uint64 `gorm:"primaryKey"`
	TemplateId         uint64
	Version            string
}

// TableName overrides the default tablename generated by GORM
func (TemplateVersionORM) TableName() string {
	return "template_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TemplateVersion) ToORM(ctx context.Context) (TemplateVersionORM, error) {
	to := TemplateVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(TemplateVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TemplateId = m.TemplateId
	to.Version = m.Version
	to.BaseContent = m.BaseContent
	// Repeated type MetadataEntry is not an ORMable message type
	to.AuthorId = m.AuthorId
	to.ChangeDescription = m.ChangeDescription
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(TemplateVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TemplateVersionORM) ToPB(ctx context.Context) (TemplateVersion, error) {
	to := TemplateVersion{}
	var err error
	if prehook, ok := interface{}(m).(TemplateVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TemplateId = m.TemplateId
	to.Version = m.Version
	to.BaseContent = m.BaseContent
	// Repeated type MetadataEntry is not an ORMable message type
	to.AuthorId = m.AuthorId
	to.ChangeDescription = m.ChangeDescription
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(TemplateVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TemplateVersion the arg will be the target, the caller the one being converted from

// TemplateVersionBeforeToORM called before default ToORM code
type TemplateVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *TemplateVersionORM) error
}

// TemplateVersionAfterToORM called after default ToORM code
type TemplateVersionWithAfterToORM interface {
	AfterToORM(context.Context, *TemplateVersionORM) error
}

// TemplateVersionBeforeToPB called before default ToPB code
type TemplateVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *TemplateVersion) error
}

// TemplateVersionAfterToPB called after default ToPB code
type TemplateVersionWithAfterToPB interface {
	AfterToPB(context.Context, *TemplateVersion) error
}

type ExplanationBlockORM struct {
	ComplexityLevel    string
	CreatedAt          *time.Time
	DocumentTemplateId *uint64
	ExplanationText    string
	Id                 uint64         `gorm:"primaryKey"`
	LegalReferences    pq.StringArray `gorm:"type:text[]"`
	RelatedTerms       pq.StringArray `gorm:"type:text[]"`
	SectionIdentifier  string
	TemplateId         uint64
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ExplanationBlockORM) TableName() string {
	return "explanation_blocks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExplanationBlock) ToORM(ctx context.Context) (ExplanationBlockORM, error) {
	to := ExplanationBlockORM{}
	var err error
	if prehook, ok := interface{}(m).(ExplanationBlockWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TemplateId = m.TemplateId
	to.SectionIdentifier = m.SectionIdentifier
	to.ExplanationText = m.ExplanationText
	to.ComplexityLevel = m.ComplexityLevel
	if m.RelatedTerms != nil {
		to.RelatedTerms = make(pq.StringArray, len(m.RelatedTerms))
		copy(to.RelatedTerms, m.RelatedTerms)
	}
	if m.LegalReferences != nil {
		to.LegalReferences = make(pq.StringArray, len(m.LegalReferences))
		copy(to.LegalReferences, m.LegalReferences)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(ExplanationBlockWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExplanationBlockORM) ToPB(ctx context.Context) (ExplanationBlock, error) {
	to := ExplanationBlock{}
	var err error
	if prehook, ok := interface{}(m).(ExplanationBlockWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TemplateId = m.TemplateId
	to.SectionIdentifier = m.SectionIdentifier
	to.ExplanationText = m.ExplanationText
	to.ComplexityLevel = m.ComplexityLevel
	if m.RelatedTerms != nil {
		to.RelatedTerms = make(pq.StringArray, len(m.RelatedTerms))
		copy(to.RelatedTerms, m.RelatedTerms)
	}
	if m.LegalReferences != nil {
		to.LegalReferences = make(pq.StringArray, len(m.LegalReferences))
		copy(to.LegalReferences, m.LegalReferences)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(ExplanationBlockWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExplanationBlock the arg will be the target, the caller the one being converted from

// ExplanationBlockBeforeToORM called before default ToORM code
type ExplanationBlockWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExplanationBlockORM) error
}

// ExplanationBlockAfterToORM called after default ToORM code
type ExplanationBlockWithAfterToORM interface {
	AfterToORM(context.Context, *ExplanationBlockORM) error
}

// ExplanationBlockBeforeToPB called before default ToPB code
type ExplanationBlockWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExplanationBlock) error
}

// ExplanationBlockAfterToPB called after default ToPB code
type ExplanationBlockWithAfterToPB interface {
	AfterToPB(context.Context, *ExplanationBlock) error
}

type AIAssistanceLogORM struct {
	AiResponse         string
	CreatedAt          *time.Time
	DocumentId         uint64
	DocumentInstanceId *uint64
	Id                 uint64 `gorm:"primaryKey"`
	InteractionType    string
	UserQuery          string
}

// TableName overrides the default tablename generated by GORM
func (AIAssistanceLogORM) TableName() string {
	return "ai_assistance_logs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AIAssistanceLog) ToORM(ctx context.Context) (AIAssistanceLogORM, error) {
	to := AIAssistanceLogORM{}
	var err error
	if prehook, ok := interface{}(m).(AIAssistanceLogWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DocumentId = m.DocumentId
	to.InteractionType = m.InteractionType
	to.UserQuery = m.UserQuery
	to.AiResponse = m.AiResponse
	// Repeated type ContextEntry is not an ORMable message type
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(AIAssistanceLogWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AIAssistanceLogORM) ToPB(ctx context.Context) (AIAssistanceLog, error) {
	to := AIAssistanceLog{}
	var err error
	if prehook, ok := interface{}(m).(AIAssistanceLogWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DocumentId = m.DocumentId
	to.InteractionType = m.InteractionType
	to.UserQuery = m.UserQuery
	to.AiResponse = m.AiResponse
	// Repeated type ContextEntry is not an ORMable message type
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(AIAssistanceLogWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AIAssistanceLog the arg will be the target, the caller the one being converted from

// AIAssistanceLogBeforeToORM called before default ToORM code
type AIAssistanceLogWithBeforeToORM interface {
	BeforeToORM(context.Context, *AIAssistanceLogORM) error
}

// AIAssistanceLogAfterToORM called after default ToORM code
type AIAssistanceLogWithAfterToORM interface {
	AfterToORM(context.Context, *AIAssistanceLogORM) error
}

// AIAssistanceLogBeforeToPB called before default ToPB code
type AIAssistanceLogWithBeforeToPB interface {
	BeforeToPB(context.Context, *AIAssistanceLog) error
}

// AIAssistanceLogAfterToPB called after default ToPB code
type AIAssistanceLogWithAfterToPB interface {
	AfterToPB(context.Context, *AIAssistanceLog) error
}

type NegotiationHistoryORM struct {
	CurrentStatus      string
	DocumentId         uint64
	DocumentInstanceId *uint64
	Id                 uint64 `gorm:"primaryKey"`
	LastUpdated        *time.Time
	Rounds             []*NegotiationRoundORM `gorm:"foreignKey:NegotiationHistoryId;references:Id"`
	StartedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NegotiationHistoryORM) TableName() string {
	return "negotiation_histories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NegotiationHistory) ToORM(ctx context.Context) (NegotiationHistoryORM, error) {
	to := NegotiationHistoryORM{}
	var err error
	if prehook, ok := interface{}(m).(NegotiationHistoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DocumentId = m.DocumentId
	for _, v := range m.Rounds {
		if v != nil {
			if tempRounds, cErr := v.ToORM(ctx); cErr == nil {
				to.Rounds = append(to.Rounds, &tempRounds)
			} else {
				return to, cErr
			}
		} else {
			to.Rounds = append(to.Rounds, nil)
		}
	}
	to.CurrentStatus = m.CurrentStatus
	if m.StartedAt != nil {
		t := m.StartedAt.AsTime()
		to.StartedAt = &t
	}
	if m.LastUpdated != nil {
		t := m.LastUpdated.AsTime()
		to.LastUpdated = &t
	}
	if posthook, ok := interface{}(m).(NegotiationHistoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NegotiationHistoryORM) ToPB(ctx context.Context) (NegotiationHistory, error) {
	to := NegotiationHistory{}
	var err error
	if prehook, ok := interface{}(m).(NegotiationHistoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DocumentId = m.DocumentId
	for _, v := range m.Rounds {
		if v != nil {
			if tempRounds, cErr := v.ToPB(ctx); cErr == nil {
				to.Rounds = append(to.Rounds, &tempRounds)
			} else {
				return to, cErr
			}
		} else {
			to.Rounds = append(to.Rounds, nil)
		}
	}
	to.CurrentStatus = m.CurrentStatus
	if m.StartedAt != nil {
		to.StartedAt = timestamppb.New(*m.StartedAt)
	}
	if m.LastUpdated != nil {
		to.LastUpdated = timestamppb.New(*m.LastUpdated)
	}
	if posthook, ok := interface{}(m).(NegotiationHistoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NegotiationHistory the arg will be the target, the caller the one being converted from

// NegotiationHistoryBeforeToORM called before default ToORM code
type NegotiationHistoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *NegotiationHistoryORM) error
}

// NegotiationHistoryAfterToORM called after default ToORM code
type NegotiationHistoryWithAfterToORM interface {
	AfterToORM(context.Context, *NegotiationHistoryORM) error
}

// NegotiationHistoryBeforeToPB called before default ToPB code
type NegotiationHistoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *NegotiationHistory) error
}

// NegotiationHistoryAfterToPB called after default ToPB code
type NegotiationHistoryWithAfterToPB interface {
	AfterToPB(context.Context, *NegotiationHistory) error
}

type NegotiationRoundORM struct {
	CreatedAt            *time.Time
	HistoryId            uint64
	Id                   uint64 `gorm:"primaryKey"`
	NegotiationHistoryId *uint64
	ProposalContent      string
	ProposerId           string
	ResponseContent      string
	RoundNumber          int32
	Status               string
}

// TableName overrides the default tablename generated by GORM
func (NegotiationRoundORM) TableName() string {
	return "negotiation_rounds"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NegotiationRound) ToORM(ctx context.Context) (NegotiationRoundORM, error) {
	to := NegotiationRoundORM{}
	var err error
	if prehook, ok := interface{}(m).(NegotiationRoundWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.HistoryId = m.HistoryId
	to.RoundNumber = m.RoundNumber
	to.ProposerId = m.ProposerId
	to.ProposalContent = m.ProposalContent
	to.ResponseContent = m.ResponseContent
	to.Status = m.Status
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(NegotiationRoundWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NegotiationRoundORM) ToPB(ctx context.Context) (NegotiationRound, error) {
	to := NegotiationRound{}
	var err error
	if prehook, ok := interface{}(m).(NegotiationRoundWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.HistoryId = m.HistoryId
	to.RoundNumber = m.RoundNumber
	to.ProposerId = m.ProposerId
	to.ProposalContent = m.ProposalContent
	to.ResponseContent = m.ResponseContent
	to.Status = m.Status
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(NegotiationRoundWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NegotiationRound the arg will be the target, the caller the one being converted from

// NegotiationRoundBeforeToORM called before default ToORM code
type NegotiationRoundWithBeforeToORM interface {
	BeforeToORM(context.Context, *NegotiationRoundORM) error
}

// NegotiationRoundAfterToORM called after default ToORM code
type NegotiationRoundWithAfterToORM interface {
	AfterToORM(context.Context, *NegotiationRoundORM) error
}

// NegotiationRoundBeforeToPB called before default ToPB code
type NegotiationRoundWithBeforeToPB interface {
	BeforeToPB(context.Context, *NegotiationRound) error
}

// NegotiationRoundAfterToPB called after default ToPB code
type NegotiationRoundWithAfterToPB interface {
	AfterToPB(context.Context, *NegotiationRound) error
}

type ChangeSetORM struct {
	ChangeType        string
	ContentAfter      string
	ContentBefore     string
	CreatedAt         *time.Time
	DocumentVersionId *uint64
	Id                uint64 `gorm:"primaryKey"`
	VersionId         uint64
}

// TableName overrides the default tablename generated by GORM
func (ChangeSetORM) TableName() string {
	return "change_sets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ChangeSet) ToORM(ctx context.Context) (ChangeSetORM, error) {
	to := ChangeSetORM{}
	var err error
	if prehook, ok := interface{}(m).(ChangeSetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.VersionId = m.VersionId
	to.ChangeType = m.ChangeType
	to.ContentBefore = m.ContentBefore
	to.ContentAfter = m.ContentAfter
	// Repeated type MetadataEntry is not an ORMable message type
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(ChangeSetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ChangeSetORM) ToPB(ctx context.Context) (ChangeSet, error) {
	to := ChangeSet{}
	var err error
	if prehook, ok := interface{}(m).(ChangeSetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.VersionId = m.VersionId
	to.ChangeType = m.ChangeType
	to.ContentBefore = m.ContentBefore
	to.ContentAfter = m.ContentAfter
	// Repeated type MetadataEntry is not an ORMable message type
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(ChangeSetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ChangeSet the arg will be the target, the caller the one being converted from

// ChangeSetBeforeToORM called before default ToORM code
type ChangeSetWithBeforeToORM interface {
	BeforeToORM(context.Context, *ChangeSetORM) error
}

// ChangeSetAfterToORM called after default ToORM code
type ChangeSetWithAfterToORM interface {
	AfterToORM(context.Context, *ChangeSetORM) error
}

// ChangeSetBeforeToPB called before default ToPB code
type ChangeSetWithBeforeToPB interface {
	BeforeToPB(context.Context, *ChangeSet) error
}

// ChangeSetAfterToPB called after default ToPB code
type ChangeSetWithAfterToPB interface {
	AfterToPB(context.Context, *ChangeSet) error
}

type ContextualSummaryORM struct {
	Content           string
	CreatedAt         *time.Time
	DocumentVersionId *uint64
	Id                uint64         `gorm:"primaryKey"`
	KeyPoints         pq.StringArray `gorm:"type:text[]"`
	SummaryType       string
	TargetAudience    string
	VersionId         uint64
}

// TableName overrides the default tablename generated by GORM
func (ContextualSummaryORM) TableName() string {
	return "contextual_summaries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ContextualSummary) ToORM(ctx context.Context) (ContextualSummaryORM, error) {
	to := ContextualSummaryORM{}
	var err error
	if prehook, ok := interface{}(m).(ContextualSummaryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.VersionId = m.VersionId
	to.SummaryType = m.SummaryType
	to.Content = m.Content
	to.TargetAudience = m.TargetAudience
	if m.KeyPoints != nil {
		to.KeyPoints = make(pq.StringArray, len(m.KeyPoints))
		copy(to.KeyPoints, m.KeyPoints)
	}
	// Repeated type MetadataEntry is not an ORMable message type
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(ContextualSummaryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContextualSummaryORM) ToPB(ctx context.Context) (ContextualSummary, error) {
	to := ContextualSummary{}
	var err error
	if prehook, ok := interface{}(m).(ContextualSummaryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.VersionId = m.VersionId
	to.SummaryType = m.SummaryType
	to.Content = m.Content
	to.TargetAudience = m.TargetAudience
	if m.KeyPoints != nil {
		to.KeyPoints = make(pq.StringArray, len(m.KeyPoints))
		copy(to.KeyPoints, m.KeyPoints)
	}
	// Repeated type MetadataEntry is not an ORMable message type
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(ContextualSummaryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ContextualSummary the arg will be the target, the caller the one being converted from

// ContextualSummaryBeforeToORM called before default ToORM code
type ContextualSummaryWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContextualSummaryORM) error
}

// ContextualSummaryAfterToORM called after default ToORM code
type ContextualSummaryWithAfterToORM interface {
	AfterToORM(context.Context, *ContextualSummaryORM) error
}

// ContextualSummaryBeforeToPB called before default ToPB code
type ContextualSummaryWithBeforeToPB interface {
	BeforeToPB(context.Context, *ContextualSummary) error
}

// ContextualSummaryAfterToPB called after default ToPB code
type ContextualSummaryWithAfterToPB interface {
	AfterToPB(context.Context, *ContextualSummary) error
}

type BranchMergeORM struct {
	BranchId         uint64
	CompletedAt      *time.Time
	Conflicts        pq.StringArray `gorm:"type:text[]"`
	CreatedAt        *time.Time
	DocumentBranchId *uint64
	Id               uint64 `gorm:"primaryKey"`
	MergeStatus      string
	MergeStrategy    string
	MergerId         string
	SourceBranch     string
	TargetBranch     string
}

// TableName overrides the default tablename generated by GORM
func (BranchMergeORM) TableName() string {
	return "branch_merges"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BranchMerge) ToORM(ctx context.Context) (BranchMergeORM, error) {
	to := BranchMergeORM{}
	var err error
	if prehook, ok := interface{}(m).(BranchMergeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BranchId = m.BranchId
	to.SourceBranch = m.SourceBranch
	to.TargetBranch = m.TargetBranch
	to.MergeStatus = m.MergeStatus
	to.MergeStrategy = m.MergeStrategy
	if m.Conflicts != nil {
		to.Conflicts = make(pq.StringArray, len(m.Conflicts))
		copy(to.Conflicts, m.Conflicts)
	}
	to.MergerId = m.MergerId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.CompletedAt != nil {
		t := m.CompletedAt.AsTime()
		to.CompletedAt = &t
	}
	if posthook, ok := interface{}(m).(BranchMergeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BranchMergeORM) ToPB(ctx context.Context) (BranchMerge, error) {
	to := BranchMerge{}
	var err error
	if prehook, ok := interface{}(m).(BranchMergeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BranchId = m.BranchId
	to.SourceBranch = m.SourceBranch
	to.TargetBranch = m.TargetBranch
	to.MergeStatus = m.MergeStatus
	to.MergeStrategy = m.MergeStrategy
	if m.Conflicts != nil {
		to.Conflicts = make(pq.StringArray, len(m.Conflicts))
		copy(to.Conflicts, m.Conflicts)
	}
	to.MergerId = m.MergerId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.CompletedAt != nil {
		to.CompletedAt = timestamppb.New(*m.CompletedAt)
	}
	if posthook, ok := interface{}(m).(BranchMergeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BranchMerge the arg will be the target, the caller the one being converted from

// BranchMergeBeforeToORM called before default ToORM code
type BranchMergeWithBeforeToORM interface {
	BeforeToORM(context.Context, *BranchMergeORM) error
}

// BranchMergeAfterToORM called after default ToORM code
type BranchMergeWithAfterToORM interface {
	AfterToORM(context.Context, *BranchMergeORM) error
}

// BranchMergeBeforeToPB called before default ToPB code
type BranchMergeWithBeforeToPB interface {
	BeforeToPB(context.Context, *BranchMerge) error
}

// BranchMergeAfterToPB called after default ToPB code
type BranchMergeWithAfterToPB interface {
	AfterToPB(context.Context, *BranchMerge) error
}

type SignatureBlockORM struct {
	BlockType          string
	Height             float32
	Id                 uint64 `gorm:"primaryKey"`
	IsRequired         bool
	PageNumber         int32
	RequestId          uint64
	SignatureData      string
	SignatureRequestId *uint64
	SignedAt           *time.Time
	Width              float32
	XPosition          float32
	YPosition          float32
}

// TableName overrides the default tablename generated by GORM
func (SignatureBlockORM) TableName() string {
	return "signature_blocks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SignatureBlock) ToORM(ctx context.Context) (SignatureBlockORM, error) {
	to := SignatureBlockORM{}
	var err error
	if prehook, ok := interface{}(m).(SignatureBlockWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RequestId = m.RequestId
	to.BlockType = m.BlockType
	to.PageNumber = m.PageNumber
	to.XPosition = m.XPosition
	to.YPosition = m.YPosition
	to.Width = m.Width
	to.Height = m.Height
	to.IsRequired = m.IsRequired
	to.SignatureData = m.SignatureData
	if m.SignedAt != nil {
		t := m.SignedAt.AsTime()
		to.SignedAt = &t
	}
	if posthook, ok := interface{}(m).(SignatureBlockWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SignatureBlockORM) ToPB(ctx context.Context) (SignatureBlock, error) {
	to := SignatureBlock{}
	var err error
	if prehook, ok := interface{}(m).(SignatureBlockWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RequestId = m.RequestId
	to.BlockType = m.BlockType
	to.PageNumber = m.PageNumber
	to.XPosition = m.XPosition
	to.YPosition = m.YPosition
	to.Width = m.Width
	to.Height = m.Height
	to.IsRequired = m.IsRequired
	to.SignatureData = m.SignatureData
	if m.SignedAt != nil {
		to.SignedAt = timestamppb.New(*m.SignedAt)
	}
	if posthook, ok := interface{}(m).(SignatureBlockWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SignatureBlock the arg will be the target, the caller the one being converted from

// SignatureBlockBeforeToORM called before default ToORM code
type SignatureBlockWithBeforeToORM interface {
	BeforeToORM(context.Context, *SignatureBlockORM) error
}

// SignatureBlockAfterToORM called after default ToORM code
type SignatureBlockWithAfterToORM interface {
	AfterToORM(context.Context, *SignatureBlockORM) error
}

// SignatureBlockBeforeToPB called before default ToPB code
type SignatureBlockWithBeforeToPB interface {
	BeforeToPB(context.Context, *SignatureBlock) error
}

// SignatureBlockAfterToPB called after default ToPB code
type SignatureBlockWithAfterToPB interface {
	AfterToPB(context.Context, *SignatureBlock) error
}

type SignatureWorkflowORM struct {
	CreatedAt            *time.Time
	CurrentSigner        string
	Deadline             *time.Time
	Id                   uint64 `gorm:"primaryKey"`
	ParallelSigning      bool
	RequestId            uint64
	RequireAllSignatures bool
	SignatureRequestId   *uint64
	SigningOrder         pq.StringArray `gorm:"type:text[]"`
	UpdatedAt            *time.Time
	WorkflowStatus       string
}

// TableName overrides the default tablename generated by GORM
func (SignatureWorkflowORM) TableName() string {
	return "signature_workflows"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SignatureWorkflow) ToORM(ctx context.Context) (SignatureWorkflowORM, error) {
	to := SignatureWorkflowORM{}
	var err error
	if prehook, ok := interface{}(m).(SignatureWorkflowWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RequestId = m.RequestId
	if m.SigningOrder != nil {
		to.SigningOrder = make(pq.StringArray, len(m.SigningOrder))
		copy(to.SigningOrder, m.SigningOrder)
	}
	to.CurrentSigner = m.CurrentSigner
	to.WorkflowStatus = m.WorkflowStatus
	to.ParallelSigning = m.ParallelSigning
	to.RequireAllSignatures = m.RequireAllSignatures
	if m.Deadline != nil {
		t := m.Deadline.AsTime()
		to.Deadline = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(SignatureWorkflowWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SignatureWorkflowORM) ToPB(ctx context.Context) (SignatureWorkflow, error) {
	to := SignatureWorkflow{}
	var err error
	if prehook, ok := interface{}(m).(SignatureWorkflowWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RequestId = m.RequestId
	if m.SigningOrder != nil {
		to.SigningOrder = make(pq.StringArray, len(m.SigningOrder))
		copy(to.SigningOrder, m.SigningOrder)
	}
	to.CurrentSigner = m.CurrentSigner
	to.WorkflowStatus = m.WorkflowStatus
	to.ParallelSigning = m.ParallelSigning
	to.RequireAllSignatures = m.RequireAllSignatures
	if m.Deadline != nil {
		to.Deadline = timestamppb.New(*m.Deadline)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(SignatureWorkflowWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SignatureWorkflow the arg will be the target, the caller the one being converted from

// SignatureWorkflowBeforeToORM called before default ToORM code
type SignatureWorkflowWithBeforeToORM interface {
	BeforeToORM(context.Context, *SignatureWorkflowORM) error
}

// SignatureWorkflowAfterToORM called after default ToORM code
type SignatureWorkflowWithAfterToORM interface {
	AfterToORM(context.Context, *SignatureWorkflowORM) error
}

// SignatureWorkflowBeforeToPB called before default ToPB code
type SignatureWorkflowWithBeforeToPB interface {
	BeforeToPB(context.Context, *SignatureWorkflow) error
}

// SignatureWorkflowAfterToPB called after default ToPB code
type SignatureWorkflowWithAfterToPB interface {
	AfterToPB(context.Context, *SignatureWorkflow) error
}

type RiskAssessmentORM struct {
	AssessmentDetails      string
	AssessorId             string
	ContractIntelligenceId *uint64
	CreatedAt              *time.Time
	Id                     uint64 `gorm:"primaryKey"`
	IntelligenceId         uint64
	MitigationSuggestions  pq.StringArray `gorm:"type:text[]"`
	RiskScore              float32
	RiskType               string
}

// TableName overrides the default tablename generated by GORM
func (RiskAssessmentORM) TableName() string {
	return "risk_assessments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *RiskAssessment) ToORM(ctx context.Context) (RiskAssessmentORM, error) {
	to := RiskAssessmentORM{}
	var err error
	if prehook, ok := interface{}(m).(RiskAssessmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.IntelligenceId = m.IntelligenceId
	to.RiskType = m.RiskType
	to.RiskScore = m.RiskScore
	to.AssessmentDetails = m.AssessmentDetails
	if m.MitigationSuggestions != nil {
		to.MitigationSuggestions = make(pq.StringArray, len(m.MitigationSuggestions))
		copy(to.MitigationSuggestions, m.MitigationSuggestions)
	}
	to.AssessorId = m.AssessorId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(RiskAssessmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RiskAssessmentORM) ToPB(ctx context.Context) (RiskAssessment, error) {
	to := RiskAssessment{}
	var err error
	if prehook, ok := interface{}(m).(RiskAssessmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.IntelligenceId = m.IntelligenceId
	to.RiskType = m.RiskType
	to.RiskScore = m.RiskScore
	to.AssessmentDetails = m.AssessmentDetails
	if m.MitigationSuggestions != nil {
		to.MitigationSuggestions = make(pq.StringArray, len(m.MitigationSuggestions))
		copy(to.MitigationSuggestions, m.MitigationSuggestions)
	}
	to.AssessorId = m.AssessorId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(RiskAssessmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type RiskAssessment the arg will be the target, the caller the one being converted from

// RiskAssessmentBeforeToORM called before default ToORM code
type RiskAssessmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *RiskAssessmentORM) error
}

// RiskAssessmentAfterToORM called after default ToORM code
type RiskAssessmentWithAfterToORM interface {
	AfterToORM(context.Context, *RiskAssessmentORM) error
}

// RiskAssessmentBeforeToPB called before default ToPB code
type RiskAssessmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *RiskAssessment) error
}

// RiskAssessmentAfterToPB called after default ToPB code
type RiskAssessmentWithAfterToPB interface {
	AfterToPB(context.Context, *RiskAssessment) error
}

type ComplianceCheckORM struct {
	CheckDate              *time.Time
	CheckResult            string
	ComplianceStandard     string
	ContractIntelligenceId *uint64
	Id                     uint64 `gorm:"primaryKey"`
	IntelligenceId         uint64
	RemediationSteps       string
	Violations             pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (ComplianceCheckORM) TableName() string {
	return "compliance_checks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ComplianceCheck) ToORM(ctx context.Context) (ComplianceCheckORM, error) {
	to := ComplianceCheckORM{}
	var err error
	if prehook, ok := interface{}(m).(ComplianceCheckWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.IntelligenceId = m.IntelligenceId
	to.ComplianceStandard = m.ComplianceStandard
	to.CheckResult = m.CheckResult
	if m.Violations != nil {
		to.Violations = make(pq.StringArray, len(m.Violations))
		copy(to.Violations, m.Violations)
	}
	to.RemediationSteps = m.RemediationSteps
	if m.CheckDate != nil {
		t := m.CheckDate.AsTime()
		to.CheckDate = &t
	}
	if posthook, ok := interface{}(m).(ComplianceCheckWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ComplianceCheckORM) ToPB(ctx context.Context) (ComplianceCheck, error) {
	to := ComplianceCheck{}
	var err error
	if prehook, ok := interface{}(m).(ComplianceCheckWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.IntelligenceId = m.IntelligenceId
	to.ComplianceStandard = m.ComplianceStandard
	to.CheckResult = m.CheckResult
	if m.Violations != nil {
		to.Violations = make(pq.StringArray, len(m.Violations))
		copy(to.Violations, m.Violations)
	}
	to.RemediationSteps = m.RemediationSteps
	if m.CheckDate != nil {
		to.CheckDate = timestamppb.New(*m.CheckDate)
	}
	if posthook, ok := interface{}(m).(ComplianceCheckWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ComplianceCheck the arg will be the target, the caller the one being converted from

// ComplianceCheckBeforeToORM called before default ToORM code
type ComplianceCheckWithBeforeToORM interface {
	BeforeToORM(context.Context, *ComplianceCheckORM) error
}

// ComplianceCheckAfterToORM called after default ToORM code
type ComplianceCheckWithAfterToORM interface {
	AfterToORM(context.Context, *ComplianceCheckORM) error
}

// ComplianceCheckBeforeToPB called before default ToPB code
type ComplianceCheckWithBeforeToPB interface {
	BeforeToPB(context.Context, *ComplianceCheck) error
}

// ComplianceCheckAfterToPB called after default ToPB code
type ComplianceCheckWithAfterToPB interface {
	AfterToPB(context.Context, *ComplianceCheck) error
}

type AppVersionORM struct {
	AppId            uint64
	Changelog        string
	Id               uint64 `gorm:"primaryKey"`
	IsPublic         bool
	MarketplaceAppId *uint64
	ReleaseDate      *time.Time
	VersionNumber    string
}

// TableName overrides the default tablename generated by GORM
func (AppVersionORM) TableName() string {
	return "app_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppVersion) ToORM(ctx context.Context) (AppVersionORM, error) {
	to := AppVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(AppVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.VersionNumber = m.VersionNumber
	to.Changelog = m.Changelog
	// Repeated type RequirementsEntry is not an ORMable message type
	to.IsPublic = m.IsPublic
	if m.ReleaseDate != nil {
		t := m.ReleaseDate.AsTime()
		to.ReleaseDate = &t
	}
	if posthook, ok := interface{}(m).(AppVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppVersionORM) ToPB(ctx context.Context) (AppVersion, error) {
	to := AppVersion{}
	var err error
	if prehook, ok := interface{}(m).(AppVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.VersionNumber = m.VersionNumber
	to.Changelog = m.Changelog
	// Repeated type RequirementsEntry is not an ORMable message type
	to.IsPublic = m.IsPublic
	if m.ReleaseDate != nil {
		to.ReleaseDate = timestamppb.New(*m.ReleaseDate)
	}
	if posthook, ok := interface{}(m).(AppVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppVersion the arg will be the target, the caller the one being converted from

// AppVersionBeforeToORM called before default ToORM code
type AppVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppVersionORM) error
}

// AppVersionAfterToORM called after default ToORM code
type AppVersionWithAfterToORM interface {
	AfterToORM(context.Context, *AppVersionORM) error
}

// AppVersionBeforeToPB called before default ToPB code
type AppVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppVersion) error
}

// AppVersionAfterToPB called after default ToPB code
type AppVersionWithAfterToPB interface {
	AfterToPB(context.Context, *AppVersion) error
}

type AppInstallationORM struct {
	AppId              uint64
	Id                 uint64 `gorm:"primaryKey"`
	InstallationStatus string
	InstalledAt        *time.Time
	LastUsed           *time.Time
	MarketplaceAppId   *uint64
	VersionInstalled   string
	WorkspaceId        uint64
}

// TableName overrides the default tablename generated by GORM
func (AppInstallationORM) TableName() string {
	return "app_installations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppInstallation) ToORM(ctx context.Context) (AppInstallationORM, error) {
	to := AppInstallationORM{}
	var err error
	if prehook, ok := interface{}(m).(AppInstallationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.WorkspaceId = m.WorkspaceId
	to.VersionInstalled = m.VersionInstalled
	// Repeated type ConfigurationEntry is not an ORMable message type
	to.InstallationStatus = m.InstallationStatus
	if m.InstalledAt != nil {
		t := m.InstalledAt.AsTime()
		to.InstalledAt = &t
	}
	if m.LastUsed != nil {
		t := m.LastUsed.AsTime()
		to.LastUsed = &t
	}
	if posthook, ok := interface{}(m).(AppInstallationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppInstallationORM) ToPB(ctx context.Context) (AppInstallation, error) {
	to := AppInstallation{}
	var err error
	if prehook, ok := interface{}(m).(AppInstallationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.WorkspaceId = m.WorkspaceId
	to.VersionInstalled = m.VersionInstalled
	// Repeated type ConfigurationEntry is not an ORMable message type
	to.InstallationStatus = m.InstallationStatus
	if m.InstalledAt != nil {
		to.InstalledAt = timestamppb.New(*m.InstalledAt)
	}
	if m.LastUsed != nil {
		to.LastUsed = timestamppb.New(*m.LastUsed)
	}
	if posthook, ok := interface{}(m).(AppInstallationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppInstallation the arg will be the target, the caller the one being converted from

// AppInstallationBeforeToORM called before default ToORM code
type AppInstallationWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppInstallationORM) error
}

// AppInstallationAfterToORM called after default ToORM code
type AppInstallationWithAfterToORM interface {
	AfterToORM(context.Context, *AppInstallationORM) error
}

// AppInstallationBeforeToPB called before default ToPB code
type AppInstallationWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppInstallation) error
}

// AppInstallationAfterToPB called after default ToPB code
type AppInstallationWithAfterToPB interface {
	AfterToPB(context.Context, *AppInstallation) error
}

type AppAnalyticsORM struct {
	AppId            uint64
	Id               uint64 `gorm:"primaryKey"`
	MarketplaceAppId *uint64
	MetricName       string
	MetricValue      float32
	RecordedAt       *time.Time
}

// TableName overrides the default tablename generated by GORM
func (AppAnalyticsORM) TableName() string {
	return "app_analytics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppAnalytics) ToORM(ctx context.Context) (AppAnalyticsORM, error) {
	to := AppAnalyticsORM{}
	var err error
	if prehook, ok := interface{}(m).(AppAnalyticsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.MetricName = m.MetricName
	to.MetricValue = m.MetricValue
	// Repeated type DimensionsEntry is not an ORMable message type
	if m.RecordedAt != nil {
		t := m.RecordedAt.AsTime()
		to.RecordedAt = &t
	}
	if posthook, ok := interface{}(m).(AppAnalyticsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppAnalyticsORM) ToPB(ctx context.Context) (AppAnalytics, error) {
	to := AppAnalytics{}
	var err error
	if prehook, ok := interface{}(m).(AppAnalyticsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.MetricName = m.MetricName
	to.MetricValue = m.MetricValue
	// Repeated type DimensionsEntry is not an ORMable message type
	if m.RecordedAt != nil {
		to.RecordedAt = timestamppb.New(*m.RecordedAt)
	}
	if posthook, ok := interface{}(m).(AppAnalyticsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppAnalytics the arg will be the target, the caller the one being converted from

// AppAnalyticsBeforeToORM called before default ToORM code
type AppAnalyticsWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppAnalyticsORM) error
}

// AppAnalyticsAfterToORM called after default ToORM code
type AppAnalyticsWithAfterToORM interface {
	AfterToORM(context.Context, *AppAnalyticsORM) error
}

// AppAnalyticsBeforeToPB called before default ToPB code
type AppAnalyticsWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppAnalytics) error
}

// AppAnalyticsAfterToPB called after default ToPB code
type AppAnalyticsWithAfterToPB interface {
	AfterToPB(context.Context, *AppAnalytics) error
}

type AppReviewORM struct {
	AppId            uint64
	CreatedAt        *time.Time
	Id               uint64 `gorm:"primaryKey"`
	MarketplaceAppId *uint64
	Rating           float32
	ReviewText       string
	ReviewerId       string
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (AppReviewORM) TableName() string {
	return "app_reviews"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppReview) ToORM(ctx context.Context) (AppReviewORM, error) {
	to := AppReviewORM{}
	var err error
	if prehook, ok := interface{}(m).(AppReviewWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.ReviewerId = m.ReviewerId
	to.Rating = m.Rating
	to.ReviewText = m.ReviewText
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(AppReviewWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppReviewORM) ToPB(ctx context.Context) (AppReview, error) {
	to := AppReview{}
	var err error
	if prehook, ok := interface{}(m).(AppReviewWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.ReviewerId = m.ReviewerId
	to.Rating = m.Rating
	to.ReviewText = m.ReviewText
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AppReviewWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppReview the arg will be the target, the caller the one being converted from

// AppReviewBeforeToORM called before default ToORM code
type AppReviewWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppReviewORM) error
}

// AppReviewAfterToORM called after default ToORM code
type AppReviewWithAfterToORM interface {
	AfterToORM(context.Context, *AppReviewORM) error
}

// AppReviewBeforeToPB called before default ToPB code
type AppReviewWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppReview) error
}

// AppReviewAfterToPB called after default ToPB code
type AppReviewWithAfterToPB interface {
	AfterToPB(context.Context, *AppReview) error
}

type AppDevelopmentInfoORM struct {
	AppId              uint64
	CreatedAt          *time.Time
	DevelopmentStatus  string
	Id                 uint64         `gorm:"primaryKey"`
	KnownIssues        pq.StringArray `gorm:"type:text[]"`
	LastSecurityAudit  *time.Time
	MarketplaceAppId   *uint64
	RoadmapUrl         string
	SdkFeatures        pq.StringArray `gorm:"type:text[]"`
	SecurityScans      pq.StringArray `gorm:"type:text[]"`
	SupportedLanguages pq.StringArray `gorm:"type:text[]"`
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (AppDevelopmentInfoORM) TableName() string {
	return "app_development_info"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppDevelopmentInfo) ToORM(ctx context.Context) (AppDevelopmentInfoORM, error) {
	to := AppDevelopmentInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(AppDevelopmentInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	if m.SupportedLanguages != nil {
		to.SupportedLanguages = make(pq.StringArray, len(m.SupportedLanguages))
		copy(to.SupportedLanguages, m.SupportedLanguages)
	}
	if m.SdkFeatures != nil {
		to.SdkFeatures = make(pq.StringArray, len(m.SdkFeatures))
		copy(to.SdkFeatures, m.SdkFeatures)
	}
	// Repeated type TestCoverageEntry is not an ORMable message type
	if m.SecurityScans != nil {
		to.SecurityScans = make(pq.StringArray, len(m.SecurityScans))
		copy(to.SecurityScans, m.SecurityScans)
	}
	// Repeated type PerformanceMetricsEntry is not an ORMable message type
	to.DevelopmentStatus = m.DevelopmentStatus
	if m.KnownIssues != nil {
		to.KnownIssues = make(pq.StringArray, len(m.KnownIssues))
		copy(to.KnownIssues, m.KnownIssues)
	}
	to.RoadmapUrl = m.RoadmapUrl
	if m.LastSecurityAudit != nil {
		t := m.LastSecurityAudit.AsTime()
		to.LastSecurityAudit = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(AppDevelopmentInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppDevelopmentInfoORM) ToPB(ctx context.Context) (AppDevelopmentInfo, error) {
	to := AppDevelopmentInfo{}
	var err error
	if prehook, ok := interface{}(m).(AppDevelopmentInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	if m.SupportedLanguages != nil {
		to.SupportedLanguages = make(pq.StringArray, len(m.SupportedLanguages))
		copy(to.SupportedLanguages, m.SupportedLanguages)
	}
	if m.SdkFeatures != nil {
		to.SdkFeatures = make(pq.StringArray, len(m.SdkFeatures))
		copy(to.SdkFeatures, m.SdkFeatures)
	}
	// Repeated type TestCoverageEntry is not an ORMable message type
	if m.SecurityScans != nil {
		to.SecurityScans = make(pq.StringArray, len(m.SecurityScans))
		copy(to.SecurityScans, m.SecurityScans)
	}
	// Repeated type PerformanceMetricsEntry is not an ORMable message type
	to.DevelopmentStatus = m.DevelopmentStatus
	if m.KnownIssues != nil {
		to.KnownIssues = make(pq.StringArray, len(m.KnownIssues))
		copy(to.KnownIssues, m.KnownIssues)
	}
	to.RoadmapUrl = m.RoadmapUrl
	if m.LastSecurityAudit != nil {
		to.LastSecurityAudit = timestamppb.New(*m.LastSecurityAudit)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AppDevelopmentInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppDevelopmentInfo the arg will be the target, the caller the one being converted from

// AppDevelopmentInfoBeforeToORM called before default ToORM code
type AppDevelopmentInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppDevelopmentInfoORM) error
}

// AppDevelopmentInfoAfterToORM called after default ToORM code
type AppDevelopmentInfoWithAfterToORM interface {
	AfterToORM(context.Context, *AppDevelopmentInfoORM) error
}

// AppDevelopmentInfoBeforeToPB called before default ToPB code
type AppDevelopmentInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppDevelopmentInfo) error
}

// AppDevelopmentInfoAfterToPB called after default ToPB code
type AppDevelopmentInfoWithAfterToPB interface {
	AfterToPB(context.Context, *AppDevelopmentInfo) error
}

type AppWebhookORM struct {
	AppId            uint64
	CreatedAt        *time.Time
	Id               uint64 `gorm:"primaryKey"`
	IsActive         bool
	LastTriggered    *time.Time
	MarketplaceAppId *uint64
	RetryCount       int32
	SecretKey        string
	SubscribedEvents pq.StringArray `gorm:"type:text[]"`
	TimeoutSeconds   int32
	Url              string
}

// TableName overrides the default tablename generated by GORM
func (AppWebhookORM) TableName() string {
	return "app_webhooks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppWebhook) ToORM(ctx context.Context) (AppWebhookORM, error) {
	to := AppWebhookORM{}
	var err error
	if prehook, ok := interface{}(m).(AppWebhookWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.Url = m.Url
	if m.SubscribedEvents != nil {
		to.SubscribedEvents = make(pq.StringArray, len(m.SubscribedEvents))
		copy(to.SubscribedEvents, m.SubscribedEvents)
	}
	to.SecretKey = m.SecretKey
	to.RetryCount = m.RetryCount
	to.TimeoutSeconds = m.TimeoutSeconds
	to.IsActive = m.IsActive
	// Repeated type HeadersEntry is not an ORMable message type
	if m.LastTriggered != nil {
		t := m.LastTriggered.AsTime()
		to.LastTriggered = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(AppWebhookWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppWebhookORM) ToPB(ctx context.Context) (AppWebhook, error) {
	to := AppWebhook{}
	var err error
	if prehook, ok := interface{}(m).(AppWebhookWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.Url = m.Url
	if m.SubscribedEvents != nil {
		to.SubscribedEvents = make(pq.StringArray, len(m.SubscribedEvents))
		copy(to.SubscribedEvents, m.SubscribedEvents)
	}
	to.SecretKey = m.SecretKey
	to.RetryCount = m.RetryCount
	to.TimeoutSeconds = m.TimeoutSeconds
	to.IsActive = m.IsActive
	// Repeated type HeadersEntry is not an ORMable message type
	if m.LastTriggered != nil {
		to.LastTriggered = timestamppb.New(*m.LastTriggered)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(AppWebhookWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppWebhook the arg will be the target, the caller the one being converted from

// AppWebhookBeforeToORM called before default ToORM code
type AppWebhookWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppWebhookORM) error
}

// AppWebhookAfterToORM called after default ToORM code
type AppWebhookWithAfterToORM interface {
	AfterToORM(context.Context, *AppWebhookORM) error
}

// AppWebhookBeforeToPB called before default ToPB code
type AppWebhookWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppWebhook) error
}

// AppWebhookAfterToPB called after default ToPB code
type AppWebhookWithAfterToPB interface {
	AfterToPB(context.Context, *AppWebhook) error
}

type AppPermissionORM struct {
	AccessLevels     pq.StringArray `gorm:"type:text[]"`
	AppId            uint64
	CreatedAt        *time.Time
	Description      string
	Id               uint64 `gorm:"primaryKey"`
	IsRequired       bool
	MarketplaceAppId *uint64
	RequiresApproval bool
	Scope            string
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (AppPermissionORM) TableName() string {
	return "app_permissions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppPermission) ToORM(ctx context.Context) (AppPermissionORM, error) {
	to := AppPermissionORM{}
	var err error
	if prehook, ok := interface{}(m).(AppPermissionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.Scope = m.Scope
	to.Description = m.Description
	to.IsRequired = m.IsRequired
	if m.AccessLevels != nil {
		to.AccessLevels = make(pq.StringArray, len(m.AccessLevels))
		copy(to.AccessLevels, m.AccessLevels)
	}
	// Repeated type ConstraintsEntry is not an ORMable message type
	to.RequiresApproval = m.RequiresApproval
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(AppPermissionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppPermissionORM) ToPB(ctx context.Context) (AppPermission, error) {
	to := AppPermission{}
	var err error
	if prehook, ok := interface{}(m).(AppPermissionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppId = m.AppId
	to.Scope = m.Scope
	to.Description = m.Description
	to.IsRequired = m.IsRequired
	if m.AccessLevels != nil {
		to.AccessLevels = make(pq.StringArray, len(m.AccessLevels))
		copy(to.AccessLevels, m.AccessLevels)
	}
	// Repeated type ConstraintsEntry is not an ORMable message type
	to.RequiresApproval = m.RequiresApproval
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AppPermissionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppPermission the arg will be the target, the caller the one being converted from

// AppPermissionBeforeToORM called before default ToORM code
type AppPermissionWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppPermissionORM) error
}

// AppPermissionAfterToORM called after default ToORM code
type AppPermissionWithAfterToORM interface {
	AfterToORM(context.Context, *AppPermissionORM) error
}

// AppPermissionBeforeToPB called before default ToPB code
type AppPermissionWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppPermission) error
}

// AppPermissionAfterToPB called after default ToPB code
type AppPermissionWithAfterToPB interface {
	AfterToPB(context.Context, *AppPermission) error
}

type BranchPolicyORM struct {
	AllowForcePush       bool
	AutomatedChecks      pq.StringArray `gorm:"type:text[]"`
	BranchId             uint64
	CreatedAt            *time.Time
	DocumentBranchId     *uint64
	EnforceLinearHistory bool
	Id                   uint64 `gorm:"primaryKey"`
	MinimumApprovals     int32
	ProtectedPaths       pq.StringArray `gorm:"type:text[]"`
	RequiredApprovers    pq.StringArray `gorm:"type:text[]"`
	UpdatedAt            *time.Time
}

// TableName overrides the default tablename generated by GORM
func (BranchPolicyORM) TableName() string {
	return "branch_policies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BranchPolicy) ToORM(ctx context.Context) (BranchPolicyORM, error) {
	to := BranchPolicyORM{}
	var err error
	if prehook, ok := interface{}(m).(BranchPolicyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BranchId = m.BranchId
	if m.RequiredApprovers != nil {
		to.RequiredApprovers = make(pq.StringArray, len(m.RequiredApprovers))
		copy(to.RequiredApprovers, m.RequiredApprovers)
	}
	to.MinimumApprovals = m.MinimumApprovals
	to.EnforceLinearHistory = m.EnforceLinearHistory
	to.AllowForcePush = m.AllowForcePush
	if m.ProtectedPaths != nil {
		to.ProtectedPaths = make(pq.StringArray, len(m.ProtectedPaths))
		copy(to.ProtectedPaths, m.ProtectedPaths)
	}
	// Repeated type MergeRulesEntry is not an ORMable message type
	if m.AutomatedChecks != nil {
		to.AutomatedChecks = make(pq.StringArray, len(m.AutomatedChecks))
		copy(to.AutomatedChecks, m.AutomatedChecks)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(BranchPolicyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BranchPolicyORM) ToPB(ctx context.Context) (BranchPolicy, error) {
	to := BranchPolicy{}
	var err error
	if prehook, ok := interface{}(m).(BranchPolicyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BranchId = m.BranchId
	if m.RequiredApprovers != nil {
		to.RequiredApprovers = make(pq.StringArray, len(m.RequiredApprovers))
		copy(to.RequiredApprovers, m.RequiredApprovers)
	}
	to.MinimumApprovals = m.MinimumApprovals
	to.EnforceLinearHistory = m.EnforceLinearHistory
	to.AllowForcePush = m.AllowForcePush
	if m.ProtectedPaths != nil {
		to.ProtectedPaths = make(pq.StringArray, len(m.ProtectedPaths))
		copy(to.ProtectedPaths, m.ProtectedPaths)
	}
	// Repeated type MergeRulesEntry is not an ORMable message type
	if m.AutomatedChecks != nil {
		to.AutomatedChecks = make(pq.StringArray, len(m.AutomatedChecks))
		copy(to.AutomatedChecks, m.AutomatedChecks)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(BranchPolicyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BranchPolicy the arg will be the target, the caller the one being converted from

// BranchPolicyBeforeToORM called before default ToORM code
type BranchPolicyWithBeforeToORM interface {
	BeforeToORM(context.Context, *BranchPolicyORM) error
}

// BranchPolicyAfterToORM called after default ToORM code
type BranchPolicyWithAfterToORM interface {
	AfterToORM(context.Context, *BranchPolicyORM) error
}

// BranchPolicyBeforeToPB called before default ToPB code
type BranchPolicyWithBeforeToPB interface {
	BeforeToPB(context.Context, *BranchPolicy) error
}

// BranchPolicyAfterToPB called after default ToPB code
type BranchPolicyWithAfterToPB interface {
	AfterToPB(context.Context, *BranchPolicy) error
}

type MergeRequestORM struct {
	AuthorId              string
	AutomatedCheckResults pq.StringArray `gorm:"type:text[]"`
	CreatedAt             *time.Time
	Description           string
	DocumentBranchId      *uint64
	HasConflicts          bool
	Id                    uint64         `gorm:"primaryKey"`
	Labels                pq.StringArray `gorm:"type:text[]"`
	Reviewers             pq.StringArray `gorm:"type:text[]"`
	SourceBranchId        uint64
	Status                string
	TargetBranchId        uint64
	Title                 string
	UpdatedAt             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (MergeRequestORM) TableName() string {
	return "merge_requests"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MergeRequest) ToORM(ctx context.Context) (MergeRequestORM, error) {
	to := MergeRequestORM{}
	var err error
	if prehook, ok := interface{}(m).(MergeRequestWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SourceBranchId = m.SourceBranchId
	to.TargetBranchId = m.TargetBranchId
	to.Title = m.Title
	to.Description = m.Description
	to.AuthorId = m.AuthorId
	if m.Reviewers != nil {
		to.Reviewers = make(pq.StringArray, len(m.Reviewers))
		copy(to.Reviewers, m.Reviewers)
	}
	to.Status = m.Status
	if m.Labels != nil {
		to.Labels = make(pq.StringArray, len(m.Labels))
		copy(to.Labels, m.Labels)
	}
	to.HasConflicts = m.HasConflicts
	if m.AutomatedCheckResults != nil {
		to.AutomatedCheckResults = make(pq.StringArray, len(m.AutomatedCheckResults))
		copy(to.AutomatedCheckResults, m.AutomatedCheckResults)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MergeRequestWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MergeRequestORM) ToPB(ctx context.Context) (MergeRequest, error) {
	to := MergeRequest{}
	var err error
	if prehook, ok := interface{}(m).(MergeRequestWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SourceBranchId = m.SourceBranchId
	to.TargetBranchId = m.TargetBranchId
	to.Title = m.Title
	to.Description = m.Description
	to.AuthorId = m.AuthorId
	if m.Reviewers != nil {
		to.Reviewers = make(pq.StringArray, len(m.Reviewers))
		copy(to.Reviewers, m.Reviewers)
	}
	to.Status = m.Status
	if m.Labels != nil {
		to.Labels = make(pq.StringArray, len(m.Labels))
		copy(to.Labels, m.Labels)
	}
	to.HasConflicts = m.HasConflicts
	if m.AutomatedCheckResults != nil {
		to.AutomatedCheckResults = make(pq.StringArray, len(m.AutomatedCheckResults))
		copy(to.AutomatedCheckResults, m.AutomatedCheckResults)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(MergeRequestWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MergeRequest the arg will be the target, the caller the one being converted from

// MergeRequestBeforeToORM called before default ToORM code
type MergeRequestWithBeforeToORM interface {
	BeforeToORM(context.Context, *MergeRequestORM) error
}

// MergeRequestAfterToORM called after default ToORM code
type MergeRequestWithAfterToORM interface {
	AfterToORM(context.Context, *MergeRequestORM) error
}

// MergeRequestBeforeToPB called before default ToPB code
type MergeRequestWithBeforeToPB interface {
	BeforeToPB(context.Context, *MergeRequest) error
}

// MergeRequestAfterToPB called after default ToPB code
type MergeRequestWithAfterToPB interface {
	AfterToPB(context.Context, *MergeRequest) error
}

// DefaultCreateAccount executes a basic gorm create call
func DefaultCreateAccount(ctx context.Context, in *Account, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccount(ctx context.Context, in *Account, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccount(ctx context.Context, in *Account, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountSet(ctx context.Context, in []*Account, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountORM{})).(AccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountORM{})).(AccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Account, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Account, *gorm.DB) error
}

// DefaultStrictUpdateAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccount(ctx context.Context, in *Account, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDataProfiles := DataProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDataProfiles.AccountId = new(uint64)
	*filterDataProfiles.AccountId = ormObj.Id
	if err = db.Where(filterDataProfiles).Delete(DataProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkspaces := WorkspaceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterWorkspaces.AccountId = new(uint64)
	*filterWorkspaces.AccountId = ormObj.Id
	if err = db.Where(filterWorkspaces).Delete(WorkspaceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccount executes a basic gorm update call with patch behavior
func DefaultPatchAccount(ctx context.Context, in *Account, updateMask *field_mask.FieldMask, db *gorm.DB) (*Account, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Account
	var err error
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccount(ctx, &Account{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Account, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccount(ctx context.Context, objects []*Account, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Account, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Account, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccount(ctx context.Context, patchee *Account, patcher *Account, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Account, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Auth0UserId" {
			patchee.Auth0UserId = patcher.Auth0UserId
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"BaseDirectory" {
			patchee.BaseDirectory = patcher.BaseDirectory
			continue
		}
		if f == prefix+"BucketName" {
			patchee.BucketName = patcher.BucketName
			continue
		}
		if f == prefix+"Region" {
			patchee.Region = patcher.Region
			continue
		}
		if f == prefix+"OrgId" {
			patchee.OrgId = patcher.OrgId
			continue
		}
		if f == prefix+"TenantId" {
			patchee.TenantId = patcher.TenantId
			continue
		}
		if f == prefix+"Roles" {
			patchee.Roles = patcher.Roles
			continue
		}
		if f == prefix+"Permissions" {
			patchee.Permissions = patcher.Permissions
			continue
		}
		if f == prefix+"MfaEnabled" {
			patchee.MfaEnabled = patcher.MfaEnabled
			continue
		}
		if f == prefix+"ComplianceLevel" {
			patchee.ComplianceLevel = patcher.ComplianceLevel
			continue
		}
		if f == prefix+"Preferences" {
			patchee.Preferences = patcher.Preferences
			continue
		}
		if f == prefix+"ApiKeys" {
			patchee.ApiKeys = patcher.ApiKeys
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Workspaces" {
			patchee.Workspaces = patcher.Workspaces
			continue
		}
		if f == prefix+"DataProfiles" {
			patchee.DataProfiles = patcher.DataProfiles
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccount executes a gorm list call
func DefaultListAccount(ctx context.Context, db *gorm.DB) ([]*Account, error) {
	in := Account{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Account{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountORM) error
}

// DefaultCreateDataProfile executes a basic gorm create call
func DefaultCreateDataProfile(ctx context.Context, in *DataProfile, db *gorm.DB) (*DataProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DataProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDataProfile(ctx context.Context, in *DataProfile, db *gorm.DB) (*DataProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DataProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DataProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DataProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDataProfile(ctx context.Context, in *DataProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DataProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DataProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDataProfileSet(ctx context.Context, in []*DataProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DataProfileORM{})).(DataProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DataProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DataProfileORM{})).(DataProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DataProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DataProfile, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DataProfile, *gorm.DB) error
}

// DefaultStrictUpdateDataProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDataProfile(ctx context.Context, in *DataProfile, db *gorm.DB) (*DataProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDataProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DataProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DataProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDataProfile executes a basic gorm update call with patch behavior
func DefaultPatchDataProfile(ctx context.Context, in *DataProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*DataProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DataProfile
	var err error
	if hook, ok := interface{}(&pbObj).(DataProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDataProfile(ctx, &DataProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DataProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDataProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DataProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDataProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DataProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DataProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DataProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DataProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DataProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DataProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DataProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DataProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DataProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDataProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetDataProfile(ctx context.Context, objects []*DataProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DataProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DataProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDataProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDataProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDataProfile(ctx context.Context, patchee *DataProfile, patcher *DataProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DataProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ProfileType" {
			patchee.ProfileType = patcher.ProfileType
			continue
		}
		if f == prefix+"DataFields" {
			patchee.DataFields = patcher.DataFields
			continue
		}
		if f == prefix+"IsDefault" {
			patchee.IsDefault = patcher.IsDefault
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDataProfile executes a gorm list call
func DefaultListDataProfile(ctx context.Context, db *gorm.DB) ([]*DataProfile, error) {
	in := DataProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DataProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DataProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DataProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DataProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DataProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DataProfileORM) error
}

// DefaultCreateWorkspace executes a basic gorm create call
func DefaultCreateWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkspaceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkspaceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkspaceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkspaceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceSet(ctx context.Context, in []*Workspace, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&WorkspaceORM{})).(WorkspaceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&WorkspaceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkspaceORM{})).(WorkspaceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkspaceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Workspace, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Workspace, *gorm.DB) error
}

// DefaultStrictUpdateWorkspace clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkspace(ctx context.Context, in *Workspace, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkspace")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkspaceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterActivities := WorkspaceActivityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterActivities.WorkspaceId = new(uint64)
	*filterActivities.WorkspaceId = ormObj.Id
	if err = db.Where(filterActivities).Delete(WorkspaceActivityORM{}).Error; err != nil {
		return nil, err
	}
	filterCompliance := WorkspaceComplianceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompliance.WorkspaceId = new(uint64)
	*filterCompliance.WorkspaceId = ormObj.Id
	if err = db.Where(filterCompliance).Delete(WorkspaceComplianceORM{}).Error; err != nil {
		return nil, err
	}
	filterFolders := FolderMetadataORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFolders.WorkspaceId = new(uint64)
	*filterFolders.WorkspaceId = ormObj.Id
	if err = db.Where(filterFolders).Delete(FolderMetadataORM{}).Error; err != nil {
		return nil, err
	}
	filterInstalledApps := MarketplaceAppORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInstalledApps.WorkspaceId = new(uint64)
	*filterInstalledApps.WorkspaceId = ormObj.Id
	if err = db.Where(filterInstalledApps).Delete(MarketplaceAppORM{}).Error; err != nil {
		return nil, err
	}
	filterSharing := WorkspaceSharingORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSharing.WorkspaceId = new(uint64)
	*filterSharing.WorkspaceId = ormObj.Id
	if err = db.Where(filterSharing).Delete(WorkspaceSharingORM{}).Error; err != nil {
		return nil, err
	}
	filterTemplates := DocumentTemplateORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTemplates.WorkspaceId = new(uint64)
	*filterTemplates.WorkspaceId = ormObj.Id
	if err = db.Where(filterTemplates).Delete(DocumentTemplateORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkspaceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkspace executes a basic gorm update call with patch behavior
func DefaultPatchWorkspace(ctx context.Context, in *Workspace, updateMask *field_mask.FieldMask, db *gorm.DB) (*Workspace, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Workspace
	var err error
	if hook, ok := interface{}(&pbObj).(WorkspaceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadWorkspace(ctx, &Workspace{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(WorkspaceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkspace(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkspaceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkspace(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkspaceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkspaceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Workspace, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkspace executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkspace(ctx context.Context, objects []*Workspace, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Workspace, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Workspace, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkspace(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkspace patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkspace(ctx context.Context, patchee *Workspace, patcher *Workspace, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Workspace, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"UniqueIdentifier" {
			patchee.UniqueIdentifier = patcher.UniqueIdentifier
			continue
		}
		if f == prefix+"S3BucketName" {
			patchee.S3BucketName = patcher.S3BucketName
			continue
		}
		if f == prefix+"S3FolderPath" {
			patchee.S3FolderPath = patcher.S3FolderPath
			continue
		}
		if f == prefix+"StorageQuota" {
			patchee.StorageQuota = patcher.StorageQuota
			continue
		}
		if f == prefix+"UsedStorage" {
			patchee.UsedStorage = patcher.UsedStorage
			continue
		}
		if f == prefix+"AllowPublicSharing" {
			patchee.AllowPublicSharing = patcher.AllowPublicSharing
			continue
		}
		if f == prefix+"RequireApproval" {
			patchee.RequireApproval = patcher.RequireApproval
			continue
		}
		if f == prefix+"GdprCompliant" {
			patchee.GdprCompliant = patcher.GdprCompliant
			continue
		}
		if f == prefix+"HipaaCompliant" {
			patchee.HipaaCompliant = patcher.HipaaCompliant
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Folders" {
			patchee.Folders = patcher.Folders
			continue
		}
		if f == prefix+"Templates" {
			patchee.Templates = patcher.Templates
			continue
		}
		if f == prefix+"Sharing" {
			patchee.Sharing = patcher.Sharing
			continue
		}
		if f == prefix+"Activities" {
			patchee.Activities = patcher.Activities
			continue
		}
		if f == prefix+"Compliance" {
			patchee.Compliance = patcher.Compliance
			continue
		}
		if f == prefix+"InstalledApps" {
			patchee.InstalledApps = patcher.InstalledApps
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkspace executes a gorm list call
func DefaultListWorkspace(ctx context.Context, db *gorm.DB) ([]*Workspace, error) {
	in := Workspace{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []WorkspaceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Workspace{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkspaceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkspaceORM) error
}

// DefaultCreateWorkspaceSharing executes a basic gorm create call
func DefaultCreateWorkspaceSharing(ctx context.Context, in *WorkspaceSharing, db *gorm.DB) (*WorkspaceSharing, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceSharingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkspaceSharing(ctx context.Context, in *WorkspaceSharing, db *gorm.DB) (*WorkspaceSharing, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkspaceSharingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkspaceSharingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceSharingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceSharing(ctx context.Context, in *WorkspaceSharing, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkspaceSharingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkspaceSharingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceSharingSet(ctx context.Context, in []*WorkspaceSharing, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&WorkspaceSharingORM{})).(WorkspaceSharingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&WorkspaceSharingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkspaceSharingORM{})).(WorkspaceSharingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkspaceSharingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*WorkspaceSharing, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*WorkspaceSharing, *gorm.DB) error
}

// DefaultStrictUpdateWorkspaceSharing clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkspaceSharing(ctx context.Context, in *WorkspaceSharing, db *gorm.DB) (*WorkspaceSharing, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkspaceSharing")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkspaceSharingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkspaceSharingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkspaceSharing executes a basic gorm update call with patch behavior
func DefaultPatchWorkspaceSharing(ctx context.Context, in *WorkspaceSharing, updateMask *field_mask.FieldMask, db *gorm.DB) (*WorkspaceSharing, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj WorkspaceSharing
	var err error
	if hook, ok := interface{}(&pbObj).(WorkspaceSharingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadWorkspaceSharing(ctx, &WorkspaceSharing{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(WorkspaceSharingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkspaceSharing(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkspaceSharingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkspaceSharing(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkspaceSharingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkspaceSharingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *WorkspaceSharing, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *WorkspaceSharing, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *WorkspaceSharing, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *WorkspaceSharing, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkspaceSharing executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkspaceSharing(ctx context.Context, objects []*WorkspaceSharing, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*WorkspaceSharing, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*WorkspaceSharing, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkspaceSharing(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkspaceSharing patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkspaceSharing(ctx context.Context, patchee *WorkspaceSharing, patcher *WorkspaceSharing, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*WorkspaceSharing, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedExpiresAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"SharedWithEmail" {
			patchee.SharedWithEmail = patcher.SharedWithEmail
			continue
		}
		if f == prefix+"PermissionLevel" {
			patchee.PermissionLevel = patcher.PermissionLevel
			continue
		}
		if !updatedExpiresAt && strings.HasPrefix(f, prefix+"ExpiresAt.") {
			if patcher.ExpiresAt == nil {
				patchee.ExpiresAt = nil
				continue
			}
			if patchee.ExpiresAt == nil {
				patchee.ExpiresAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiresAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiresAt, patchee.ExpiresAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiresAt" {
			updatedExpiresAt = true
			patchee.ExpiresAt = patcher.ExpiresAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkspaceSharing executes a gorm list call
func DefaultListWorkspaceSharing(ctx context.Context, db *gorm.DB) ([]*WorkspaceSharing, error) {
	in := WorkspaceSharing{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []WorkspaceSharingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceSharingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*WorkspaceSharing{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkspaceSharingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceSharingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkspaceSharingORM) error
}

// DefaultCreateWorkspaceActivity executes a basic gorm create call
func DefaultCreateWorkspaceActivity(ctx context.Context, in *WorkspaceActivity, db *gorm.DB) (*WorkspaceActivity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceActivityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkspaceActivity(ctx context.Context, in *WorkspaceActivity, db *gorm.DB) (*WorkspaceActivity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkspaceActivityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkspaceActivityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceActivityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceActivity(ctx context.Context, in *WorkspaceActivity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkspaceActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkspaceActivityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceActivitySet(ctx context.Context, in []*WorkspaceActivity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&WorkspaceActivityORM{})).(WorkspaceActivityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&WorkspaceActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkspaceActivityORM{})).(WorkspaceActivityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkspaceActivityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*WorkspaceActivity, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*WorkspaceActivity, *gorm.DB) error
}

// DefaultStrictUpdateWorkspaceActivity clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkspaceActivity(ctx context.Context, in *WorkspaceActivity, db *gorm.DB) (*WorkspaceActivity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkspaceActivity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkspaceActivityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkspaceActivityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkspaceActivity executes a basic gorm update call with patch behavior
func DefaultPatchWorkspaceActivity(ctx context.Context, in *WorkspaceActivity, updateMask *field_mask.FieldMask, db *gorm.DB) (*WorkspaceActivity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj WorkspaceActivity
	var err error
	if hook, ok := interface{}(&pbObj).(WorkspaceActivityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadWorkspaceActivity(ctx, &WorkspaceActivity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(WorkspaceActivityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkspaceActivity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkspaceActivityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkspaceActivity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkspaceActivityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkspaceActivityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *WorkspaceActivity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *WorkspaceActivity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *WorkspaceActivity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *WorkspaceActivity, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkspaceActivity executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkspaceActivity(ctx context.Context, objects []*WorkspaceActivity, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*WorkspaceActivity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*WorkspaceActivity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkspaceActivity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkspaceActivity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkspaceActivity(ctx context.Context, patchee *WorkspaceActivity, patcher *WorkspaceActivity, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*WorkspaceActivity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ActivityType" {
			patchee.ActivityType = patcher.ActivityType
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkspaceActivity executes a gorm list call
func DefaultListWorkspaceActivity(ctx context.Context, db *gorm.DB) ([]*WorkspaceActivity, error) {
	in := WorkspaceActivity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []WorkspaceActivityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceActivityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*WorkspaceActivity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkspaceActivityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceActivityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkspaceActivityORM) error
}

// DefaultCreateWorkspaceCompliance executes a basic gorm create call
func DefaultCreateWorkspaceCompliance(ctx context.Context, in *WorkspaceCompliance, db *gorm.DB) (*WorkspaceCompliance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceComplianceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkspaceCompliance(ctx context.Context, in *WorkspaceCompliance, db *gorm.DB) (*WorkspaceCompliance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkspaceComplianceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkspaceComplianceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkspaceComplianceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceCompliance(ctx context.Context, in *WorkspaceCompliance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkspaceComplianceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkspaceComplianceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkspaceComplianceSet(ctx context.Context, in []*WorkspaceCompliance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&WorkspaceComplianceORM{})).(WorkspaceComplianceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&WorkspaceComplianceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkspaceComplianceORM{})).(WorkspaceComplianceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkspaceComplianceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*WorkspaceCompliance, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*WorkspaceCompliance, *gorm.DB) error
}

// DefaultStrictUpdateWorkspaceCompliance clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkspaceCompliance(ctx context.Context, in *WorkspaceCompliance, db *gorm.DB) (*WorkspaceCompliance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkspaceCompliance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkspaceComplianceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkspaceComplianceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkspaceCompliance executes a basic gorm update call with patch behavior
func DefaultPatchWorkspaceCompliance(ctx context.Context, in *WorkspaceCompliance, updateMask *field_mask.FieldMask, db *gorm.DB) (*WorkspaceCompliance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj WorkspaceCompliance
	var err error
	if hook, ok := interface{}(&pbObj).(WorkspaceComplianceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadWorkspaceCompliance(ctx, &WorkspaceCompliance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(WorkspaceComplianceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkspaceCompliance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkspaceComplianceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkspaceCompliance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkspaceComplianceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkspaceComplianceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *WorkspaceCompliance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *WorkspaceCompliance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *WorkspaceCompliance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *WorkspaceCompliance, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkspaceCompliance executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkspaceCompliance(ctx context.Context, objects []*WorkspaceCompliance, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*WorkspaceCompliance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*WorkspaceCompliance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkspaceCompliance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkspaceCompliance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkspaceCompliance(ctx context.Context, patchee *WorkspaceCompliance, patcher *WorkspaceCompliance, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*WorkspaceCompliance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedValidUntil bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ComplianceType" {
			patchee.ComplianceType = patcher.ComplianceType
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"CertificationId" {
			patchee.CertificationId = patcher.CertificationId
			continue
		}
		if !updatedValidUntil && strings.HasPrefix(f, prefix+"ValidUntil.") {
			if patcher.ValidUntil == nil {
				patchee.ValidUntil = nil
				continue
			}
			if patchee.ValidUntil == nil {
				patchee.ValidUntil = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ValidUntil."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ValidUntil, patchee.ValidUntil, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ValidUntil" {
			updatedValidUntil = true
			patchee.ValidUntil = patcher.ValidUntil
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkspaceCompliance executes a gorm list call
func DefaultListWorkspaceCompliance(ctx context.Context, db *gorm.DB) ([]*WorkspaceCompliance, error) {
	in := WorkspaceCompliance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []WorkspaceComplianceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkspaceComplianceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*WorkspaceCompliance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkspaceComplianceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkspaceComplianceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkspaceComplianceORM) error
}

// DefaultCreateFolderMetadata executes a basic gorm create call
func DefaultCreateFolderMetadata(ctx context.Context, in *FolderMetadata, db *gorm.DB) (*FolderMetadata, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FolderMetadataORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFolderMetadata(ctx context.Context, in *FolderMetadata, db *gorm.DB) (*FolderMetadata, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FolderMetadataORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FolderMetadataORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FolderMetadataORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFolderMetadata(ctx context.Context, in *FolderMetadata, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FolderMetadataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FolderMetadataORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFolderMetadataSet(ctx context.Context, in []*FolderMetadata, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FolderMetadataORM{})).(FolderMetadataORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FolderMetadataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FolderMetadataORM{})).(FolderMetadataORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FolderMetadataORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FolderMetadata, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FolderMetadata, *gorm.DB) error
}

// DefaultStrictUpdateFolderMetadata clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFolderMetadata(ctx context.Context, in *FolderMetadata, db *gorm.DB) (*FolderMetadata, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFolderMetadata")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FolderMetadataORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FolderMetadataORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFolderMetadata executes a basic gorm update call with patch behavior
func DefaultPatchFolderMetadata(ctx context.Context, in *FolderMetadata, updateMask *field_mask.FieldMask, db *gorm.DB) (*FolderMetadata, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FolderMetadata
	var err error
	if hook, ok := interface{}(&pbObj).(FolderMetadataWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFolderMetadata(ctx, &FolderMetadata{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FolderMetadataWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFolderMetadata(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FolderMetadataWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFolderMetadata(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FolderMetadataWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FolderMetadataWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FolderMetadata, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FolderMetadata, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FolderMetadata, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FolderMetadata, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFolderMetadata executes a bulk gorm update call with patch behavior
func DefaultPatchSetFolderMetadata(ctx context.Context, objects []*FolderMetadata, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FolderMetadata, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FolderMetadata, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFolderMetadata(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFolderMetadata patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFolderMetadata(ctx context.Context, patchee *FolderMetadata, patcher *FolderMetadata, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FolderMetadata, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"S3BucketName" {
			patchee.S3BucketName = patcher.S3BucketName
			continue
		}
		if f == prefix+"S3FolderPath" {
			patchee.S3FolderPath = patcher.S3FolderPath
			continue
		}
		if f == prefix+"IsDeleted" {
			patchee.IsDeleted = patcher.IsDeleted
			continue
		}
		if f == prefix+"ParentFolderId" {
			patchee.ParentFolderId = patcher.ParentFolderId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Files" {
			patchee.Files = patcher.Files
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFolderMetadata executes a gorm list call
func DefaultListFolderMetadata(ctx context.Context, db *gorm.DB) ([]*FolderMetadata, error) {
	in := FolderMetadata{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FolderMetadataORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FolderMetadataORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FolderMetadata{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FolderMetadataORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FolderMetadataORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FolderMetadataORM) error
}

// DefaultCreateFileEmbeddings executes a basic gorm create call
func DefaultCreateFileEmbeddings(ctx context.Context, in *FileEmbeddings, db *gorm.DB) (*FileEmbeddings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FileEmbeddingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFileEmbeddings(ctx context.Context, in *FileEmbeddings, db *gorm.DB) (*FileEmbeddings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FileEmbeddingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FileEmbeddingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FileEmbeddingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFileEmbeddings(ctx context.Context, in *FileEmbeddings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FileEmbeddingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FileEmbeddingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFileEmbeddingsSet(ctx context.Context, in []*FileEmbeddings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FileEmbeddingsORM{})).(FileEmbeddingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FileEmbeddingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FileEmbeddingsORM{})).(FileEmbeddingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FileEmbeddingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FileEmbeddings, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FileEmbeddings, *gorm.DB) error
}

// DefaultStrictUpdateFileEmbeddings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFileEmbeddings(ctx context.Context, in *FileEmbeddings, db *gorm.DB) (*FileEmbeddings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFileEmbeddings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FileEmbeddingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FileEmbeddingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFileEmbeddings executes a basic gorm update call with patch behavior
func DefaultPatchFileEmbeddings(ctx context.Context, in *FileEmbeddings, updateMask *field_mask.FieldMask, db *gorm.DB) (*FileEmbeddings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FileEmbeddings
	var err error
	if hook, ok := interface{}(&pbObj).(FileEmbeddingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFileEmbeddings(ctx, &FileEmbeddings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FileEmbeddingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFileEmbeddings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FileEmbeddingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFileEmbeddings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FileEmbeddingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FileEmbeddingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FileEmbeddings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FileEmbeddings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FileEmbeddings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FileEmbeddings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFileEmbeddings executes a bulk gorm update call with patch behavior
func DefaultPatchSetFileEmbeddings(ctx context.Context, objects []*FileEmbeddings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FileEmbeddings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FileEmbeddings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFileEmbeddings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFileEmbeddings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFileEmbeddings(ctx context.Context, patchee *FileEmbeddings, patcher *FileEmbeddings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FileEmbeddings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Embeddings" {
			patchee.Embeddings = patcher.Embeddings
			continue
		}
		if f == prefix+"ModelVersion" {
			patchee.ModelVersion = patcher.ModelVersion
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFileEmbeddings executes a gorm list call
func DefaultListFileEmbeddings(ctx context.Context, db *gorm.DB) ([]*FileEmbeddings, error) {
	in := FileEmbeddings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FileEmbeddingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileEmbeddingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FileEmbeddings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FileEmbeddingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileEmbeddingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FileEmbeddingsORM) error
}

// DefaultCreateFileVersion executes a basic gorm create call
func DefaultCreateFileVersion(ctx context.Context, in *FileVersion, db *gorm.DB) (*FileVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FileVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFileVersion(ctx context.Context, in *FileVersion, db *gorm.DB) (*FileVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FileVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FileVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FileVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFileVersion(ctx context.Context, in *FileVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FileVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FileVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFileVersionSet(ctx context.Context, in []*FileVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FileVersionORM{})).(FileVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FileVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FileVersionORM{})).(FileVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FileVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FileVersion, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FileVersion, *gorm.DB) error
}

// DefaultStrictUpdateFileVersion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFileVersion(ctx context.Context, in *FileVersion, db *gorm.DB) (*FileVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFileVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FileVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FileVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFileVersion executes a basic gorm update call with patch behavior
func DefaultPatchFileVersion(ctx context.Context, in *FileVersion, updateMask *field_mask.FieldMask, db *gorm.DB) (*FileVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FileVersion
	var err error
	if hook, ok := interface{}(&pbObj).(FileVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFileVersion(ctx, &FileVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FileVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFileVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FileVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFileVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FileVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FileVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FileVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FileVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FileVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FileVersion, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFileVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetFileVersion(ctx context.Context, objects []*FileVersion, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FileVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FileVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFileVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFileVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFileVersion(ctx context.Context, patchee *FileVersion, patcher *FileVersion, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FileVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FileId" {
			patchee.FileId = patcher.FileId
			continue
		}
		if f == prefix+"VersionNumber" {
			patchee.VersionNumber = patcher.VersionNumber
			continue
		}
		if f == prefix+"S3Key" {
			patchee.S3Key = patcher.S3Key
			continue
		}
		if f == prefix+"Size" {
			patchee.Size = patcher.Size
			continue
		}
		if f == prefix+"CommitMessage" {
			patchee.CommitMessage = patcher.CommitMessage
			continue
		}
		if f == prefix+"AuthorId" {
			patchee.AuthorId = patcher.AuthorId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFileVersion executes a gorm list call
func DefaultListFileVersion(ctx context.Context, db *gorm.DB) ([]*FileVersion, error) {
	in := FileVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FileVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FileVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FileVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FileVersionORM) error
}

// DefaultCreateCommentThread executes a basic gorm create call
func DefaultCreateCommentThread(ctx context.Context, in *CommentThread, db *gorm.DB) (*CommentThread, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CommentThreadORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCommentThread(ctx context.Context, in *CommentThread, db *gorm.DB) (*CommentThread, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CommentThreadORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CommentThreadORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CommentThreadORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCommentThread(ctx context.Context, in *CommentThread, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CommentThreadORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CommentThreadORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCommentThreadSet(ctx context.Context, in []*CommentThread, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CommentThreadORM{})).(CommentThreadORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CommentThreadORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CommentThreadORM{})).(CommentThreadORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CommentThreadORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CommentThread, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CommentThread, *gorm.DB) error
}

// DefaultStrictUpdateCommentThread clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCommentThread(ctx context.Context, in *CommentThread, db *gorm.DB) (*CommentThread, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCommentThread")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CommentThreadORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CommentThreadORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCommentThread executes a basic gorm update call with patch behavior
func DefaultPatchCommentThread(ctx context.Context, in *CommentThread, updateMask *field_mask.FieldMask, db *gorm.DB) (*CommentThread, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CommentThread
	var err error
	if hook, ok := interface{}(&pbObj).(CommentThreadWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCommentThread(ctx, &CommentThread{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CommentThreadWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCommentThread(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CommentThreadWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCommentThread(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CommentThreadWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CommentThreadWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CommentThread, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CommentThread, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CommentThread, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CommentThread, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCommentThread executes a bulk gorm update call with patch behavior
func DefaultPatchSetCommentThread(ctx context.Context, objects []*CommentThread, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CommentThread, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CommentThread, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCommentThread(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCommentThread patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCommentThread(ctx context.Context, patchee *CommentThread, patcher *CommentThread, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CommentThread, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AuthorId" {
			patchee.AuthorId = patcher.AuthorId
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"StartPosition" {
			patchee.StartPosition = patcher.StartPosition
			continue
		}
		if f == prefix+"EndPosition" {
			patchee.EndPosition = patcher.EndPosition
			continue
		}
		if f == prefix+"Resolved" {
			patchee.Resolved = patcher.Resolved
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCommentThread executes a gorm list call
func DefaultListCommentThread(ctx context.Context, db *gorm.DB) ([]*CommentThread, error) {
	in := CommentThread{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CommentThreadORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommentThreadORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CommentThread{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CommentThreadORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommentThreadORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CommentThreadORM) error
}

// DefaultCreateFileSharing executes a basic gorm create call
func DefaultCreateFileSharing(ctx context.Context, in *FileSharing, db *gorm.DB) (*FileSharing, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FileSharingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFileSharing(ctx context.Context, in *FileSharing, db *gorm.DB) (*FileSharing, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FileSharingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FileSharingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FileSharingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFileSharing(ctx context.Context, in *FileSharing, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FileSharingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FileSharingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFileSharingSet(ctx context.Context, in []*FileSharing, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FileSharingORM{})).(FileSharingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FileSharingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FileSharingORM{})).(FileSharingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FileSharingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FileSharing, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FileSharing, *gorm.DB) error
}

// DefaultStrictUpdateFileSharing clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFileSharing(ctx context.Context, in *FileSharing, db *gorm.DB) (*FileSharing, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFileSharing")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FileSharingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FileSharingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFileSharing executes a basic gorm update call with patch behavior
func DefaultPatchFileSharing(ctx context.Context, in *FileSharing, updateMask *field_mask.FieldMask, db *gorm.DB) (*FileSharing, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FileSharing
	var err error
	if hook, ok := interface{}(&pbObj).(FileSharingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFileSharing(ctx, &FileSharing{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FileSharingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFileSharing(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FileSharingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFileSharing(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FileSharingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FileSharingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FileSharing, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileSharingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FileSharing, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileSharingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FileSharing, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileSharingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FileSharing, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFileSharing executes a bulk gorm update call with patch behavior
func DefaultPatchSetFileSharing(ctx context.Context, objects []*FileSharing, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FileSharing, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FileSharing, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFileSharing(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFileSharing patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFileSharing(ctx context.Context, patchee *FileSharing, patcher *FileSharing, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FileSharing, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedExpiresAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"SharedWithEmail" {
			patchee.SharedWithEmail = patcher.SharedWithEmail
			continue
		}
		if f == prefix+"PermissionLevel" {
			patchee.PermissionLevel = patcher.PermissionLevel
			continue
		}
		if !updatedExpiresAt && strings.HasPrefix(f, prefix+"ExpiresAt.") {
			if patcher.ExpiresAt == nil {
				patchee.ExpiresAt = nil
				continue
			}
			if patchee.ExpiresAt == nil {
				patchee.ExpiresAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiresAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiresAt, patchee.ExpiresAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiresAt" {
			updatedExpiresAt = true
			patchee.ExpiresAt = patcher.ExpiresAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFileSharing executes a gorm list call
func DefaultListFileSharing(ctx context.Context, db *gorm.DB) ([]*FileSharing, error) {
	in := FileSharing{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FileSharingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileSharingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FileSharing{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FileSharingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileSharingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FileSharingORM) error
}

// DefaultCreateDocumentTemplate executes a basic gorm create call
func DefaultCreateDocumentTemplate(ctx context.Context, in *DocumentTemplate, db *gorm.DB) (*DocumentTemplate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentTemplateORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDocumentTemplate(ctx context.Context, in *DocumentTemplate, db *gorm.DB) (*DocumentTemplate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DocumentTemplateORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DocumentTemplateORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DocumentTemplateORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentTemplate(ctx context.Context, in *DocumentTemplate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DocumentTemplateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DocumentTemplateORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentTemplateSet(ctx context.Context, in []*DocumentTemplate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DocumentTemplateORM{})).(DocumentTemplateORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DocumentTemplateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DocumentTemplateORM{})).(DocumentTemplateORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DocumentTemplateORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DocumentTemplate, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DocumentTemplate, *gorm.DB) error
}

// DefaultStrictUpdateDocumentTemplate clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDocumentTemplate(ctx context.Context, in *DocumentTemplate, db *gorm.DB) (*DocumentTemplate, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDocumentTemplate")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DocumentTemplateORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterExplanations := ExplanationBlockORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterExplanations.DocumentTemplateId = new(uint64)
	*filterExplanations.DocumentTemplateId = ormObj.Id
	if err = db.Where(filterExplanations).Delete(ExplanationBlockORM{}).Error; err != nil {
		return nil, err
	}
	filterInstances := DocumentInstanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInstances.DocumentTemplateId = new(uint64)
	*filterInstances.DocumentTemplateId = ormObj.Id
	if err = db.Where(filterInstances).Delete(DocumentInstanceORM{}).Error; err != nil {
		return nil, err
	}
	filterIntelligence := ContractIntelligenceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIntelligence.DocumentTemplateId = new(uint64)
	*filterIntelligence.DocumentTemplateId = ormObj.Id
	if err = db.Where(filterIntelligence).Delete(ContractIntelligenceORM{}).Error; err != nil {
		return nil, err
	}
	filterVariables := TemplateVariableORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVariables.DocumentTemplateId = new(uint64)
	*filterVariables.DocumentTemplateId = ormObj.Id
	if err = db.Where(filterVariables).Delete(TemplateVariableORM{}).Error; err != nil {
		return nil, err
	}
	filterVersions := TemplateVersionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVersions.DocumentTemplateId = new(uint64)
	*filterVersions.DocumentTemplateId = ormObj.Id
	if err = db.Where(filterVersions).Delete(TemplateVersionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DocumentTemplateORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDocumentTemplate executes a basic gorm update call with patch behavior
func DefaultPatchDocumentTemplate(ctx context.Context, in *DocumentTemplate, updateMask *field_mask.FieldMask, db *gorm.DB) (*DocumentTemplate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DocumentTemplate
	var err error
	if hook, ok := interface{}(&pbObj).(DocumentTemplateWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDocumentTemplate(ctx, &DocumentTemplate{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DocumentTemplateWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDocumentTemplate(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DocumentTemplateWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDocumentTemplate(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DocumentTemplateWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DocumentTemplateWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DocumentTemplate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DocumentTemplate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DocumentTemplate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DocumentTemplate, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDocumentTemplate executes a bulk gorm update call with patch behavior
func DefaultPatchSetDocumentTemplate(ctx context.Context, objects []*DocumentTemplate, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DocumentTemplate, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DocumentTemplate, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDocumentTemplate(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDocumentTemplate patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocumentTemplate(ctx context.Context, patchee *DocumentTemplate, patcher *DocumentTemplate, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DocumentTemplate, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"IndustryType" {
			patchee.IndustryType = patcher.IndustryType
			continue
		}
		if f == prefix+"DocumentType" {
			patchee.DocumentType = patcher.DocumentType
			continue
		}
		if f == prefix+"BaseContent" {
			patchee.BaseContent = patcher.BaseContent
			continue
		}
		if f == prefix+"IsAdaptive" {
			patchee.IsAdaptive = patcher.IsAdaptive
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if f == prefix+"SupportedLanguages" {
			patchee.SupportedLanguages = patcher.SupportedLanguages
			continue
		}
		if f == prefix+"RequiredDataFields" {
			patchee.RequiredDataFields = patcher.RequiredDataFields
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"TemplateType" {
			patchee.TemplateType = patcher.TemplateType
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"DetectedVariables" {
			patchee.DetectedVariables = patcher.DetectedVariables
			continue
		}
		if f == prefix+"VariableMappings" {
			patchee.VariableMappings = patcher.VariableMappings
			continue
		}
		if f == prefix+"IsContextAware" {
			patchee.IsContextAware = patcher.IsContextAware
			continue
		}
		if f == prefix+"SupportedContexts" {
			patchee.SupportedContexts = patcher.SupportedContexts
			continue
		}
		if f == prefix+"FormattingRules" {
			patchee.FormattingRules = patcher.FormattingRules
			continue
		}
		if f == prefix+"ConditionalSections" {
			patchee.ConditionalSections = patcher.ConditionalSections
			continue
		}
		if f == prefix+"Versions" {
			patchee.Versions = patcher.Versions
			continue
		}
		if f == prefix+"Variables" {
			patchee.Variables = patcher.Variables
			continue
		}
		if f == prefix+"Instances" {
			patchee.Instances = patcher.Instances
			continue
		}
		if f == prefix+"Explanations" {
			patchee.Explanations = patcher.Explanations
			continue
		}
		if f == prefix+"Intelligence" {
			patchee.Intelligence = patcher.Intelligence
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocumentTemplate executes a gorm list call
func DefaultListDocumentTemplate(ctx context.Context, db *gorm.DB) ([]*DocumentTemplate, error) {
	in := DocumentTemplate{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DocumentTemplateORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTemplateORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DocumentTemplate{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentTemplateORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTemplateORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentTemplateORM) error
}

// DefaultCreateTemplateVariable executes a basic gorm create call
func DefaultCreateTemplateVariable(ctx context.Context, in *TemplateVariable, db *gorm.DB) (*TemplateVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TemplateVariableORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTemplateVariable(ctx context.Context, in *TemplateVariable, db *gorm.DB) (*TemplateVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TemplateVariableORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TemplateVariableORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TemplateVariableORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTemplateVariable(ctx context.Context, in *TemplateVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TemplateVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TemplateVariableORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTemplateVariableSet(ctx context.Context, in []*TemplateVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TemplateVariableORM{})).(TemplateVariableORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TemplateVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TemplateVariableORM{})).(TemplateVariableORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TemplateVariableORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TemplateVariable, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TemplateVariable, *gorm.DB) error
}

// DefaultStrictUpdateTemplateVariable clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTemplateVariable(ctx context.Context, in *TemplateVariable, db *gorm.DB) (*TemplateVariable, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTemplateVariable")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TemplateVariableORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TemplateVariableORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTemplateVariable executes a basic gorm update call with patch behavior
func DefaultPatchTemplateVariable(ctx context.Context, in *TemplateVariable, updateMask *field_mask.FieldMask, db *gorm.DB) (*TemplateVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TemplateVariable
	var err error
	if hook, ok := interface{}(&pbObj).(TemplateVariableWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTemplateVariable(ctx, &TemplateVariable{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TemplateVariableWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTemplateVariable(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TemplateVariableWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTemplateVariable(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TemplateVariableWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TemplateVariableWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TemplateVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TemplateVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TemplateVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TemplateVariable, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTemplateVariable executes a bulk gorm update call with patch behavior
func DefaultPatchSetTemplateVariable(ctx context.Context, objects []*TemplateVariable, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TemplateVariable, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TemplateVariable, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTemplateVariable(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTemplateVariable patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTemplateVariable(ctx context.Context, patchee *TemplateVariable, patcher *TemplateVariable, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TemplateVariable, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"VariableType" {
			patchee.VariableType = patcher.VariableType
			continue
		}
		if f == prefix+"DefaultValue" {
			patchee.DefaultValue = patcher.DefaultValue
			continue
		}
		if f == prefix+"IsRequired" {
			patchee.IsRequired = patcher.IsRequired
			continue
		}
		if f == prefix+"ValidationRules" {
			patchee.ValidationRules = patcher.ValidationRules
			continue
		}
		if f == prefix+"DataSource" {
			patchee.DataSource = patcher.DataSource
			continue
		}
		if f == prefix+"AiExtractionRules" {
			patchee.AiExtractionRules = patcher.AiExtractionRules
			continue
		}
		if f == prefix+"Alternatives" {
			patchee.Alternatives = patcher.Alternatives
			continue
		}
		if f == prefix+"TemplateId" {
			patchee.TemplateId = patcher.TemplateId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTemplateVariable executes a gorm list call
func DefaultListTemplateVariable(ctx context.Context, db *gorm.DB) ([]*TemplateVariable, error) {
	in := TemplateVariable{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TemplateVariableORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVariableORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TemplateVariable{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TemplateVariableORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVariableORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TemplateVariableORM) error
}

// DefaultCreateDocumentInstance executes a basic gorm create call
func DefaultCreateDocumentInstance(ctx context.Context, in *DocumentInstance, db *gorm.DB) (*DocumentInstance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentInstanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDocumentInstance(ctx context.Context, in *DocumentInstance, db *gorm.DB) (*DocumentInstance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DocumentInstanceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DocumentInstanceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DocumentInstanceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentInstance(ctx context.Context, in *DocumentInstance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DocumentInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DocumentInstanceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentInstanceSet(ctx context.Context, in []*DocumentInstance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DocumentInstanceORM{})).(DocumentInstanceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DocumentInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DocumentInstanceORM{})).(DocumentInstanceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DocumentInstanceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DocumentInstance, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DocumentInstance, *gorm.DB) error
}

// DefaultStrictUpdateDocumentInstance clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDocumentInstance(ctx context.Context, in *DocumentInstance, db *gorm.DB) (*DocumentInstance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDocumentInstance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DocumentInstanceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAiAssistance := AIAssistanceLogORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAiAssistance.DocumentInstanceId = new(uint64)
	*filterAiAssistance.DocumentInstanceId = ormObj.Id
	if err = db.Where(filterAiAssistance).Delete(AIAssistanceLogORM{}).Error; err != nil {
		return nil, err
	}
	filterNegotiation := NegotiationHistoryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNegotiation.DocumentInstanceId = new(uint64)
	*filterNegotiation.DocumentInstanceId = ormObj.Id
	if err = db.Where(filterNegotiation).Delete(NegotiationHistoryORM{}).Error; err != nil {
		return nil, err
	}
	filterSignatureRequests := SignatureRequestORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSignatureRequests.DocumentInstanceId = new(uint64)
	*filterSignatureRequests.DocumentInstanceId = ormObj.Id
	if err = db.Where(filterSignatureRequests).Delete(SignatureRequestORM{}).Error; err != nil {
		return nil, err
	}
	filterVersions := DocumentVersionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVersions.DocumentInstanceId = new(uint64)
	*filterVersions.DocumentInstanceId = ormObj.Id
	if err = db.Where(filterVersions).Delete(DocumentVersionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DocumentInstanceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDocumentInstance executes a basic gorm update call with patch behavior
func DefaultPatchDocumentInstance(ctx context.Context, in *DocumentInstance, updateMask *field_mask.FieldMask, db *gorm.DB) (*DocumentInstance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DocumentInstance
	var err error
	if hook, ok := interface{}(&pbObj).(DocumentInstanceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDocumentInstance(ctx, &DocumentInstance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DocumentInstanceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDocumentInstance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DocumentInstanceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDocumentInstance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DocumentInstanceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DocumentInstanceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DocumentInstance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DocumentInstance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DocumentInstance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DocumentInstance, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDocumentInstance executes a bulk gorm update call with patch behavior
func DefaultPatchSetDocumentInstance(ctx context.Context, objects []*DocumentInstance, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DocumentInstance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DocumentInstance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDocumentInstance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDocumentInstance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocumentInstance(ctx context.Context, patchee *DocumentInstance, patcher *DocumentInstance, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DocumentInstance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDueDate bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedNegotiation bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TemplateId" {
			patchee.TemplateId = patcher.TemplateId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"FieldValues" {
			patchee.FieldValues = patcher.FieldValues
			continue
		}
		if f == prefix+"Signers" {
			patchee.Signers = patcher.Signers
			continue
		}
		if f == prefix+"Language" {
			patchee.Language = patcher.Language
			continue
		}
		if f == prefix+"IsCompleted" {
			patchee.IsCompleted = patcher.IsCompleted
			continue
		}
		if !updatedDueDate && strings.HasPrefix(f, prefix+"DueDate.") {
			if patcher.DueDate == nil {
				patchee.DueDate = nil
				continue
			}
			if patchee.DueDate == nil {
				patchee.DueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DueDate, patchee.DueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DueDate" {
			updatedDueDate = true
			patchee.DueDate = patcher.DueDate
			continue
		}
		if f == prefix+"GeneratedContent" {
			patchee.GeneratedContent = patcher.GeneratedContent
			continue
		}
		if f == prefix+"Attachments" {
			patchee.Attachments = patcher.Attachments
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"SignatureRequests" {
			patchee.SignatureRequests = patcher.SignatureRequests
			continue
		}
		if f == prefix+"AiAssistance" {
			patchee.AiAssistance = patcher.AiAssistance
			continue
		}
		if !updatedNegotiation && strings.HasPrefix(f, prefix+"Negotiation.") {
			updatedNegotiation = true
			if patcher.Negotiation == nil {
				patchee.Negotiation = nil
				continue
			}
			if patchee.Negotiation == nil {
				patchee.Negotiation = &NegotiationHistory{}
			}
			if o, err := DefaultApplyFieldMaskNegotiationHistory(ctx, patchee.Negotiation, patcher.Negotiation, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Negotiation.", db); err != nil {
				return nil, err
			} else {
				patchee.Negotiation = o
			}
			continue
		}
		if f == prefix+"Negotiation" {
			updatedNegotiation = true
			patchee.Negotiation = patcher.Negotiation
			continue
		}
		if f == prefix+"Versions" {
			patchee.Versions = patcher.Versions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocumentInstance executes a gorm list call
func DefaultListDocumentInstance(ctx context.Context, db *gorm.DB) ([]*DocumentInstance, error) {
	in := DocumentInstance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DocumentInstanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentInstanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DocumentInstance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentInstanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentInstanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentInstanceORM) error
}

// DefaultCreateDocumentVersion executes a basic gorm create call
func DefaultCreateDocumentVersion(ctx context.Context, in *DocumentVersion, db *gorm.DB) (*DocumentVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDocumentVersion(ctx context.Context, in *DocumentVersion, db *gorm.DB) (*DocumentVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DocumentVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DocumentVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DocumentVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentVersion(ctx context.Context, in *DocumentVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DocumentVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DocumentVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentVersionSet(ctx context.Context, in []*DocumentVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DocumentVersionORM{})).(DocumentVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DocumentVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DocumentVersionORM{})).(DocumentVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DocumentVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DocumentVersion, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DocumentVersion, *gorm.DB) error
}

// DefaultStrictUpdateDocumentVersion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDocumentVersion(ctx context.Context, in *DocumentVersion, db *gorm.DB) (*DocumentVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDocumentVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DocumentVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBranches := DocumentBranchORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBranches.DocumentVersionId = new(uint64)
	*filterBranches.DocumentVersionId = ormObj.Id
	if err = db.Where(filterBranches).Delete(DocumentBranchORM{}).Error; err != nil {
		return nil, err
	}
	filterChanges := ChangeSetORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterChanges.DocumentVersionId = new(uint64)
	*filterChanges.DocumentVersionId = ormObj.Id
	if err = db.Where(filterChanges).Delete(ChangeSetORM{}).Error; err != nil {
		return nil, err
	}
	filterSummaries := ContextualSummaryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSummaries.DocumentVersionId = new(uint64)
	*filterSummaries.DocumentVersionId = ormObj.Id
	if err = db.Where(filterSummaries).Delete(ContextualSummaryORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DocumentVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDocumentVersion executes a basic gorm update call with patch behavior
func DefaultPatchDocumentVersion(ctx context.Context, in *DocumentVersion, updateMask *field_mask.FieldMask, db *gorm.DB) (*DocumentVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DocumentVersion
	var err error
	if hook, ok := interface{}(&pbObj).(DocumentVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDocumentVersion(ctx, &DocumentVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DocumentVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDocumentVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DocumentVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDocumentVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DocumentVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DocumentVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DocumentVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DocumentVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DocumentVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DocumentVersion, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDocumentVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetDocumentVersion(ctx context.Context, objects []*DocumentVersion, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DocumentVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DocumentVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDocumentVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDocumentVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocumentVersion(ctx context.Context, patchee *DocumentVersion, patcher *DocumentVersion, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DocumentVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"VersionHash" {
			patchee.VersionHash = patcher.VersionHash
			continue
		}
		if f == prefix+"ParentHash" {
			patchee.ParentHash = patcher.ParentHash
			continue
		}
		if f == prefix+"CommitMessage" {
			patchee.CommitMessage = patcher.CommitMessage
			continue
		}
		if f == prefix+"AuthorId" {
			patchee.AuthorId = patcher.AuthorId
			continue
		}
		if f == prefix+"BranchName" {
			patchee.BranchName = patcher.BranchName
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"IsApproved" {
			patchee.IsApproved = patcher.IsApproved
			continue
		}
		if f == prefix+"ApprovalChain" {
			patchee.ApprovalChain = patcher.ApprovalChain
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Branches" {
			patchee.Branches = patcher.Branches
			continue
		}
		if f == prefix+"Changes" {
			patchee.Changes = patcher.Changes
			continue
		}
		if f == prefix+"Summaries" {
			patchee.Summaries = patcher.Summaries
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocumentVersion executes a gorm list call
func DefaultListDocumentVersion(ctx context.Context, db *gorm.DB) ([]*DocumentVersion, error) {
	in := DocumentVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DocumentVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DocumentVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentVersionORM) error
}

// DefaultCreateDocumentBranch executes a basic gorm create call
func DefaultCreateDocumentBranch(ctx context.Context, in *DocumentBranch, db *gorm.DB) (*DocumentBranch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentBranchORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDocumentBranch(ctx context.Context, in *DocumentBranch, db *gorm.DB) (*DocumentBranch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DocumentBranchORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DocumentBranchORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DocumentBranchORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentBranch(ctx context.Context, in *DocumentBranch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DocumentBranchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DocumentBranchORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentBranchSet(ctx context.Context, in []*DocumentBranch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DocumentBranchORM{})).(DocumentBranchORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DocumentBranchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DocumentBranchORM{})).(DocumentBranchORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DocumentBranchORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DocumentBranch, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DocumentBranch, *gorm.DB) error
}

// DefaultStrictUpdateDocumentBranch clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDocumentBranch(ctx context.Context, in *DocumentBranch, db *gorm.DB) (*DocumentBranch, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDocumentBranch")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DocumentBranchORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterMergeRequests := MergeRequestORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMergeRequests.DocumentBranchId = new(uint64)
	*filterMergeRequests.DocumentBranchId = ormObj.Id
	if err = db.Where(filterMergeRequests).Delete(MergeRequestORM{}).Error; err != nil {
		return nil, err
	}
	filterMerges := BranchMergeORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMerges.DocumentBranchId = new(uint64)
	*filterMerges.DocumentBranchId = ormObj.Id
	if err = db.Where(filterMerges).Delete(BranchMergeORM{}).Error; err != nil {
		return nil, err
	}
	filterPolicy := BranchPolicyORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPolicy.DocumentBranchId = new(uint64)
	*filterPolicy.DocumentBranchId = ormObj.Id
	if err = db.Where(filterPolicy).Delete(BranchPolicyORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DocumentBranchORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDocumentBranch executes a basic gorm update call with patch behavior
func DefaultPatchDocumentBranch(ctx context.Context, in *DocumentBranch, updateMask *field_mask.FieldMask, db *gorm.DB) (*DocumentBranch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DocumentBranch
	var err error
	if hook, ok := interface{}(&pbObj).(DocumentBranchWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDocumentBranch(ctx, &DocumentBranch{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DocumentBranchWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDocumentBranch(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DocumentBranchWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDocumentBranch(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DocumentBranchWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DocumentBranchWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DocumentBranch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DocumentBranch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DocumentBranch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DocumentBranch, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDocumentBranch executes a bulk gorm update call with patch behavior
func DefaultPatchSetDocumentBranch(ctx context.Context, objects []*DocumentBranch, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DocumentBranch, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DocumentBranch, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDocumentBranch(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDocumentBranch patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocumentBranch(ctx context.Context, patchee *DocumentBranch, patcher *DocumentBranch, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DocumentBranch, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastUpdated bool
	var updatedPolicy bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"BaseVersionHash" {
			patchee.BaseVersionHash = patcher.BaseVersionHash
			continue
		}
		if f == prefix+"CurrentHeadHash" {
			patchee.CurrentHeadHash = patcher.CurrentHeadHash
			continue
		}
		if f == prefix+"Purpose" {
			patchee.Purpose = patcher.Purpose
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Reviewers" {
			patchee.Reviewers = patcher.Reviewers
			continue
		}
		if f == prefix+"BranchMetadata" {
			patchee.BranchMetadata = patcher.BranchMetadata
			continue
		}
		if f == prefix+"IsLocked" {
			patchee.IsLocked = patcher.IsLocked
			continue
		}
		if !updatedLastUpdated && strings.HasPrefix(f, prefix+"LastUpdated.") {
			if patcher.LastUpdated == nil {
				patchee.LastUpdated = nil
				continue
			}
			if patchee.LastUpdated == nil {
				patchee.LastUpdated = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUpdated."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUpdated, patchee.LastUpdated, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUpdated" {
			updatedLastUpdated = true
			patchee.LastUpdated = patcher.LastUpdated
			continue
		}
		if f == prefix+"Merges" {
			patchee.Merges = patcher.Merges
			continue
		}
		if !updatedPolicy && strings.HasPrefix(f, prefix+"Policy.") {
			updatedPolicy = true
			if patcher.Policy == nil {
				patchee.Policy = nil
				continue
			}
			if patchee.Policy == nil {
				patchee.Policy = &BranchPolicy{}
			}
			if o, err := DefaultApplyFieldMaskBranchPolicy(ctx, patchee.Policy, patcher.Policy, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Policy.", db); err != nil {
				return nil, err
			} else {
				patchee.Policy = o
			}
			continue
		}
		if f == prefix+"Policy" {
			updatedPolicy = true
			patchee.Policy = patcher.Policy
			continue
		}
		if f == prefix+"MergeRequests" {
			patchee.MergeRequests = patcher.MergeRequests
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocumentBranch executes a gorm list call
func DefaultListDocumentBranch(ctx context.Context, db *gorm.DB) ([]*DocumentBranch, error) {
	in := DocumentBranch{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DocumentBranchORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentBranchORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DocumentBranch{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentBranchORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentBranchORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentBranchORM) error
}

// DefaultCreateSignatureRequest executes a basic gorm create call
func DefaultCreateSignatureRequest(ctx context.Context, in *SignatureRequest, db *gorm.DB) (*SignatureRequest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SignatureRequestORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSignatureRequest(ctx context.Context, in *SignatureRequest, db *gorm.DB) (*SignatureRequest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SignatureRequestORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SignatureRequestORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SignatureRequestORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSignatureRequest(ctx context.Context, in *SignatureRequest, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SignatureRequestORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SignatureRequestORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSignatureRequestSet(ctx context.Context, in []*SignatureRequest, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SignatureRequestORM{})).(SignatureRequestORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SignatureRequestORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SignatureRequestORM{})).(SignatureRequestORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SignatureRequestORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SignatureRequest, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SignatureRequest, *gorm.DB) error
}

// DefaultStrictUpdateSignatureRequest clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSignatureRequest(ctx context.Context, in *SignatureRequest, db *gorm.DB) (*SignatureRequest, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSignatureRequest")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SignatureRequestORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSignatureBlocks := SignatureBlockORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSignatureBlocks.SignatureRequestId = new(uint64)
	*filterSignatureBlocks.SignatureRequestId = ormObj.Id
	if err = db.Where(filterSignatureBlocks).Delete(SignatureBlockORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkflow := SignatureWorkflowORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterWorkflow.SignatureRequestId = new(uint64)
	*filterWorkflow.SignatureRequestId = ormObj.Id
	if err = db.Where(filterWorkflow).Delete(SignatureWorkflowORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SignatureRequestORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSignatureRequest executes a basic gorm update call with patch behavior
func DefaultPatchSignatureRequest(ctx context.Context, in *SignatureRequest, updateMask *field_mask.FieldMask, db *gorm.DB) (*SignatureRequest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SignatureRequest
	var err error
	if hook, ok := interface{}(&pbObj).(SignatureRequestWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSignatureRequest(ctx, &SignatureRequest{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SignatureRequestWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSignatureRequest(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SignatureRequestWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSignatureRequest(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SignatureRequestWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SignatureRequestWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SignatureRequest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SignatureRequest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SignatureRequest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SignatureRequest, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSignatureRequest executes a bulk gorm update call with patch behavior
func DefaultPatchSetSignatureRequest(ctx context.Context, objects []*SignatureRequest, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SignatureRequest, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SignatureRequest, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSignatureRequest(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSignatureRequest patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSignatureRequest(ctx context.Context, patchee *SignatureRequest, patcher *SignatureRequest, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SignatureRequest, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedExpiresAt bool
	var updatedWorkflow bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"SignerEmail" {
			patchee.SignerEmail = patcher.SignerEmail
			continue
		}
		if f == prefix+"SignerName" {
			patchee.SignerName = patcher.SignerName
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if f == prefix+"AuthenticationMethod" {
			patchee.AuthenticationMethod = patcher.AuthenticationMethod
			continue
		}
		if !updatedExpiresAt && strings.HasPrefix(f, prefix+"ExpiresAt.") {
			if patcher.ExpiresAt == nil {
				patchee.ExpiresAt = nil
				continue
			}
			if patchee.ExpiresAt == nil {
				patchee.ExpiresAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiresAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiresAt, patchee.ExpiresAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiresAt" {
			updatedExpiresAt = true
			patchee.ExpiresAt = patcher.ExpiresAt
			continue
		}
		if f == prefix+"RequiresMfa" {
			patchee.RequiresMfa = patcher.RequiresMfa
			continue
		}
		if f == prefix+"SignatureType" {
			patchee.SignatureType = patcher.SignatureType
			continue
		}
		if f == prefix+"ReminderSchedule" {
			patchee.ReminderSchedule = patcher.ReminderSchedule
			continue
		}
		if f == prefix+"DocumentId" {
			patchee.DocumentId = patcher.DocumentId
			continue
		}
		if f == prefix+"SignatureBlocks" {
			patchee.SignatureBlocks = patcher.SignatureBlocks
			continue
		}
		if !updatedWorkflow && strings.HasPrefix(f, prefix+"Workflow.") {
			updatedWorkflow = true
			if patcher.Workflow == nil {
				patchee.Workflow = nil
				continue
			}
			if patchee.Workflow == nil {
				patchee.Workflow = &SignatureWorkflow{}
			}
			if o, err := DefaultApplyFieldMaskSignatureWorkflow(ctx, patchee.Workflow, patcher.Workflow, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Workflow.", db); err != nil {
				return nil, err
			} else {
				patchee.Workflow = o
			}
			continue
		}
		if f == prefix+"Workflow" {
			updatedWorkflow = true
			patchee.Workflow = patcher.Workflow
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSignatureRequest executes a gorm list call
func DefaultListSignatureRequest(ctx context.Context, db *gorm.DB) ([]*SignatureRequest, error) {
	in := SignatureRequest{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SignatureRequestORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureRequestORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SignatureRequest{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SignatureRequestORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureRequestORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SignatureRequestORM) error
}

// DefaultCreateContractIntelligence executes a basic gorm create call
func DefaultCreateContractIntelligence(ctx context.Context, in *ContractIntelligence, db *gorm.DB) (*ContractIntelligence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContractIntelligenceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadContractIntelligence(ctx context.Context, in *ContractIntelligence, db *gorm.DB) (*ContractIntelligence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContractIntelligenceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContractIntelligenceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContractIntelligenceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteContractIntelligence(ctx context.Context, in *ContractIntelligence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContractIntelligenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ContractIntelligenceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteContractIntelligenceSet(ctx context.Context, in []*ContractIntelligence, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContractIntelligenceORM{})).(ContractIntelligenceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ContractIntelligenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContractIntelligenceORM{})).(ContractIntelligenceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContractIntelligenceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ContractIntelligence, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ContractIntelligence, *gorm.DB) error
}

// DefaultStrictUpdateContractIntelligence clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContractIntelligence(ctx context.Context, in *ContractIntelligence, db *gorm.DB) (*ContractIntelligence, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContractIntelligence")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ContractIntelligenceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterComplianceChecks := ComplianceCheckORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterComplianceChecks.ContractIntelligenceId = new(uint64)
	*filterComplianceChecks.ContractIntelligenceId = ormObj.Id
	if err = db.Where(filterComplianceChecks).Delete(ComplianceCheckORM{}).Error; err != nil {
		return nil, err
	}
	filterRiskAssessments := RiskAssessmentORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRiskAssessments.ContractIntelligenceId = new(uint64)
	*filterRiskAssessments.ContractIntelligenceId = ormObj.Id
	if err = db.Where(filterRiskAssessments).Delete(RiskAssessmentORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContractIntelligenceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchContractIntelligence executes a basic gorm update call with patch behavior
func DefaultPatchContractIntelligence(ctx context.Context, in *ContractIntelligence, updateMask *field_mask.FieldMask, db *gorm.DB) (*ContractIntelligence, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ContractIntelligence
	var err error
	if hook, ok := interface{}(&pbObj).(ContractIntelligenceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContractIntelligence(ctx, &ContractIntelligence{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContractIntelligenceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContractIntelligence(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContractIntelligenceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContractIntelligence(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContractIntelligenceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContractIntelligenceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ContractIntelligence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ContractIntelligence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ContractIntelligence, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ContractIntelligence, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetContractIntelligence executes a bulk gorm update call with patch behavior
func DefaultPatchSetContractIntelligence(ctx context.Context, objects []*ContractIntelligence, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ContractIntelligence, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ContractIntelligence, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchContractIntelligence(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskContractIntelligence patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContractIntelligence(ctx context.Context, patchee *ContractIntelligence, patcher *ContractIntelligence, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ContractIntelligence, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAnalysisDate bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ContractType" {
			patchee.ContractType = patcher.ContractType
			continue
		}
		if f == prefix+"RiskScores" {
			patchee.RiskScores = patcher.RiskScores
			continue
		}
		if f == prefix+"DetectedClauses" {
			patchee.DetectedClauses = patcher.DetectedClauses
			continue
		}
		if f == prefix+"KeyObligations" {
			patchee.KeyObligations = patcher.KeyObligations
			continue
		}
		if f == prefix+"ComplianceScores" {
			patchee.ComplianceScores = patcher.ComplianceScores
			continue
		}
		if f == prefix+"Jurisdiction" {
			patchee.Jurisdiction = patcher.Jurisdiction
			continue
		}
		if f == prefix+"GoverningLaws" {
			patchee.GoverningLaws = patcher.GoverningLaws
			continue
		}
		if f == prefix+"SemanticAnalysis" {
			patchee.SemanticAnalysis = patcher.SemanticAnalysis
			continue
		}
		if !updatedAnalysisDate && strings.HasPrefix(f, prefix+"AnalysisDate.") {
			if patcher.AnalysisDate == nil {
				patchee.AnalysisDate = nil
				continue
			}
			if patchee.AnalysisDate == nil {
				patchee.AnalysisDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AnalysisDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AnalysisDate, patchee.AnalysisDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AnalysisDate" {
			updatedAnalysisDate = true
			patchee.AnalysisDate = patcher.AnalysisDate
			continue
		}
		if f == prefix+"RiskAssessments" {
			patchee.RiskAssessments = patcher.RiskAssessments
			continue
		}
		if f == prefix+"ComplianceChecks" {
			patchee.ComplianceChecks = patcher.ComplianceChecks
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContractIntelligence executes a gorm list call
func DefaultListContractIntelligence(ctx context.Context, db *gorm.DB) ([]*ContractIntelligence, error) {
	in := ContractIntelligence{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContractIntelligenceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContractIntelligenceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ContractIntelligence{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContractIntelligenceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContractIntelligenceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ContractIntelligenceORM) error
}

// DefaultCreateMarketplaceApp executes a basic gorm create call
func DefaultCreateMarketplaceApp(ctx context.Context, in *MarketplaceApp, db *gorm.DB) (*MarketplaceApp, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MarketplaceAppORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMarketplaceApp(ctx context.Context, in *MarketplaceApp, db *gorm.DB) (*MarketplaceApp, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MarketplaceAppORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MarketplaceAppORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MarketplaceAppORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMarketplaceApp(ctx context.Context, in *MarketplaceApp, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MarketplaceAppORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MarketplaceAppORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMarketplaceAppSet(ctx context.Context, in []*MarketplaceApp, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MarketplaceAppORM{})).(MarketplaceAppORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MarketplaceAppORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MarketplaceAppORM{})).(MarketplaceAppORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MarketplaceAppORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MarketplaceApp, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MarketplaceApp, *gorm.DB) error
}

// DefaultStrictUpdateMarketplaceApp clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMarketplaceApp(ctx context.Context, in *MarketplaceApp, db *gorm.DB) (*MarketplaceApp, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMarketplaceApp")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MarketplaceAppORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAnalytics := AppAnalyticsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAnalytics.MarketplaceAppId = new(uint64)
	*filterAnalytics.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterAnalytics).Delete(AppAnalyticsORM{}).Error; err != nil {
		return nil, err
	}
	filterInfo := AppDevelopmentInfoORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInfo.MarketplaceAppId = new(uint64)
	*filterInfo.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterInfo).Delete(AppDevelopmentInfoORM{}).Error; err != nil {
		return nil, err
	}
	filterInstallations := AppInstallationORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInstallations.MarketplaceAppId = new(uint64)
	*filterInstallations.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterInstallations).Delete(AppInstallationORM{}).Error; err != nil {
		return nil, err
	}
	filterPermissions := AppPermissionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPermissions.MarketplaceAppId = new(uint64)
	*filterPermissions.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterPermissions).Delete(AppPermissionORM{}).Error; err != nil {
		return nil, err
	}
	filterReviews := AppReviewORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterReviews.MarketplaceAppId = new(uint64)
	*filterReviews.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterReviews).Delete(AppReviewORM{}).Error; err != nil {
		return nil, err
	}
	filterVersions := AppVersionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVersions.MarketplaceAppId = new(uint64)
	*filterVersions.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterVersions).Delete(AppVersionORM{}).Error; err != nil {
		return nil, err
	}
	filterWebhooks := AppWebhookORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterWebhooks.MarketplaceAppId = new(uint64)
	*filterWebhooks.MarketplaceAppId = ormObj.Id
	if err = db.Where(filterWebhooks).Delete(AppWebhookORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MarketplaceAppORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMarketplaceApp executes a basic gorm update call with patch behavior
func DefaultPatchMarketplaceApp(ctx context.Context, in *MarketplaceApp, updateMask *field_mask.FieldMask, db *gorm.DB) (*MarketplaceApp, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MarketplaceApp
	var err error
	if hook, ok := interface{}(&pbObj).(MarketplaceAppWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMarketplaceApp(ctx, &MarketplaceApp{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MarketplaceAppWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMarketplaceApp(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MarketplaceAppWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMarketplaceApp(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MarketplaceAppWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MarketplaceAppWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MarketplaceApp, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MarketplaceApp, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MarketplaceApp, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MarketplaceApp, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMarketplaceApp executes a bulk gorm update call with patch behavior
func DefaultPatchSetMarketplaceApp(ctx context.Context, objects []*MarketplaceApp, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MarketplaceApp, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MarketplaceApp, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMarketplaceApp(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMarketplaceApp patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMarketplaceApp(ctx context.Context, patchee *MarketplaceApp, patcher *MarketplaceApp, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MarketplaceApp, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPublishedAt bool
	var updatedLastUpdated bool
	var updatedInfo bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"DeveloperId" {
			patchee.DeveloperId = patcher.DeveloperId
			continue
		}
		if f == prefix+"Category" {
			patchee.Category = patcher.Category
			continue
		}
		if f == prefix+"SupportedContractTypes" {
			patchee.SupportedContractTypes = patcher.SupportedContractTypes
			continue
		}
		if f == prefix+"Features" {
			patchee.Features = patcher.Features
			continue
		}
		if f == prefix+"PricingModel" {
			patchee.PricingModel = patcher.PricingModel
			continue
		}
		if f == prefix+"PricingTiers" {
			patchee.PricingTiers = patcher.PricingTiers
			continue
		}
		if f == prefix+"SupportedIntegrations" {
			patchee.SupportedIntegrations = patcher.SupportedIntegrations
			continue
		}
		if f == prefix+"IsVerified" {
			patchee.IsVerified = patcher.IsVerified
			continue
		}
		if f == prefix+"Rating" {
			patchee.Rating = patcher.Rating
			continue
		}
		if f == prefix+"InstallationCount" {
			patchee.InstallationCount = patcher.InstallationCount
			continue
		}
		if f == prefix+"RequiredPermissions" {
			patchee.RequiredPermissions = patcher.RequiredPermissions
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if f == prefix+"DocumentationUrl" {
			patchee.DocumentationUrl = patcher.DocumentationUrl
			continue
		}
		if f == prefix+"SupportEmail" {
			patchee.SupportEmail = patcher.SupportEmail
			continue
		}
		if f == prefix+"Screenshots" {
			patchee.Screenshots = patcher.Screenshots
			continue
		}
		if f == prefix+"PrivacyPolicyUrl" {
			patchee.PrivacyPolicyUrl = patcher.PrivacyPolicyUrl
			continue
		}
		if f == prefix+"TermsUrl" {
			patchee.TermsUrl = patcher.TermsUrl
			continue
		}
		if !updatedPublishedAt && strings.HasPrefix(f, prefix+"PublishedAt.") {
			if patcher.PublishedAt == nil {
				patchee.PublishedAt = nil
				continue
			}
			if patchee.PublishedAt == nil {
				patchee.PublishedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PublishedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.PublishedAt, patchee.PublishedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PublishedAt" {
			updatedPublishedAt = true
			patchee.PublishedAt = patcher.PublishedAt
			continue
		}
		if !updatedLastUpdated && strings.HasPrefix(f, prefix+"LastUpdated.") {
			if patcher.LastUpdated == nil {
				patchee.LastUpdated = nil
				continue
			}
			if patchee.LastUpdated == nil {
				patchee.LastUpdated = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUpdated."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUpdated, patchee.LastUpdated, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUpdated" {
			updatedLastUpdated = true
			patchee.LastUpdated = patcher.LastUpdated
			continue
		}
		if f == prefix+"Versions" {
			patchee.Versions = patcher.Versions
			continue
		}
		if f == prefix+"Installations" {
			patchee.Installations = patcher.Installations
			continue
		}
		if f == prefix+"Analytics" {
			patchee.Analytics = patcher.Analytics
			continue
		}
		if f == prefix+"Reviews" {
			patchee.Reviews = patcher.Reviews
			continue
		}
		if !updatedInfo && strings.HasPrefix(f, prefix+"Info.") {
			updatedInfo = true
			if patcher.Info == nil {
				patchee.Info = nil
				continue
			}
			if patchee.Info == nil {
				patchee.Info = &AppDevelopmentInfo{}
			}
			if o, err := DefaultApplyFieldMaskAppDevelopmentInfo(ctx, patchee.Info, patcher.Info, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Info.", db); err != nil {
				return nil, err
			} else {
				patchee.Info = o
			}
			continue
		}
		if f == prefix+"Info" {
			updatedInfo = true
			patchee.Info = patcher.Info
			continue
		}
		if f == prefix+"Webhooks" {
			patchee.Webhooks = patcher.Webhooks
			continue
		}
		if f == prefix+"Permissions" {
			patchee.Permissions = patcher.Permissions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMarketplaceApp executes a gorm list call
func DefaultListMarketplaceApp(ctx context.Context, db *gorm.DB) ([]*MarketplaceApp, error) {
	in := MarketplaceApp{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MarketplaceAppORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MarketplaceAppORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MarketplaceApp{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MarketplaceAppORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MarketplaceAppORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MarketplaceAppORM) error
}

// DefaultCreateDocumentSnapshot executes a basic gorm create call
func DefaultCreateDocumentSnapshot(ctx context.Context, in *DocumentSnapshot, db *gorm.DB) (*DocumentSnapshot, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentSnapshotORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDocumentSnapshot(ctx context.Context, in *DocumentSnapshot, db *gorm.DB) (*DocumentSnapshot, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DocumentSnapshotORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DocumentSnapshotORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DocumentSnapshotORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentSnapshot(ctx context.Context, in *DocumentSnapshot, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DocumentSnapshotORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DocumentSnapshotORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentSnapshotSet(ctx context.Context, in []*DocumentSnapshot, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DocumentSnapshotORM{})).(DocumentSnapshotORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DocumentSnapshotORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DocumentSnapshotORM{})).(DocumentSnapshotORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DocumentSnapshotORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DocumentSnapshot, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DocumentSnapshot, *gorm.DB) error
}

// DefaultStrictUpdateDocumentSnapshot clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDocumentSnapshot(ctx context.Context, in *DocumentSnapshot, db *gorm.DB) (*DocumentSnapshot, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDocumentSnapshot")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DocumentSnapshotORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DocumentSnapshotORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDocumentSnapshot executes a basic gorm update call with patch behavior
func DefaultPatchDocumentSnapshot(ctx context.Context, in *DocumentSnapshot, updateMask *field_mask.FieldMask, db *gorm.DB) (*DocumentSnapshot, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DocumentSnapshot
	var err error
	if hook, ok := interface{}(&pbObj).(DocumentSnapshotWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDocumentSnapshot(ctx, &DocumentSnapshot{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DocumentSnapshotWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDocumentSnapshot(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DocumentSnapshotWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDocumentSnapshot(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DocumentSnapshotWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DocumentSnapshotWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DocumentSnapshot, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DocumentSnapshot, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DocumentSnapshot, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DocumentSnapshot, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDocumentSnapshot executes a bulk gorm update call with patch behavior
func DefaultPatchSetDocumentSnapshot(ctx context.Context, objects []*DocumentSnapshot, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DocumentSnapshot, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DocumentSnapshot, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDocumentSnapshot(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDocumentSnapshot patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocumentSnapshot(ctx context.Context, patchee *DocumentSnapshot, patcher *DocumentSnapshot, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DocumentSnapshot, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FileId" {
			patchee.FileId = patcher.FileId
			continue
		}
		if f == prefix+"SnapshotHash" {
			patchee.SnapshotHash = patcher.SnapshotHash
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"AuthorId" {
			patchee.AuthorId = patcher.AuthorId
			continue
		}
		if f == prefix+"Reason" {
			patchee.Reason = patcher.Reason
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocumentSnapshot executes a gorm list call
func DefaultListDocumentSnapshot(ctx context.Context, db *gorm.DB) ([]*DocumentSnapshot, error) {
	in := DocumentSnapshot{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DocumentSnapshotORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentSnapshotORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DocumentSnapshot{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentSnapshotORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentSnapshotORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentSnapshotORM) error
}

// DefaultCreateTemplateVersion executes a basic gorm create call
func DefaultCreateTemplateVersion(ctx context.Context, in *TemplateVersion, db *gorm.DB) (*TemplateVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TemplateVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTemplateVersion(ctx context.Context, in *TemplateVersion, db *gorm.DB) (*TemplateVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TemplateVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TemplateVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TemplateVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTemplateVersion(ctx context.Context, in *TemplateVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TemplateVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TemplateVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTemplateVersionSet(ctx context.Context, in []*TemplateVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TemplateVersionORM{})).(TemplateVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TemplateVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TemplateVersionORM{})).(TemplateVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TemplateVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TemplateVersion, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TemplateVersion, *gorm.DB) error
}

// DefaultStrictUpdateTemplateVersion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTemplateVersion(ctx context.Context, in *TemplateVersion, db *gorm.DB) (*TemplateVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTemplateVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TemplateVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TemplateVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTemplateVersion executes a basic gorm update call with patch behavior
func DefaultPatchTemplateVersion(ctx context.Context, in *TemplateVersion, updateMask *field_mask.FieldMask, db *gorm.DB) (*TemplateVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TemplateVersion
	var err error
	if hook, ok := interface{}(&pbObj).(TemplateVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTemplateVersion(ctx, &TemplateVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TemplateVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTemplateVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TemplateVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTemplateVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TemplateVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TemplateVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TemplateVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TemplateVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TemplateVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TemplateVersion, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTemplateVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetTemplateVersion(ctx context.Context, objects []*TemplateVersion, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TemplateVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TemplateVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTemplateVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTemplateVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTemplateVersion(ctx context.Context, patchee *TemplateVersion, patcher *TemplateVersion, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TemplateVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TemplateId" {
			patchee.TemplateId = patcher.TemplateId
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"BaseContent" {
			patchee.BaseContent = patcher.BaseContent
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if f == prefix+"AuthorId" {
			patchee.AuthorId = patcher.AuthorId
			continue
		}
		if f == prefix+"ChangeDescription" {
			patchee.ChangeDescription = patcher.ChangeDescription
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTemplateVersion executes a gorm list call
func DefaultListTemplateVersion(ctx context.Context, db *gorm.DB) ([]*TemplateVersion, error) {
	in := TemplateVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TemplateVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplateVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TemplateVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TemplateVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplateVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TemplateVersionORM) error
}

// DefaultCreateExplanationBlock executes a basic gorm create call
func DefaultCreateExplanationBlock(ctx context.Context, in *ExplanationBlock, db *gorm.DB) (*ExplanationBlock, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExplanationBlockORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExplanationBlock(ctx context.Context, in *ExplanationBlock, db *gorm.DB) (*ExplanationBlock, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExplanationBlockORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExplanationBlockORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExplanationBlockORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExplanationBlock(ctx context.Context, in *ExplanationBlock, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExplanationBlockORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExplanationBlockORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExplanationBlockSet(ctx context.Context, in []*ExplanationBlock, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExplanationBlockORM{})).(ExplanationBlockORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExplanationBlockORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExplanationBlockORM{})).(ExplanationBlockORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExplanationBlockORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ExplanationBlock, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ExplanationBlock, *gorm.DB) error
}

// DefaultStrictUpdateExplanationBlock clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExplanationBlock(ctx context.Context, in *ExplanationBlock, db *gorm.DB) (*ExplanationBlock, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExplanationBlock")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExplanationBlockORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExplanationBlockORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExplanationBlock executes a basic gorm update call with patch behavior
func DefaultPatchExplanationBlock(ctx context.Context, in *ExplanationBlock, updateMask *field_mask.FieldMask, db *gorm.DB) (*ExplanationBlock, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ExplanationBlock
	var err error
	if hook, ok := interface{}(&pbObj).(ExplanationBlockWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExplanationBlock(ctx, &ExplanationBlock{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExplanationBlockWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExplanationBlock(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExplanationBlockWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExplanationBlock(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExplanationBlockWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExplanationBlockWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ExplanationBlock, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ExplanationBlock, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ExplanationBlock, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ExplanationBlock, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExplanationBlock executes a bulk gorm update call with patch behavior
func DefaultPatchSetExplanationBlock(ctx context.Context, objects []*ExplanationBlock, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ExplanationBlock, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ExplanationBlock, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExplanationBlock(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExplanationBlock patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExplanationBlock(ctx context.Context, patchee *ExplanationBlock, patcher *ExplanationBlock, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExplanationBlock, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TemplateId" {
			patchee.TemplateId = patcher.TemplateId
			continue
		}
		if f == prefix+"SectionIdentifier" {
			patchee.SectionIdentifier = patcher.SectionIdentifier
			continue
		}
		if f == prefix+"ExplanationText" {
			patchee.ExplanationText = patcher.ExplanationText
			continue
		}
		if f == prefix+"ComplexityLevel" {
			patchee.ComplexityLevel = patcher.ComplexityLevel
			continue
		}
		if f == prefix+"RelatedTerms" {
			patchee.RelatedTerms = patcher.RelatedTerms
			continue
		}
		if f == prefix+"LegalReferences" {
			patchee.LegalReferences = patcher.LegalReferences
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExplanationBlock executes a gorm list call
func DefaultListExplanationBlock(ctx context.Context, db *gorm.DB) ([]*ExplanationBlock, error) {
	in := ExplanationBlock{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExplanationBlockORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExplanationBlockORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExplanationBlock{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExplanationBlockORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExplanationBlockORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExplanationBlockORM) error
}

// DefaultCreateAIAssistanceLog executes a basic gorm create call
func DefaultCreateAIAssistanceLog(ctx context.Context, in *AIAssistanceLog, db *gorm.DB) (*AIAssistanceLog, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AIAssistanceLogORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAIAssistanceLog(ctx context.Context, in *AIAssistanceLog, db *gorm.DB) (*AIAssistanceLog, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AIAssistanceLogORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AIAssistanceLogORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AIAssistanceLogORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAIAssistanceLog(ctx context.Context, in *AIAssistanceLog, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AIAssistanceLogORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AIAssistanceLogORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAIAssistanceLogSet(ctx context.Context, in []*AIAssistanceLog, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AIAssistanceLogORM{})).(AIAssistanceLogORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AIAssistanceLogORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AIAssistanceLogORM{})).(AIAssistanceLogORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AIAssistanceLogORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AIAssistanceLog, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AIAssistanceLog, *gorm.DB) error
}

// DefaultStrictUpdateAIAssistanceLog clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAIAssistanceLog(ctx context.Context, in *AIAssistanceLog, db *gorm.DB) (*AIAssistanceLog, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAIAssistanceLog")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AIAssistanceLogORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AIAssistanceLogORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAIAssistanceLog executes a basic gorm update call with patch behavior
func DefaultPatchAIAssistanceLog(ctx context.Context, in *AIAssistanceLog, updateMask *field_mask.FieldMask, db *gorm.DB) (*AIAssistanceLog, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AIAssistanceLog
	var err error
	if hook, ok := interface{}(&pbObj).(AIAssistanceLogWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAIAssistanceLog(ctx, &AIAssistanceLog{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AIAssistanceLogWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAIAssistanceLog(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AIAssistanceLogWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAIAssistanceLog(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AIAssistanceLogWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AIAssistanceLogWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AIAssistanceLog, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AIAssistanceLog, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AIAssistanceLog, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AIAssistanceLog, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAIAssistanceLog executes a bulk gorm update call with patch behavior
func DefaultPatchSetAIAssistanceLog(ctx context.Context, objects []*AIAssistanceLog, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AIAssistanceLog, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AIAssistanceLog, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAIAssistanceLog(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAIAssistanceLog patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAIAssistanceLog(ctx context.Context, patchee *AIAssistanceLog, patcher *AIAssistanceLog, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AIAssistanceLog, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"DocumentId" {
			patchee.DocumentId = patcher.DocumentId
			continue
		}
		if f == prefix+"InteractionType" {
			patchee.InteractionType = patcher.InteractionType
			continue
		}
		if f == prefix+"UserQuery" {
			patchee.UserQuery = patcher.UserQuery
			continue
		}
		if f == prefix+"AiResponse" {
			patchee.AiResponse = patcher.AiResponse
			continue
		}
		if f == prefix+"Context" {
			patchee.Context = patcher.Context
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAIAssistanceLog executes a gorm list call
func DefaultListAIAssistanceLog(ctx context.Context, db *gorm.DB) ([]*AIAssistanceLog, error) {
	in := AIAssistanceLog{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AIAssistanceLogORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIAssistanceLogORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AIAssistanceLog{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AIAssistanceLogORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIAssistanceLogORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AIAssistanceLogORM) error
}

// DefaultCreateNegotiationHistory executes a basic gorm create call
func DefaultCreateNegotiationHistory(ctx context.Context, in *NegotiationHistory, db *gorm.DB) (*NegotiationHistory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NegotiationHistoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNegotiationHistory(ctx context.Context, in *NegotiationHistory, db *gorm.DB) (*NegotiationHistory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NegotiationHistoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NegotiationHistoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NegotiationHistoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNegotiationHistory(ctx context.Context, in *NegotiationHistory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NegotiationHistoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NegotiationHistoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNegotiationHistorySet(ctx context.Context, in []*NegotiationHistory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NegotiationHistoryORM{})).(NegotiationHistoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NegotiationHistoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NegotiationHistoryORM{})).(NegotiationHistoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NegotiationHistoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NegotiationHistory, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NegotiationHistory, *gorm.DB) error
}

// DefaultStrictUpdateNegotiationHistory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNegotiationHistory(ctx context.Context, in *NegotiationHistory, db *gorm.DB) (*NegotiationHistory, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNegotiationHistory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NegotiationHistoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterRounds := NegotiationRoundORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRounds.NegotiationHistoryId = new(uint64)
	*filterRounds.NegotiationHistoryId = ormObj.Id
	if err = db.Where(filterRounds).Delete(NegotiationRoundORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NegotiationHistoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNegotiationHistory executes a basic gorm update call with patch behavior
func DefaultPatchNegotiationHistory(ctx context.Context, in *NegotiationHistory, updateMask *field_mask.FieldMask, db *gorm.DB) (*NegotiationHistory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NegotiationHistory
	var err error
	if hook, ok := interface{}(&pbObj).(NegotiationHistoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNegotiationHistory(ctx, &NegotiationHistory{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NegotiationHistoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNegotiationHistory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NegotiationHistoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNegotiationHistory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NegotiationHistoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NegotiationHistoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NegotiationHistory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NegotiationHistory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NegotiationHistory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NegotiationHistory, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNegotiationHistory executes a bulk gorm update call with patch behavior
func DefaultPatchSetNegotiationHistory(ctx context.Context, objects []*NegotiationHistory, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NegotiationHistory, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NegotiationHistory, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNegotiationHistory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNegotiationHistory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNegotiationHistory(ctx context.Context, patchee *NegotiationHistory, patcher *NegotiationHistory, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NegotiationHistory, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartedAt bool
	var updatedLastUpdated bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"DocumentId" {
			patchee.DocumentId = patcher.DocumentId
			continue
		}
		if f == prefix+"Rounds" {
			patchee.Rounds = patcher.Rounds
			continue
		}
		if f == prefix+"CurrentStatus" {
			patchee.CurrentStatus = patcher.CurrentStatus
			continue
		}
		if !updatedStartedAt && strings.HasPrefix(f, prefix+"StartedAt.") {
			if patcher.StartedAt == nil {
				patchee.StartedAt = nil
				continue
			}
			if patchee.StartedAt == nil {
				patchee.StartedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartedAt, patchee.StartedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartedAt" {
			updatedStartedAt = true
			patchee.StartedAt = patcher.StartedAt
			continue
		}
		if !updatedLastUpdated && strings.HasPrefix(f, prefix+"LastUpdated.") {
			if patcher.LastUpdated == nil {
				patchee.LastUpdated = nil
				continue
			}
			if patchee.LastUpdated == nil {
				patchee.LastUpdated = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUpdated."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUpdated, patchee.LastUpdated, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUpdated" {
			updatedLastUpdated = true
			patchee.LastUpdated = patcher.LastUpdated
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNegotiationHistory executes a gorm list call
func DefaultListNegotiationHistory(ctx context.Context, db *gorm.DB) ([]*NegotiationHistory, error) {
	in := NegotiationHistory{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NegotiationHistoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationHistoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NegotiationHistory{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NegotiationHistoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationHistoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NegotiationHistoryORM) error
}

// DefaultCreateNegotiationRound executes a basic gorm create call
func DefaultCreateNegotiationRound(ctx context.Context, in *NegotiationRound, db *gorm.DB) (*NegotiationRound, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NegotiationRoundORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNegotiationRound(ctx context.Context, in *NegotiationRound, db *gorm.DB) (*NegotiationRound, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NegotiationRoundORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NegotiationRoundORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NegotiationRoundORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNegotiationRound(ctx context.Context, in *NegotiationRound, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NegotiationRoundORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NegotiationRoundORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNegotiationRoundSet(ctx context.Context, in []*NegotiationRound, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NegotiationRoundORM{})).(NegotiationRoundORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NegotiationRoundORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NegotiationRoundORM{})).(NegotiationRoundORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NegotiationRoundORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NegotiationRound, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NegotiationRound, *gorm.DB) error
}

// DefaultStrictUpdateNegotiationRound clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNegotiationRound(ctx context.Context, in *NegotiationRound, db *gorm.DB) (*NegotiationRound, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNegotiationRound")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NegotiationRoundORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NegotiationRoundORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNegotiationRound executes a basic gorm update call with patch behavior
func DefaultPatchNegotiationRound(ctx context.Context, in *NegotiationRound, updateMask *field_mask.FieldMask, db *gorm.DB) (*NegotiationRound, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NegotiationRound
	var err error
	if hook, ok := interface{}(&pbObj).(NegotiationRoundWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNegotiationRound(ctx, &NegotiationRound{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NegotiationRoundWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNegotiationRound(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NegotiationRoundWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNegotiationRound(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NegotiationRoundWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NegotiationRoundWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NegotiationRound, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NegotiationRound, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NegotiationRound, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NegotiationRound, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNegotiationRound executes a bulk gorm update call with patch behavior
func DefaultPatchSetNegotiationRound(ctx context.Context, objects []*NegotiationRound, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NegotiationRound, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NegotiationRound, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNegotiationRound(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNegotiationRound patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNegotiationRound(ctx context.Context, patchee *NegotiationRound, patcher *NegotiationRound, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NegotiationRound, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"HistoryId" {
			patchee.HistoryId = patcher.HistoryId
			continue
		}
		if f == prefix+"RoundNumber" {
			patchee.RoundNumber = patcher.RoundNumber
			continue
		}
		if f == prefix+"ProposerId" {
			patchee.ProposerId = patcher.ProposerId
			continue
		}
		if f == prefix+"ProposalContent" {
			patchee.ProposalContent = patcher.ProposalContent
			continue
		}
		if f == prefix+"ResponseContent" {
			patchee.ResponseContent = patcher.ResponseContent
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNegotiationRound executes a gorm list call
func DefaultListNegotiationRound(ctx context.Context, db *gorm.DB) ([]*NegotiationRound, error) {
	in := NegotiationRound{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NegotiationRoundORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NegotiationRoundORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NegotiationRound{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NegotiationRoundORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NegotiationRoundORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NegotiationRoundORM) error
}

// DefaultCreateChangeSet executes a basic gorm create call
func DefaultCreateChangeSet(ctx context.Context, in *ChangeSet, db *gorm.DB) (*ChangeSet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ChangeSetORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadChangeSet(ctx context.Context, in *ChangeSet, db *gorm.DB) (*ChangeSet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ChangeSetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ChangeSetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ChangeSetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteChangeSet(ctx context.Context, in *ChangeSet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ChangeSetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ChangeSetORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteChangeSetSet(ctx context.Context, in []*ChangeSet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ChangeSetORM{})).(ChangeSetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ChangeSetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ChangeSetORM{})).(ChangeSetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ChangeSetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ChangeSet, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ChangeSet, *gorm.DB) error
}

// DefaultStrictUpdateChangeSet clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateChangeSet(ctx context.Context, in *ChangeSet, db *gorm.DB) (*ChangeSet, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateChangeSet")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ChangeSetORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ChangeSetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchChangeSet executes a basic gorm update call with patch behavior
func DefaultPatchChangeSet(ctx context.Context, in *ChangeSet, updateMask *field_mask.FieldMask, db *gorm.DB) (*ChangeSet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ChangeSet
	var err error
	if hook, ok := interface{}(&pbObj).(ChangeSetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadChangeSet(ctx, &ChangeSet{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ChangeSetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskChangeSet(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ChangeSetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateChangeSet(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ChangeSetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ChangeSetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ChangeSet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ChangeSet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ChangeSet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ChangeSet, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetChangeSet executes a bulk gorm update call with patch behavior
func DefaultPatchSetChangeSet(ctx context.Context, objects []*ChangeSet, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ChangeSet, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ChangeSet, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchChangeSet(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskChangeSet patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskChangeSet(ctx context.Context, patchee *ChangeSet, patcher *ChangeSet, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ChangeSet, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"VersionId" {
			patchee.VersionId = patcher.VersionId
			continue
		}
		if f == prefix+"ChangeType" {
			patchee.ChangeType = patcher.ChangeType
			continue
		}
		if f == prefix+"ContentBefore" {
			patchee.ContentBefore = patcher.ContentBefore
			continue
		}
		if f == prefix+"ContentAfter" {
			patchee.ContentAfter = patcher.ContentAfter
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListChangeSet executes a gorm list call
func DefaultListChangeSet(ctx context.Context, db *gorm.DB) ([]*ChangeSet, error) {
	in := ChangeSet{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ChangeSetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChangeSetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ChangeSet{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ChangeSetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ChangeSetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ChangeSetORM) error
}

// DefaultCreateContextualSummary executes a basic gorm create call
func DefaultCreateContextualSummary(ctx context.Context, in *ContextualSummary, db *gorm.DB) (*ContextualSummary, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContextualSummaryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadContextualSummary(ctx context.Context, in *ContextualSummary, db *gorm.DB) (*ContextualSummary, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContextualSummaryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContextualSummaryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContextualSummaryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteContextualSummary(ctx context.Context, in *ContextualSummary, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContextualSummaryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ContextualSummaryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteContextualSummarySet(ctx context.Context, in []*ContextualSummary, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContextualSummaryORM{})).(ContextualSummaryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ContextualSummaryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContextualSummaryORM{})).(ContextualSummaryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContextualSummaryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ContextualSummary, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ContextualSummary, *gorm.DB) error
}

// DefaultStrictUpdateContextualSummary clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContextualSummary(ctx context.Context, in *ContextualSummary, db *gorm.DB) (*ContextualSummary, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContextualSummary")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ContextualSummaryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContextualSummaryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchContextualSummary executes a basic gorm update call with patch behavior
func DefaultPatchContextualSummary(ctx context.Context, in *ContextualSummary, updateMask *field_mask.FieldMask, db *gorm.DB) (*ContextualSummary, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ContextualSummary
	var err error
	if hook, ok := interface{}(&pbObj).(ContextualSummaryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContextualSummary(ctx, &ContextualSummary{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContextualSummaryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContextualSummary(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContextualSummaryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContextualSummary(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContextualSummaryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContextualSummaryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ContextualSummary, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ContextualSummary, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ContextualSummary, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ContextualSummary, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetContextualSummary executes a bulk gorm update call with patch behavior
func DefaultPatchSetContextualSummary(ctx context.Context, objects []*ContextualSummary, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ContextualSummary, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ContextualSummary, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchContextualSummary(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskContextualSummary patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContextualSummary(ctx context.Context, patchee *ContextualSummary, patcher *ContextualSummary, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ContextualSummary, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"VersionId" {
			patchee.VersionId = patcher.VersionId
			continue
		}
		if f == prefix+"SummaryType" {
			patchee.SummaryType = patcher.SummaryType
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"TargetAudience" {
			patchee.TargetAudience = patcher.TargetAudience
			continue
		}
		if f == prefix+"KeyPoints" {
			patchee.KeyPoints = patcher.KeyPoints
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContextualSummary executes a gorm list call
func DefaultListContextualSummary(ctx context.Context, db *gorm.DB) ([]*ContextualSummary, error) {
	in := ContextualSummary{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContextualSummaryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContextualSummaryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ContextualSummary{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContextualSummaryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContextualSummaryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ContextualSummaryORM) error
}

// DefaultCreateBranchMerge executes a basic gorm create call
func DefaultCreateBranchMerge(ctx context.Context, in *BranchMerge, db *gorm.DB) (*BranchMerge, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BranchMergeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBranchMerge(ctx context.Context, in *BranchMerge, db *gorm.DB) (*BranchMerge, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BranchMergeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BranchMergeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BranchMergeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBranchMerge(ctx context.Context, in *BranchMerge, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BranchMergeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BranchMergeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBranchMergeSet(ctx context.Context, in []*BranchMerge, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BranchMergeORM{})).(BranchMergeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BranchMergeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BranchMergeORM{})).(BranchMergeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BranchMergeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BranchMerge, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BranchMerge, *gorm.DB) error
}

// DefaultStrictUpdateBranchMerge clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBranchMerge(ctx context.Context, in *BranchMerge, db *gorm.DB) (*BranchMerge, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBranchMerge")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BranchMergeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BranchMergeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBranchMerge executes a basic gorm update call with patch behavior
func DefaultPatchBranchMerge(ctx context.Context, in *BranchMerge, updateMask *field_mask.FieldMask, db *gorm.DB) (*BranchMerge, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BranchMerge
	var err error
	if hook, ok := interface{}(&pbObj).(BranchMergeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBranchMerge(ctx, &BranchMerge{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BranchMergeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBranchMerge(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BranchMergeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBranchMerge(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BranchMergeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BranchMergeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BranchMerge, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BranchMerge, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BranchMerge, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BranchMerge, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBranchMerge executes a bulk gorm update call with patch behavior
func DefaultPatchSetBranchMerge(ctx context.Context, objects []*BranchMerge, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BranchMerge, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BranchMerge, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBranchMerge(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBranchMerge patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBranchMerge(ctx context.Context, patchee *BranchMerge, patcher *BranchMerge, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BranchMerge, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedCompletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"BranchId" {
			patchee.BranchId = patcher.BranchId
			continue
		}
		if f == prefix+"SourceBranch" {
			patchee.SourceBranch = patcher.SourceBranch
			continue
		}
		if f == prefix+"TargetBranch" {
			patchee.TargetBranch = patcher.TargetBranch
			continue
		}
		if f == prefix+"MergeStatus" {
			patchee.MergeStatus = patcher.MergeStatus
			continue
		}
		if f == prefix+"MergeStrategy" {
			patchee.MergeStrategy = patcher.MergeStrategy
			continue
		}
		if f == prefix+"Conflicts" {
			patchee.Conflicts = patcher.Conflicts
			continue
		}
		if f == prefix+"MergerId" {
			patchee.MergerId = patcher.MergerId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedCompletedAt && strings.HasPrefix(f, prefix+"CompletedAt.") {
			if patcher.CompletedAt == nil {
				patchee.CompletedAt = nil
				continue
			}
			if patchee.CompletedAt == nil {
				patchee.CompletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CompletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CompletedAt, patchee.CompletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CompletedAt" {
			updatedCompletedAt = true
			patchee.CompletedAt = patcher.CompletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBranchMerge executes a gorm list call
func DefaultListBranchMerge(ctx context.Context, db *gorm.DB) ([]*BranchMerge, error) {
	in := BranchMerge{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BranchMergeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchMergeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BranchMerge{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BranchMergeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchMergeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BranchMergeORM) error
}

// DefaultCreateSignatureBlock executes a basic gorm create call
func DefaultCreateSignatureBlock(ctx context.Context, in *SignatureBlock, db *gorm.DB) (*SignatureBlock, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SignatureBlockORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSignatureBlock(ctx context.Context, in *SignatureBlock, db *gorm.DB) (*SignatureBlock, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SignatureBlockORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SignatureBlockORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SignatureBlockORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSignatureBlock(ctx context.Context, in *SignatureBlock, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SignatureBlockORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SignatureBlockORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSignatureBlockSet(ctx context.Context, in []*SignatureBlock, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SignatureBlockORM{})).(SignatureBlockORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SignatureBlockORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SignatureBlockORM{})).(SignatureBlockORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SignatureBlockORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SignatureBlock, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SignatureBlock, *gorm.DB) error
}

// DefaultStrictUpdateSignatureBlock clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSignatureBlock(ctx context.Context, in *SignatureBlock, db *gorm.DB) (*SignatureBlock, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSignatureBlock")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SignatureBlockORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SignatureBlockORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSignatureBlock executes a basic gorm update call with patch behavior
func DefaultPatchSignatureBlock(ctx context.Context, in *SignatureBlock, updateMask *field_mask.FieldMask, db *gorm.DB) (*SignatureBlock, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SignatureBlock
	var err error
	if hook, ok := interface{}(&pbObj).(SignatureBlockWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSignatureBlock(ctx, &SignatureBlock{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SignatureBlockWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSignatureBlock(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SignatureBlockWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSignatureBlock(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SignatureBlockWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SignatureBlockWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SignatureBlock, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SignatureBlock, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SignatureBlock, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SignatureBlock, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSignatureBlock executes a bulk gorm update call with patch behavior
func DefaultPatchSetSignatureBlock(ctx context.Context, objects []*SignatureBlock, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SignatureBlock, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SignatureBlock, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSignatureBlock(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSignatureBlock patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSignatureBlock(ctx context.Context, patchee *SignatureBlock, patcher *SignatureBlock, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SignatureBlock, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedSignedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RequestId" {
			patchee.RequestId = patcher.RequestId
			continue
		}
		if f == prefix+"BlockType" {
			patchee.BlockType = patcher.BlockType
			continue
		}
		if f == prefix+"PageNumber" {
			patchee.PageNumber = patcher.PageNumber
			continue
		}
		if f == prefix+"XPosition" {
			patchee.XPosition = patcher.XPosition
			continue
		}
		if f == prefix+"YPosition" {
			patchee.YPosition = patcher.YPosition
			continue
		}
		if f == prefix+"Width" {
			patchee.Width = patcher.Width
			continue
		}
		if f == prefix+"Height" {
			patchee.Height = patcher.Height
			continue
		}
		if f == prefix+"IsRequired" {
			patchee.IsRequired = patcher.IsRequired
			continue
		}
		if f == prefix+"SignatureData" {
			patchee.SignatureData = patcher.SignatureData
			continue
		}
		if !updatedSignedAt && strings.HasPrefix(f, prefix+"SignedAt.") {
			if patcher.SignedAt == nil {
				patchee.SignedAt = nil
				continue
			}
			if patchee.SignedAt == nil {
				patchee.SignedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"SignedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.SignedAt, patchee.SignedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"SignedAt" {
			updatedSignedAt = true
			patchee.SignedAt = patcher.SignedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSignatureBlock executes a gorm list call
func DefaultListSignatureBlock(ctx context.Context, db *gorm.DB) ([]*SignatureBlock, error) {
	in := SignatureBlock{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SignatureBlockORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureBlockORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SignatureBlock{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SignatureBlockORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureBlockORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SignatureBlockORM) error
}

// DefaultCreateSignatureWorkflow executes a basic gorm create call
func DefaultCreateSignatureWorkflow(ctx context.Context, in *SignatureWorkflow, db *gorm.DB) (*SignatureWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SignatureWorkflowORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSignatureWorkflow(ctx context.Context, in *SignatureWorkflow, db *gorm.DB) (*SignatureWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SignatureWorkflowORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SignatureWorkflowORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SignatureWorkflowORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSignatureWorkflow(ctx context.Context, in *SignatureWorkflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SignatureWorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SignatureWorkflowORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSignatureWorkflowSet(ctx context.Context, in []*SignatureWorkflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SignatureWorkflowORM{})).(SignatureWorkflowORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SignatureWorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SignatureWorkflowORM{})).(SignatureWorkflowORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SignatureWorkflowORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SignatureWorkflow, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SignatureWorkflow, *gorm.DB) error
}

// DefaultStrictUpdateSignatureWorkflow clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSignatureWorkflow(ctx context.Context, in *SignatureWorkflow, db *gorm.DB) (*SignatureWorkflow, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSignatureWorkflow")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SignatureWorkflowORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SignatureWorkflowORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSignatureWorkflow executes a basic gorm update call with patch behavior
func DefaultPatchSignatureWorkflow(ctx context.Context, in *SignatureWorkflow, updateMask *field_mask.FieldMask, db *gorm.DB) (*SignatureWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SignatureWorkflow
	var err error
	if hook, ok := interface{}(&pbObj).(SignatureWorkflowWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSignatureWorkflow(ctx, &SignatureWorkflow{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SignatureWorkflowWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSignatureWorkflow(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SignatureWorkflowWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSignatureWorkflow(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SignatureWorkflowWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SignatureWorkflowWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SignatureWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SignatureWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SignatureWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SignatureWorkflow, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSignatureWorkflow executes a bulk gorm update call with patch behavior
func DefaultPatchSetSignatureWorkflow(ctx context.Context, objects []*SignatureWorkflow, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SignatureWorkflow, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SignatureWorkflow, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSignatureWorkflow(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSignatureWorkflow patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSignatureWorkflow(ctx context.Context, patchee *SignatureWorkflow, patcher *SignatureWorkflow, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SignatureWorkflow, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDeadline bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RequestId" {
			patchee.RequestId = patcher.RequestId
			continue
		}
		if f == prefix+"SigningOrder" {
			patchee.SigningOrder = patcher.SigningOrder
			continue
		}
		if f == prefix+"CurrentSigner" {
			patchee.CurrentSigner = patcher.CurrentSigner
			continue
		}
		if f == prefix+"WorkflowStatus" {
			patchee.WorkflowStatus = patcher.WorkflowStatus
			continue
		}
		if f == prefix+"ParallelSigning" {
			patchee.ParallelSigning = patcher.ParallelSigning
			continue
		}
		if f == prefix+"RequireAllSignatures" {
			patchee.RequireAllSignatures = patcher.RequireAllSignatures
			continue
		}
		if !updatedDeadline && strings.HasPrefix(f, prefix+"Deadline.") {
			if patcher.Deadline == nil {
				patchee.Deadline = nil
				continue
			}
			if patchee.Deadline == nil {
				patchee.Deadline = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Deadline."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Deadline, patchee.Deadline, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Deadline" {
			updatedDeadline = true
			patchee.Deadline = patcher.Deadline
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSignatureWorkflow executes a gorm list call
func DefaultListSignatureWorkflow(ctx context.Context, db *gorm.DB) ([]*SignatureWorkflow, error) {
	in := SignatureWorkflow{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SignatureWorkflowORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SignatureWorkflowORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SignatureWorkflow{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SignatureWorkflowORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SignatureWorkflowORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SignatureWorkflowORM) error
}

// DefaultCreateRiskAssessment executes a basic gorm create call
func DefaultCreateRiskAssessment(ctx context.Context, in *RiskAssessment, db *gorm.DB) (*RiskAssessment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RiskAssessmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadRiskAssessment(ctx context.Context, in *RiskAssessment, db *gorm.DB) (*RiskAssessment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := RiskAssessmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RiskAssessmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RiskAssessmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteRiskAssessment(ctx context.Context, in *RiskAssessment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RiskAssessmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RiskAssessmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteRiskAssessmentSet(ctx context.Context, in []*RiskAssessment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RiskAssessmentORM{})).(RiskAssessmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&RiskAssessmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RiskAssessmentORM{})).(RiskAssessmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RiskAssessmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*RiskAssessment, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*RiskAssessment, *gorm.DB) error
}

// DefaultStrictUpdateRiskAssessment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRiskAssessment(ctx context.Context, in *RiskAssessment, db *gorm.DB) (*RiskAssessment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRiskAssessment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &RiskAssessmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RiskAssessmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchRiskAssessment executes a basic gorm update call with patch behavior
func DefaultPatchRiskAssessment(ctx context.Context, in *RiskAssessment, updateMask *field_mask.FieldMask, db *gorm.DB) (*RiskAssessment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj RiskAssessment
	var err error
	if hook, ok := interface{}(&pbObj).(RiskAssessmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRiskAssessment(ctx, &RiskAssessment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RiskAssessmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRiskAssessment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RiskAssessmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRiskAssessment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RiskAssessmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RiskAssessmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *RiskAssessment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *RiskAssessment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *RiskAssessment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *RiskAssessment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetRiskAssessment executes a bulk gorm update call with patch behavior
func DefaultPatchSetRiskAssessment(ctx context.Context, objects []*RiskAssessment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*RiskAssessment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*RiskAssessment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchRiskAssessment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskRiskAssessment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRiskAssessment(ctx context.Context, patchee *RiskAssessment, patcher *RiskAssessment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*RiskAssessment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"IntelligenceId" {
			patchee.IntelligenceId = patcher.IntelligenceId
			continue
		}
		if f == prefix+"RiskType" {
			patchee.RiskType = patcher.RiskType
			continue
		}
		if f == prefix+"RiskScore" {
			patchee.RiskScore = patcher.RiskScore
			continue
		}
		if f == prefix+"AssessmentDetails" {
			patchee.AssessmentDetails = patcher.AssessmentDetails
			continue
		}
		if f == prefix+"MitigationSuggestions" {
			patchee.MitigationSuggestions = patcher.MitigationSuggestions
			continue
		}
		if f == prefix+"AssessorId" {
			patchee.AssessorId = patcher.AssessorId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRiskAssessment executes a gorm list call
func DefaultListRiskAssessment(ctx context.Context, db *gorm.DB) ([]*RiskAssessment, error) {
	in := RiskAssessment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RiskAssessmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RiskAssessmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*RiskAssessment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RiskAssessmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RiskAssessmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]RiskAssessmentORM) error
}

// DefaultCreateComplianceCheck executes a basic gorm create call
func DefaultCreateComplianceCheck(ctx context.Context, in *ComplianceCheck, db *gorm.DB) (*ComplianceCheck, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ComplianceCheckORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadComplianceCheck(ctx context.Context, in *ComplianceCheck, db *gorm.DB) (*ComplianceCheck, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ComplianceCheckORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ComplianceCheckORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ComplianceCheckORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteComplianceCheck(ctx context.Context, in *ComplianceCheck, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ComplianceCheckORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ComplianceCheckORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteComplianceCheckSet(ctx context.Context, in []*ComplianceCheck, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ComplianceCheckORM{})).(ComplianceCheckORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ComplianceCheckORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ComplianceCheckORM{})).(ComplianceCheckORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ComplianceCheckORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ComplianceCheck, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ComplianceCheck, *gorm.DB) error
}

// DefaultStrictUpdateComplianceCheck clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateComplianceCheck(ctx context.Context, in *ComplianceCheck, db *gorm.DB) (*ComplianceCheck, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateComplianceCheck")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ComplianceCheckORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ComplianceCheckORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchComplianceCheck executes a basic gorm update call with patch behavior
func DefaultPatchComplianceCheck(ctx context.Context, in *ComplianceCheck, updateMask *field_mask.FieldMask, db *gorm.DB) (*ComplianceCheck, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ComplianceCheck
	var err error
	if hook, ok := interface{}(&pbObj).(ComplianceCheckWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadComplianceCheck(ctx, &ComplianceCheck{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ComplianceCheckWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskComplianceCheck(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ComplianceCheckWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateComplianceCheck(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ComplianceCheckWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ComplianceCheckWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ComplianceCheck, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ComplianceCheck, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ComplianceCheck, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ComplianceCheck, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetComplianceCheck executes a bulk gorm update call with patch behavior
func DefaultPatchSetComplianceCheck(ctx context.Context, objects []*ComplianceCheck, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ComplianceCheck, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ComplianceCheck, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchComplianceCheck(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskComplianceCheck patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskComplianceCheck(ctx context.Context, patchee *ComplianceCheck, patcher *ComplianceCheck, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ComplianceCheck, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCheckDate bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"IntelligenceId" {
			patchee.IntelligenceId = patcher.IntelligenceId
			continue
		}
		if f == prefix+"ComplianceStandard" {
			patchee.ComplianceStandard = patcher.ComplianceStandard
			continue
		}
		if f == prefix+"CheckResult" {
			patchee.CheckResult = patcher.CheckResult
			continue
		}
		if f == prefix+"Violations" {
			patchee.Violations = patcher.Violations
			continue
		}
		if f == prefix+"RemediationSteps" {
			patchee.RemediationSteps = patcher.RemediationSteps
			continue
		}
		if !updatedCheckDate && strings.HasPrefix(f, prefix+"CheckDate.") {
			if patcher.CheckDate == nil {
				patchee.CheckDate = nil
				continue
			}
			if patchee.CheckDate == nil {
				patchee.CheckDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CheckDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CheckDate, patchee.CheckDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CheckDate" {
			updatedCheckDate = true
			patchee.CheckDate = patcher.CheckDate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListComplianceCheck executes a gorm list call
func DefaultListComplianceCheck(ctx context.Context, db *gorm.DB) ([]*ComplianceCheck, error) {
	in := ComplianceCheck{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ComplianceCheckORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComplianceCheckORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ComplianceCheck{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ComplianceCheckORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComplianceCheckORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ComplianceCheckORM) error
}

// DefaultCreateAppVersion executes a basic gorm create call
func DefaultCreateAppVersion(ctx context.Context, in *AppVersion, db *gorm.DB) (*AppVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppVersion(ctx context.Context, in *AppVersion, db *gorm.DB) (*AppVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppVersion(ctx context.Context, in *AppVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppVersionSet(ctx context.Context, in []*AppVersion, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppVersionORM{})).(AppVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppVersionORM{})).(AppVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppVersion, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppVersion, *gorm.DB) error
}

// DefaultStrictUpdateAppVersion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppVersion(ctx context.Context, in *AppVersion, db *gorm.DB) (*AppVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppVersion executes a basic gorm update call with patch behavior
func DefaultPatchAppVersion(ctx context.Context, in *AppVersion, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppVersion, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppVersion
	var err error
	if hook, ok := interface{}(&pbObj).(AppVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppVersion(ctx, &AppVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppVersion, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppVersion, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppVersion(ctx context.Context, objects []*AppVersion, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppVersion(ctx context.Context, patchee *AppVersion, patcher *AppVersion, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedReleaseDate bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"VersionNumber" {
			patchee.VersionNumber = patcher.VersionNumber
			continue
		}
		if f == prefix+"Changelog" {
			patchee.Changelog = patcher.Changelog
			continue
		}
		if f == prefix+"Requirements" {
			patchee.Requirements = patcher.Requirements
			continue
		}
		if f == prefix+"IsPublic" {
			patchee.IsPublic = patcher.IsPublic
			continue
		}
		if !updatedReleaseDate && strings.HasPrefix(f, prefix+"ReleaseDate.") {
			if patcher.ReleaseDate == nil {
				patchee.ReleaseDate = nil
				continue
			}
			if patchee.ReleaseDate == nil {
				patchee.ReleaseDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ReleaseDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ReleaseDate, patchee.ReleaseDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ReleaseDate" {
			updatedReleaseDate = true
			patchee.ReleaseDate = patcher.ReleaseDate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppVersion executes a gorm list call
func DefaultListAppVersion(ctx context.Context, db *gorm.DB) ([]*AppVersion, error) {
	in := AppVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppVersionORM) error
}

// DefaultCreateAppInstallation executes a basic gorm create call
func DefaultCreateAppInstallation(ctx context.Context, in *AppInstallation, db *gorm.DB) (*AppInstallation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppInstallationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppInstallation(ctx context.Context, in *AppInstallation, db *gorm.DB) (*AppInstallation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppInstallationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppInstallationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppInstallationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppInstallation(ctx context.Context, in *AppInstallation, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppInstallationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppInstallationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppInstallationSet(ctx context.Context, in []*AppInstallation, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppInstallationORM{})).(AppInstallationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppInstallationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppInstallationORM{})).(AppInstallationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppInstallationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppInstallation, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppInstallation, *gorm.DB) error
}

// DefaultStrictUpdateAppInstallation clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppInstallation(ctx context.Context, in *AppInstallation, db *gorm.DB) (*AppInstallation, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppInstallation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppInstallationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppInstallationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppInstallation executes a basic gorm update call with patch behavior
func DefaultPatchAppInstallation(ctx context.Context, in *AppInstallation, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppInstallation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppInstallation
	var err error
	if hook, ok := interface{}(&pbObj).(AppInstallationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppInstallation(ctx, &AppInstallation{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppInstallationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppInstallation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppInstallationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppInstallation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppInstallationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppInstallationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppInstallation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppInstallation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppInstallation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppInstallation, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppInstallation executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppInstallation(ctx context.Context, objects []*AppInstallation, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppInstallation, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppInstallation, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppInstallation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppInstallation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppInstallation(ctx context.Context, patchee *AppInstallation, patcher *AppInstallation, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppInstallation, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedInstalledAt bool
	var updatedLastUsed bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"WorkspaceId" {
			patchee.WorkspaceId = patcher.WorkspaceId
			continue
		}
		if f == prefix+"VersionInstalled" {
			patchee.VersionInstalled = patcher.VersionInstalled
			continue
		}
		if f == prefix+"Configuration" {
			patchee.Configuration = patcher.Configuration
			continue
		}
		if f == prefix+"InstallationStatus" {
			patchee.InstallationStatus = patcher.InstallationStatus
			continue
		}
		if !updatedInstalledAt && strings.HasPrefix(f, prefix+"InstalledAt.") {
			if patcher.InstalledAt == nil {
				patchee.InstalledAt = nil
				continue
			}
			if patchee.InstalledAt == nil {
				patchee.InstalledAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"InstalledAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.InstalledAt, patchee.InstalledAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"InstalledAt" {
			updatedInstalledAt = true
			patchee.InstalledAt = patcher.InstalledAt
			continue
		}
		if !updatedLastUsed && strings.HasPrefix(f, prefix+"LastUsed.") {
			if patcher.LastUsed == nil {
				patchee.LastUsed = nil
				continue
			}
			if patchee.LastUsed == nil {
				patchee.LastUsed = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUsed."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUsed, patchee.LastUsed, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUsed" {
			updatedLastUsed = true
			patchee.LastUsed = patcher.LastUsed
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppInstallation executes a gorm list call
func DefaultListAppInstallation(ctx context.Context, db *gorm.DB) ([]*AppInstallation, error) {
	in := AppInstallation{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppInstallationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppInstallationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppInstallation{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppInstallationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppInstallationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppInstallationORM) error
}

// DefaultCreateAppAnalytics executes a basic gorm create call
func DefaultCreateAppAnalytics(ctx context.Context, in *AppAnalytics, db *gorm.DB) (*AppAnalytics, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppAnalyticsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppAnalytics(ctx context.Context, in *AppAnalytics, db *gorm.DB) (*AppAnalytics, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppAnalyticsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppAnalyticsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppAnalyticsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppAnalytics(ctx context.Context, in *AppAnalytics, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppAnalyticsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppAnalyticsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppAnalyticsSet(ctx context.Context, in []*AppAnalytics, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppAnalyticsORM{})).(AppAnalyticsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppAnalyticsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppAnalyticsORM{})).(AppAnalyticsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppAnalyticsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppAnalytics, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppAnalytics, *gorm.DB) error
}

// DefaultStrictUpdateAppAnalytics clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppAnalytics(ctx context.Context, in *AppAnalytics, db *gorm.DB) (*AppAnalytics, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppAnalytics")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppAnalyticsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppAnalyticsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppAnalytics executes a basic gorm update call with patch behavior
func DefaultPatchAppAnalytics(ctx context.Context, in *AppAnalytics, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppAnalytics, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppAnalytics
	var err error
	if hook, ok := interface{}(&pbObj).(AppAnalyticsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppAnalytics(ctx, &AppAnalytics{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppAnalyticsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppAnalytics(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppAnalyticsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppAnalytics(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppAnalyticsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppAnalyticsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppAnalytics, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppAnalytics, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppAnalytics, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppAnalytics, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppAnalytics executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppAnalytics(ctx context.Context, objects []*AppAnalytics, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppAnalytics, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppAnalytics, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppAnalytics(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppAnalytics patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppAnalytics(ctx context.Context, patchee *AppAnalytics, patcher *AppAnalytics, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppAnalytics, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRecordedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"MetricName" {
			patchee.MetricName = patcher.MetricName
			continue
		}
		if f == prefix+"MetricValue" {
			patchee.MetricValue = patcher.MetricValue
			continue
		}
		if f == prefix+"Dimensions" {
			patchee.Dimensions = patcher.Dimensions
			continue
		}
		if !updatedRecordedAt && strings.HasPrefix(f, prefix+"RecordedAt.") {
			if patcher.RecordedAt == nil {
				patchee.RecordedAt = nil
				continue
			}
			if patchee.RecordedAt == nil {
				patchee.RecordedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RecordedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RecordedAt, patchee.RecordedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RecordedAt" {
			updatedRecordedAt = true
			patchee.RecordedAt = patcher.RecordedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppAnalytics executes a gorm list call
func DefaultListAppAnalytics(ctx context.Context, db *gorm.DB) ([]*AppAnalytics, error) {
	in := AppAnalytics{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppAnalyticsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppAnalyticsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppAnalytics{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppAnalyticsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppAnalyticsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppAnalyticsORM) error
}

// DefaultCreateAppReview executes a basic gorm create call
func DefaultCreateAppReview(ctx context.Context, in *AppReview, db *gorm.DB) (*AppReview, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppReviewORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppReview(ctx context.Context, in *AppReview, db *gorm.DB) (*AppReview, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppReviewORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppReviewORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppReviewORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppReview(ctx context.Context, in *AppReview, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppReviewORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppReviewORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppReviewSet(ctx context.Context, in []*AppReview, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppReviewORM{})).(AppReviewORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppReviewORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppReviewORM{})).(AppReviewORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppReviewORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppReview, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppReview, *gorm.DB) error
}

// DefaultStrictUpdateAppReview clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppReview(ctx context.Context, in *AppReview, db *gorm.DB) (*AppReview, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppReview")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppReviewORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppReviewORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppReview executes a basic gorm update call with patch behavior
func DefaultPatchAppReview(ctx context.Context, in *AppReview, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppReview, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppReview
	var err error
	if hook, ok := interface{}(&pbObj).(AppReviewWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppReview(ctx, &AppReview{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppReviewWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppReview(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppReviewWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppReview(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppReviewWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppReviewWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppReview, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppReviewWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppReview, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppReviewWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppReview, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppReviewWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppReview, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppReview executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppReview(ctx context.Context, objects []*AppReview, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppReview, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppReview, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppReview(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppReview patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppReview(ctx context.Context, patchee *AppReview, patcher *AppReview, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppReview, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"ReviewerId" {
			patchee.ReviewerId = patcher.ReviewerId
			continue
		}
		if f == prefix+"Rating" {
			patchee.Rating = patcher.Rating
			continue
		}
		if f == prefix+"ReviewText" {
			patchee.ReviewText = patcher.ReviewText
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppReview executes a gorm list call
func DefaultListAppReview(ctx context.Context, db *gorm.DB) ([]*AppReview, error) {
	in := AppReview{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppReviewORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppReviewORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppReview{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppReviewORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppReviewORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppReviewORM) error
}

// DefaultCreateAppDevelopmentInfo executes a basic gorm create call
func DefaultCreateAppDevelopmentInfo(ctx context.Context, in *AppDevelopmentInfo, db *gorm.DB) (*AppDevelopmentInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppDevelopmentInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppDevelopmentInfo(ctx context.Context, in *AppDevelopmentInfo, db *gorm.DB) (*AppDevelopmentInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppDevelopmentInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppDevelopmentInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppDevelopmentInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppDevelopmentInfo(ctx context.Context, in *AppDevelopmentInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppDevelopmentInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppDevelopmentInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppDevelopmentInfoSet(ctx context.Context, in []*AppDevelopmentInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppDevelopmentInfoORM{})).(AppDevelopmentInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppDevelopmentInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppDevelopmentInfoORM{})).(AppDevelopmentInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppDevelopmentInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppDevelopmentInfo, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppDevelopmentInfo, *gorm.DB) error
}

// DefaultStrictUpdateAppDevelopmentInfo clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppDevelopmentInfo(ctx context.Context, in *AppDevelopmentInfo, db *gorm.DB) (*AppDevelopmentInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppDevelopmentInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppDevelopmentInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppDevelopmentInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppDevelopmentInfo executes a basic gorm update call with patch behavior
func DefaultPatchAppDevelopmentInfo(ctx context.Context, in *AppDevelopmentInfo, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppDevelopmentInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppDevelopmentInfo
	var err error
	if hook, ok := interface{}(&pbObj).(AppDevelopmentInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppDevelopmentInfo(ctx, &AppDevelopmentInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppDevelopmentInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppDevelopmentInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppDevelopmentInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppDevelopmentInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppDevelopmentInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppDevelopmentInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppDevelopmentInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppDevelopmentInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppDevelopmentInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppDevelopmentInfo, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppDevelopmentInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppDevelopmentInfo(ctx context.Context, objects []*AppDevelopmentInfo, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppDevelopmentInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppDevelopmentInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppDevelopmentInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppDevelopmentInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppDevelopmentInfo(ctx context.Context, patchee *AppDevelopmentInfo, patcher *AppDevelopmentInfo, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppDevelopmentInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastSecurityAudit bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"SupportedLanguages" {
			patchee.SupportedLanguages = patcher.SupportedLanguages
			continue
		}
		if f == prefix+"SdkFeatures" {
			patchee.SdkFeatures = patcher.SdkFeatures
			continue
		}
		if f == prefix+"TestCoverage" {
			patchee.TestCoverage = patcher.TestCoverage
			continue
		}
		if f == prefix+"SecurityScans" {
			patchee.SecurityScans = patcher.SecurityScans
			continue
		}
		if f == prefix+"PerformanceMetrics" {
			patchee.PerformanceMetrics = patcher.PerformanceMetrics
			continue
		}
		if f == prefix+"DevelopmentStatus" {
			patchee.DevelopmentStatus = patcher.DevelopmentStatus
			continue
		}
		if f == prefix+"KnownIssues" {
			patchee.KnownIssues = patcher.KnownIssues
			continue
		}
		if f == prefix+"RoadmapUrl" {
			patchee.RoadmapUrl = patcher.RoadmapUrl
			continue
		}
		if !updatedLastSecurityAudit && strings.HasPrefix(f, prefix+"LastSecurityAudit.") {
			if patcher.LastSecurityAudit == nil {
				patchee.LastSecurityAudit = nil
				continue
			}
			if patchee.LastSecurityAudit == nil {
				patchee.LastSecurityAudit = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastSecurityAudit."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastSecurityAudit, patchee.LastSecurityAudit, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastSecurityAudit" {
			updatedLastSecurityAudit = true
			patchee.LastSecurityAudit = patcher.LastSecurityAudit
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppDevelopmentInfo executes a gorm list call
func DefaultListAppDevelopmentInfo(ctx context.Context, db *gorm.DB) ([]*AppDevelopmentInfo, error) {
	in := AppDevelopmentInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppDevelopmentInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppDevelopmentInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppDevelopmentInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppDevelopmentInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppDevelopmentInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppDevelopmentInfoORM) error
}

// DefaultCreateAppWebhook executes a basic gorm create call
func DefaultCreateAppWebhook(ctx context.Context, in *AppWebhook, db *gorm.DB) (*AppWebhook, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppWebhookORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppWebhook(ctx context.Context, in *AppWebhook, db *gorm.DB) (*AppWebhook, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppWebhookORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppWebhookORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppWebhookORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppWebhook(ctx context.Context, in *AppWebhook, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppWebhookORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppWebhookORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppWebhookSet(ctx context.Context, in []*AppWebhook, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppWebhookORM{})).(AppWebhookORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppWebhookORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppWebhookORM{})).(AppWebhookORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppWebhookORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppWebhook, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppWebhook, *gorm.DB) error
}

// DefaultStrictUpdateAppWebhook clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppWebhook(ctx context.Context, in *AppWebhook, db *gorm.DB) (*AppWebhook, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppWebhook")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppWebhookORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppWebhookORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppWebhook executes a basic gorm update call with patch behavior
func DefaultPatchAppWebhook(ctx context.Context, in *AppWebhook, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppWebhook, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppWebhook
	var err error
	if hook, ok := interface{}(&pbObj).(AppWebhookWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppWebhook(ctx, &AppWebhook{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppWebhookWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppWebhook(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppWebhookWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppWebhook(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppWebhookWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppWebhookWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppWebhook, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppWebhook, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppWebhook, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppWebhook, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppWebhook executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppWebhook(ctx context.Context, objects []*AppWebhook, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppWebhook, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppWebhook, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppWebhook(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppWebhook patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppWebhook(ctx context.Context, patchee *AppWebhook, patcher *AppWebhook, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppWebhook, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastTriggered bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"Url" {
			patchee.Url = patcher.Url
			continue
		}
		if f == prefix+"SubscribedEvents" {
			patchee.SubscribedEvents = patcher.SubscribedEvents
			continue
		}
		if f == prefix+"SecretKey" {
			patchee.SecretKey = patcher.SecretKey
			continue
		}
		if f == prefix+"RetryCount" {
			patchee.RetryCount = patcher.RetryCount
			continue
		}
		if f == prefix+"TimeoutSeconds" {
			patchee.TimeoutSeconds = patcher.TimeoutSeconds
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Headers" {
			patchee.Headers = patcher.Headers
			continue
		}
		if !updatedLastTriggered && strings.HasPrefix(f, prefix+"LastTriggered.") {
			if patcher.LastTriggered == nil {
				patchee.LastTriggered = nil
				continue
			}
			if patchee.LastTriggered == nil {
				patchee.LastTriggered = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastTriggered."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastTriggered, patchee.LastTriggered, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastTriggered" {
			updatedLastTriggered = true
			patchee.LastTriggered = patcher.LastTriggered
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppWebhook executes a gorm list call
func DefaultListAppWebhook(ctx context.Context, db *gorm.DB) ([]*AppWebhook, error) {
	in := AppWebhook{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppWebhookORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppWebhookORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppWebhook{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppWebhookORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppWebhookORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppWebhookORM) error
}

// DefaultCreateAppPermission executes a basic gorm create call
func DefaultCreateAppPermission(ctx context.Context, in *AppPermission, db *gorm.DB) (*AppPermission, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppPermissionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAppPermission(ctx context.Context, in *AppPermission, db *gorm.DB) (*AppPermission, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AppPermissionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppPermissionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppPermissionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAppPermission(ctx context.Context, in *AppPermission, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppPermissionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppPermissionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAppPermissionSet(ctx context.Context, in []*AppPermission, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppPermissionORM{})).(AppPermissionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AppPermissionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppPermissionORM{})).(AppPermissionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppPermissionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppPermission, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppPermission, *gorm.DB) error
}

// DefaultStrictUpdateAppPermission clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppPermission(ctx context.Context, in *AppPermission, db *gorm.DB) (*AppPermission, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppPermission")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AppPermissionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppPermissionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAppPermission executes a basic gorm update call with patch behavior
func DefaultPatchAppPermission(ctx context.Context, in *AppPermission, updateMask *field_mask.FieldMask, db *gorm.DB) (*AppPermission, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AppPermission
	var err error
	if hook, ok := interface{}(&pbObj).(AppPermissionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppPermission(ctx, &AppPermission{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppPermissionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppPermission(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppPermissionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppPermission(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppPermissionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppPermissionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppPermission, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppPermission, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppPermission, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppPermission, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAppPermission executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppPermission(ctx context.Context, objects []*AppPermission, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AppPermission, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppPermission, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppPermission(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppPermission patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppPermission(ctx context.Context, patchee *AppPermission, patcher *AppPermission, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AppPermission, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"Scope" {
			patchee.Scope = patcher.Scope
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"IsRequired" {
			patchee.IsRequired = patcher.IsRequired
			continue
		}
		if f == prefix+"AccessLevels" {
			patchee.AccessLevels = patcher.AccessLevels
			continue
		}
		if f == prefix+"Constraints" {
			patchee.Constraints = patcher.Constraints
			continue
		}
		if f == prefix+"RequiresApproval" {
			patchee.RequiresApproval = patcher.RequiresApproval
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppPermission executes a gorm list call
func DefaultListAppPermission(ctx context.Context, db *gorm.DB) ([]*AppPermission, error) {
	in := AppPermission{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppPermissionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppPermissionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppPermission{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppPermissionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AppPermissionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AppPermissionORM) error
}

// DefaultCreateBranchPolicy executes a basic gorm create call
func DefaultCreateBranchPolicy(ctx context.Context, in *BranchPolicy, db *gorm.DB) (*BranchPolicy, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BranchPolicyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBranchPolicy(ctx context.Context, in *BranchPolicy, db *gorm.DB) (*BranchPolicy, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BranchPolicyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BranchPolicyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BranchPolicyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBranchPolicy(ctx context.Context, in *BranchPolicy, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BranchPolicyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BranchPolicyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBranchPolicySet(ctx context.Context, in []*BranchPolicy, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BranchPolicyORM{})).(BranchPolicyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BranchPolicyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BranchPolicyORM{})).(BranchPolicyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BranchPolicyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BranchPolicy, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BranchPolicy, *gorm.DB) error
}

// DefaultStrictUpdateBranchPolicy clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBranchPolicy(ctx context.Context, in *BranchPolicy, db *gorm.DB) (*BranchPolicy, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBranchPolicy")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BranchPolicyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BranchPolicyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBranchPolicy executes a basic gorm update call with patch behavior
func DefaultPatchBranchPolicy(ctx context.Context, in *BranchPolicy, updateMask *field_mask.FieldMask, db *gorm.DB) (*BranchPolicy, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BranchPolicy
	var err error
	if hook, ok := interface{}(&pbObj).(BranchPolicyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBranchPolicy(ctx, &BranchPolicy{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BranchPolicyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBranchPolicy(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BranchPolicyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBranchPolicy(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BranchPolicyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BranchPolicyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BranchPolicy, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BranchPolicy, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BranchPolicy, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BranchPolicy, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBranchPolicy executes a bulk gorm update call with patch behavior
func DefaultPatchSetBranchPolicy(ctx context.Context, objects []*BranchPolicy, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BranchPolicy, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BranchPolicy, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBranchPolicy(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBranchPolicy patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBranchPolicy(ctx context.Context, patchee *BranchPolicy, patcher *BranchPolicy, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BranchPolicy, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"BranchId" {
			patchee.BranchId = patcher.BranchId
			continue
		}
		if f == prefix+"RequiredApprovers" {
			patchee.RequiredApprovers = patcher.RequiredApprovers
			continue
		}
		if f == prefix+"MinimumApprovals" {
			patchee.MinimumApprovals = patcher.MinimumApprovals
			continue
		}
		if f == prefix+"EnforceLinearHistory" {
			patchee.EnforceLinearHistory = patcher.EnforceLinearHistory
			continue
		}
		if f == prefix+"AllowForcePush" {
			patchee.AllowForcePush = patcher.AllowForcePush
			continue
		}
		if f == prefix+"ProtectedPaths" {
			patchee.ProtectedPaths = patcher.ProtectedPaths
			continue
		}
		if f == prefix+"MergeRules" {
			patchee.MergeRules = patcher.MergeRules
			continue
		}
		if f == prefix+"AutomatedChecks" {
			patchee.AutomatedChecks = patcher.AutomatedChecks
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBranchPolicy executes a gorm list call
func DefaultListBranchPolicy(ctx context.Context, db *gorm.DB) ([]*BranchPolicy, error) {
	in := BranchPolicy{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BranchPolicyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BranchPolicyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BranchPolicy{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BranchPolicyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BranchPolicyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BranchPolicyORM) error
}

// DefaultCreateMergeRequest executes a basic gorm create call
func DefaultCreateMergeRequest(ctx context.Context, in *MergeRequest, db *gorm.DB) (*MergeRequest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MergeRequestORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMergeRequest(ctx context.Context, in *MergeRequest, db *gorm.DB) (*MergeRequest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MergeRequestORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MergeRequestORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MergeRequestORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMergeRequest(ctx context.Context, in *MergeRequest, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MergeRequestORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MergeRequestORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMergeRequestSet(ctx context.Context, in []*MergeRequest, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MergeRequestORM{})).(MergeRequestORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MergeRequestORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MergeRequestORM{})).(MergeRequestORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MergeRequestORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MergeRequest, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MergeRequest, *gorm.DB) error
}

// DefaultStrictUpdateMergeRequest clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMergeRequest(ctx context.Context, in *MergeRequest, db *gorm.DB) (*MergeRequest, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMergeRequest")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MergeRequestORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MergeRequestORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMergeRequest executes a basic gorm update call with patch behavior
func DefaultPatchMergeRequest(ctx context.Context, in *MergeRequest, updateMask *field_mask.FieldMask, db *gorm.DB) (*MergeRequest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MergeRequest
	var err error
	if hook, ok := interface{}(&pbObj).(MergeRequestWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMergeRequest(ctx, &MergeRequest{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MergeRequestWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMergeRequest(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MergeRequestWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMergeRequest(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MergeRequestWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MergeRequestWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MergeRequest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MergeRequest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MergeRequest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MergeRequest, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMergeRequest executes a bulk gorm update call with patch behavior
func DefaultPatchSetMergeRequest(ctx context.Context, objects []*MergeRequest, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MergeRequest, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MergeRequest, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMergeRequest(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMergeRequest patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMergeRequest(ctx context.Context, patchee *MergeRequest, patcher *MergeRequest, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MergeRequest, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"SourceBranchId" {
			patchee.SourceBranchId = patcher.SourceBranchId
			continue
		}
		if f == prefix+"TargetBranchId" {
			patchee.TargetBranchId = patcher.TargetBranchId
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"AuthorId" {
			patchee.AuthorId = patcher.AuthorId
			continue
		}
		if f == prefix+"Reviewers" {
			patchee.Reviewers = patcher.Reviewers
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Labels" {
			patchee.Labels = patcher.Labels
			continue
		}
		if f == prefix+"HasConflicts" {
			patchee.HasConflicts = patcher.HasConflicts
			continue
		}
		if f == prefix+"AutomatedCheckResults" {
			patchee.AutomatedCheckResults = patcher.AutomatedCheckResults
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMergeRequest executes a gorm list call
func DefaultListMergeRequest(ctx context.Context, db *gorm.DB) ([]*MergeRequest, error) {
	in := MergeRequest{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MergeRequestORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeRequestORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MergeRequest{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MergeRequestORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeRequestORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MergeRequestORM) error
}
