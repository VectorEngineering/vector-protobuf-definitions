// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: workspace_service/v1/schema.proto

package workspace_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Auth0UserId

	// no validation rules for Email

	// no validation rules for BaseDirectory

	// no validation rules for BucketName

	// no validation rules for Region

	// no validation rules for OrgId

	// no validation rules for TenantId

	// no validation rules for MfaEnabled

	// no validation rules for ComplianceLevel

	// no validation rules for Preferences

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetWorkspaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("Workspaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("Workspaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccountValidationError{
					field:  fmt.Sprintf("Workspaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDataProfiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("DataProfiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("DataProfiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccountValidationError{
					field:  fmt.Sprintf("DataProfiles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on DataProfile with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataProfile with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataProfileMultiError, or
// nil if none found.
func (m *DataProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *DataProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ProfileType

	// no validation rules for DataFields

	// no validation rules for IsDefault

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataProfileValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataProfileValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataProfileValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataProfileValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataProfileValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataProfileValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DataProfileMultiError(errors)
	}

	return nil
}

// DataProfileMultiError is an error wrapping multiple validation errors
// returned by DataProfile.ValidateAll() if the designated constraints aren't met.
type DataProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataProfileMultiError) AllErrors() []error { return m }

// DataProfileValidationError is the validation error returned by
// DataProfile.Validate if the designated constraints aren't met.
type DataProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataProfileValidationError) ErrorName() string { return "DataProfileValidationError" }

// Error satisfies the builtin error interface
func (e DataProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataProfileValidationError{}

// Validate checks the field values on Workspace with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Workspace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Workspace with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkspaceMultiError, or nil
// if none found.
func (m *Workspace) ValidateAll() error {
	return m.validate(true)
}

func (m *Workspace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for UniqueIdentifier

	// no validation rules for S3BucketName

	// no validation rules for S3FolderPath

	// no validation rules for StorageQuota

	// no validation rules for UsedStorage

	// no validation rules for AllowPublicSharing

	// no validation rules for RequireApproval

	// no validation rules for GdprCompliant

	// no validation rules for HipaaCompliant

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFolders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Folders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Folders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkspaceValidationError{
					field:  fmt.Sprintf("Folders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkspaceValidationError{
					field:  fmt.Sprintf("Templates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSharing() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Sharing[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Sharing[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkspaceValidationError{
					field:  fmt.Sprintf("Sharing[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Activities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Activities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkspaceValidationError{
					field:  fmt.Sprintf("Activities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCompliance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Compliance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("Compliance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkspaceValidationError{
					field:  fmt.Sprintf("Compliance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstalledApps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("InstalledApps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkspaceValidationError{
						field:  fmt.Sprintf("InstalledApps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkspaceValidationError{
					field:  fmt.Sprintf("InstalledApps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkspaceMultiError(errors)
	}

	return nil
}

// WorkspaceMultiError is an error wrapping multiple validation errors returned
// by Workspace.ValidateAll() if the designated constraints aren't met.
type WorkspaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkspaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkspaceMultiError) AllErrors() []error { return m }

// WorkspaceValidationError is the validation error returned by
// Workspace.Validate if the designated constraints aren't met.
type WorkspaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkspaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkspaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkspaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkspaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkspaceValidationError) ErrorName() string { return "WorkspaceValidationError" }

// Error satisfies the builtin error interface
func (e WorkspaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkspace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkspaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkspaceValidationError{}

// Validate checks the field values on WorkspaceSharing with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkspaceSharing) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkspaceSharing with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkspaceSharingMultiError, or nil if none found.
func (m *WorkspaceSharing) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkspaceSharing) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SharedWithEmail

	// no validation rules for PermissionLevel

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceSharingValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceSharingValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceSharingValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceSharingValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceSharingValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceSharingValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceSharingValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceSharingValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceSharingValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkspaceSharingMultiError(errors)
	}

	return nil
}

// WorkspaceSharingMultiError is an error wrapping multiple validation errors
// returned by WorkspaceSharing.ValidateAll() if the designated constraints
// aren't met.
type WorkspaceSharingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkspaceSharingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkspaceSharingMultiError) AllErrors() []error { return m }

// WorkspaceSharingValidationError is the validation error returned by
// WorkspaceSharing.Validate if the designated constraints aren't met.
type WorkspaceSharingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkspaceSharingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkspaceSharingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkspaceSharingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkspaceSharingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkspaceSharingValidationError) ErrorName() string { return "WorkspaceSharingValidationError" }

// Error satisfies the builtin error interface
func (e WorkspaceSharingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkspaceSharing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkspaceSharingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkspaceSharingValidationError{}

// Validate checks the field values on WorkspaceActivity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkspaceActivity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkspaceActivity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkspaceActivityMultiError, or nil if none found.
func (m *WorkspaceActivity) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkspaceActivity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ActivityType

	// no validation rules for UserId

	// no validation rules for Description

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceActivityValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceActivityValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceActivityValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkspaceActivityMultiError(errors)
	}

	return nil
}

// WorkspaceActivityMultiError is an error wrapping multiple validation errors
// returned by WorkspaceActivity.ValidateAll() if the designated constraints
// aren't met.
type WorkspaceActivityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkspaceActivityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkspaceActivityMultiError) AllErrors() []error { return m }

// WorkspaceActivityValidationError is the validation error returned by
// WorkspaceActivity.Validate if the designated constraints aren't met.
type WorkspaceActivityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkspaceActivityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkspaceActivityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkspaceActivityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkspaceActivityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkspaceActivityValidationError) ErrorName() string {
	return "WorkspaceActivityValidationError"
}

// Error satisfies the builtin error interface
func (e WorkspaceActivityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkspaceActivity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkspaceActivityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkspaceActivityValidationError{}

// Validate checks the field values on WorkspaceCompliance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WorkspaceCompliance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkspaceCompliance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkspaceComplianceMultiError, or nil if none found.
func (m *WorkspaceCompliance) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkspaceCompliance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ComplianceType

	// no validation rules for Status

	// no validation rules for CertificationId

	if all {
		switch v := interface{}(m.GetValidUntil()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceComplianceValidationError{
					field:  "ValidUntil",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceComplianceValidationError{
					field:  "ValidUntil",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidUntil()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceComplianceValidationError{
				field:  "ValidUntil",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceComplianceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceComplianceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceComplianceValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkspaceComplianceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkspaceComplianceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkspaceComplianceValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkspaceComplianceMultiError(errors)
	}

	return nil
}

// WorkspaceComplianceMultiError is an error wrapping multiple validation
// errors returned by WorkspaceCompliance.ValidateAll() if the designated
// constraints aren't met.
type WorkspaceComplianceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkspaceComplianceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkspaceComplianceMultiError) AllErrors() []error { return m }

// WorkspaceComplianceValidationError is the validation error returned by
// WorkspaceCompliance.Validate if the designated constraints aren't met.
type WorkspaceComplianceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkspaceComplianceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkspaceComplianceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkspaceComplianceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkspaceComplianceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkspaceComplianceValidationError) ErrorName() string {
	return "WorkspaceComplianceValidationError"
}

// Error satisfies the builtin error interface
func (e WorkspaceComplianceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkspaceCompliance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkspaceComplianceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkspaceComplianceValidationError{}

// Validate checks the field values on FolderMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FolderMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FolderMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FolderMetadataMultiError,
// or nil if none found.
func (m *FolderMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *FolderMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for S3BucketName

	// no validation rules for S3FolderPath

	// no validation rules for IsDeleted

	// no validation rules for ParentFolderId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FolderMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FolderMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FolderMetadataValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FolderMetadataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FolderMetadataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FolderMetadataValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FolderMetadataValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FolderMetadataValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FolderMetadataValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FolderMetadataValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FolderMetadataValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FolderMetadataValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FolderMetadataMultiError(errors)
	}

	return nil
}

// FolderMetadataMultiError is an error wrapping multiple validation errors
// returned by FolderMetadata.ValidateAll() if the designated constraints
// aren't met.
type FolderMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FolderMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FolderMetadataMultiError) AllErrors() []error { return m }

// FolderMetadataValidationError is the validation error returned by
// FolderMetadata.Validate if the designated constraints aren't met.
type FolderMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FolderMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FolderMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FolderMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FolderMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FolderMetadataValidationError) ErrorName() string { return "FolderMetadataValidationError" }

// Error satisfies the builtin error interface
func (e FolderMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFolderMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FolderMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FolderMetadataValidationError{}

// Validate checks the field values on FileMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileMetadataMultiError, or
// nil if none found.
func (m *FileMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *FileMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Size

	// no validation rules for S3Key

	// no validation rules for S3BucketName

	// no validation rules for IsDeleted

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileMetadataValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileMetadataValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileMetadataValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEmbeddings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "Embeddings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileMetadataValidationError{
					field:  "Embeddings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmbeddings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileMetadataValidationError{
				field:  "Embeddings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileMetadataValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileMetadataValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSharing() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Sharing[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Sharing[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileMetadataValidationError{
					field:  fmt.Sprintf("Sharing[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSnapshots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Snapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileMetadataValidationError{
						field:  fmt.Sprintf("Snapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileMetadataValidationError{
					field:  fmt.Sprintf("Snapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FileMetadataMultiError(errors)
	}

	return nil
}

// FileMetadataMultiError is an error wrapping multiple validation errors
// returned by FileMetadata.ValidateAll() if the designated constraints aren't met.
type FileMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileMetadataMultiError) AllErrors() []error { return m }

// FileMetadataValidationError is the validation error returned by
// FileMetadata.Validate if the designated constraints aren't met.
type FileMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileMetadataValidationError) ErrorName() string { return "FileMetadataValidationError" }

// Error satisfies the builtin error interface
func (e FileMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileMetadataValidationError{}

// Validate checks the field values on FileEmbeddings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileEmbeddings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileEmbeddings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileEmbeddingsMultiError,
// or nil if none found.
func (m *FileEmbeddings) ValidateAll() error {
	return m.validate(true)
}

func (m *FileEmbeddings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ModelVersion

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileEmbeddingsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileEmbeddingsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileEmbeddingsValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileEmbeddingsValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileEmbeddingsValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileEmbeddingsValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FileEmbeddingsMultiError(errors)
	}

	return nil
}

// FileEmbeddingsMultiError is an error wrapping multiple validation errors
// returned by FileEmbeddings.ValidateAll() if the designated constraints
// aren't met.
type FileEmbeddingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileEmbeddingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileEmbeddingsMultiError) AllErrors() []error { return m }

// FileEmbeddingsValidationError is the validation error returned by
// FileEmbeddings.Validate if the designated constraints aren't met.
type FileEmbeddingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileEmbeddingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileEmbeddingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileEmbeddingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileEmbeddingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileEmbeddingsValidationError) ErrorName() string { return "FileEmbeddingsValidationError" }

// Error satisfies the builtin error interface
func (e FileEmbeddingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileEmbeddings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileEmbeddingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileEmbeddingsValidationError{}

// Validate checks the field values on FileVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileVersionMultiError, or
// nil if none found.
func (m *FileVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *FileVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for FileId

	// no validation rules for VersionNumber

	// no validation rules for S3Key

	// no validation rules for Size

	// no validation rules for CommitMessage

	// no validation rules for AuthorId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileVersionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FileVersionMultiError(errors)
	}

	return nil
}

// FileVersionMultiError is an error wrapping multiple validation errors
// returned by FileVersion.ValidateAll() if the designated constraints aren't met.
type FileVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileVersionMultiError) AllErrors() []error { return m }

// FileVersionValidationError is the validation error returned by
// FileVersion.Validate if the designated constraints aren't met.
type FileVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileVersionValidationError) ErrorName() string { return "FileVersionValidationError" }

// Error satisfies the builtin error interface
func (e FileVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileVersionValidationError{}

// Validate checks the field values on CommentThread with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommentThread) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommentThread with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommentThreadMultiError, or
// nil if none found.
func (m *CommentThread) ValidateAll() error {
	return m.validate(true)
}

func (m *CommentThread) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AuthorId

	// no validation rules for Content

	// no validation rules for StartPosition

	// no validation rules for EndPosition

	// no validation rules for Resolved

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentThreadValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentThreadValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentThreadValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentThreadValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentThreadValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentThreadValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommentThreadMultiError(errors)
	}

	return nil
}

// CommentThreadMultiError is an error wrapping multiple validation errors
// returned by CommentThread.ValidateAll() if the designated constraints
// aren't met.
type CommentThreadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentThreadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentThreadMultiError) AllErrors() []error { return m }

// CommentThreadValidationError is the validation error returned by
// CommentThread.Validate if the designated constraints aren't met.
type CommentThreadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentThreadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentThreadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentThreadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentThreadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentThreadValidationError) ErrorName() string { return "CommentThreadValidationError" }

// Error satisfies the builtin error interface
func (e CommentThreadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommentThread.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentThreadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentThreadValidationError{}

// Validate checks the field values on FileSharing with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileSharing) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileSharing with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileSharingMultiError, or
// nil if none found.
func (m *FileSharing) ValidateAll() error {
	return m.validate(true)
}

func (m *FileSharing) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SharedWithEmail

	// no validation rules for PermissionLevel

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileSharingValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileSharingValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileSharingValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileSharingValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileSharingValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileSharingValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileSharingValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileSharingValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileSharingValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FileSharingMultiError(errors)
	}

	return nil
}

// FileSharingMultiError is an error wrapping multiple validation errors
// returned by FileSharing.ValidateAll() if the designated constraints aren't met.
type FileSharingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileSharingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileSharingMultiError) AllErrors() []error { return m }

// FileSharingValidationError is the validation error returned by
// FileSharing.Validate if the designated constraints aren't met.
type FileSharingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileSharingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileSharingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileSharingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileSharingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileSharingValidationError) ErrorName() string { return "FileSharingValidationError" }

// Error satisfies the builtin error interface
func (e FileSharingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileSharing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileSharingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileSharingValidationError{}

// Validate checks the field values on DocumentTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentTemplate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentTemplateMultiError, or nil if none found.
func (m *DocumentTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for IndustryType

	// no validation rules for DocumentType

	// no validation rules for BaseContent

	// no validation rules for IsAdaptive

	// no validation rules for Metadata

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentTemplateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentTemplateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentTemplateValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentTemplateValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentTemplateValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentTemplateValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TemplateType

	// no validation rules for Content

	// no validation rules for VariableMappings

	// no validation rules for IsContextAware

	// no validation rules for FormattingRules

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentTemplateValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVariables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentTemplateValidationError{
					field:  fmt.Sprintf("Variables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentTemplateValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Explanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Explanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentTemplateValidationError{
					field:  fmt.Sprintf("Explanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIntelligence() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Intelligence[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentTemplateValidationError{
						field:  fmt.Sprintf("Intelligence[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentTemplateValidationError{
					field:  fmt.Sprintf("Intelligence[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentTemplateMultiError(errors)
	}

	return nil
}

// DocumentTemplateMultiError is an error wrapping multiple validation errors
// returned by DocumentTemplate.ValidateAll() if the designated constraints
// aren't met.
type DocumentTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentTemplateMultiError) AllErrors() []error { return m }

// DocumentTemplateValidationError is the validation error returned by
// DocumentTemplate.Validate if the designated constraints aren't met.
type DocumentTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentTemplateValidationError) ErrorName() string { return "DocumentTemplateValidationError" }

// Error satisfies the builtin error interface
func (e DocumentTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentTemplateValidationError{}

// Validate checks the field values on TemplateVariable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TemplateVariable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateVariableMultiError, or nil if none found.
func (m *TemplateVariable) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateVariable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for VariableType

	// no validation rules for DefaultValue

	// no validation rules for IsRequired

	// no validation rules for ValidationRules

	// no validation rules for DataSource

	// no validation rules for AiExtractionRules

	// no validation rules for TemplateId

	if len(errors) > 0 {
		return TemplateVariableMultiError(errors)
	}

	return nil
}

// TemplateVariableMultiError is an error wrapping multiple validation errors
// returned by TemplateVariable.ValidateAll() if the designated constraints
// aren't met.
type TemplateVariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateVariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateVariableMultiError) AllErrors() []error { return m }

// TemplateVariableValidationError is the validation error returned by
// TemplateVariable.Validate if the designated constraints aren't met.
type TemplateVariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateVariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateVariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateVariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateVariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateVariableValidationError) ErrorName() string { return "TemplateVariableValidationError" }

// Error satisfies the builtin error interface
func (e TemplateVariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateVariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateVariableValidationError{}

// Validate checks the field values on DocumentInstance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentInstanceMultiError, or nil if none found.
func (m *DocumentInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TemplateId

	// no validation rules for Status

	// no validation rules for FieldValues

	// no validation rules for Language

	// no validation rules for IsCompleted

	if all {
		switch v := interface{}(m.GetDueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentInstanceValidationError{
				field:  "DueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GeneratedContent

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentInstanceValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentInstanceValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSignatureRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentInstanceValidationError{
						field:  fmt.Sprintf("SignatureRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentInstanceValidationError{
						field:  fmt.Sprintf("SignatureRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentInstanceValidationError{
					field:  fmt.Sprintf("SignatureRequests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAiAssistance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentInstanceValidationError{
						field:  fmt.Sprintf("AiAssistance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentInstanceValidationError{
						field:  fmt.Sprintf("AiAssistance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentInstanceValidationError{
					field:  fmt.Sprintf("AiAssistance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetNegotiation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "Negotiation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentInstanceValidationError{
					field:  "Negotiation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNegotiation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentInstanceValidationError{
				field:  "Negotiation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentInstanceValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentInstanceValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentInstanceValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentInstanceMultiError(errors)
	}

	return nil
}

// DocumentInstanceMultiError is an error wrapping multiple validation errors
// returned by DocumentInstance.ValidateAll() if the designated constraints
// aren't met.
type DocumentInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentInstanceMultiError) AllErrors() []error { return m }

// DocumentInstanceValidationError is the validation error returned by
// DocumentInstance.Validate if the designated constraints aren't met.
type DocumentInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentInstanceValidationError) ErrorName() string { return "DocumentInstanceValidationError" }

// Error satisfies the builtin error interface
func (e DocumentInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentInstanceValidationError{}

// Validate checks the field values on DocumentVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentVersionMultiError, or nil if none found.
func (m *DocumentVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for VersionHash

	// no validation rules for ParentHash

	// no validation rules for CommitMessage

	// no validation rules for AuthorId

	// no validation rules for BranchName

	// no validation rules for Metadata

	// no validation rules for IsApproved

	// no validation rules for ApprovalChain

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentVersionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBranches() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentVersionValidationError{
						field:  fmt.Sprintf("Branches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentVersionValidationError{
						field:  fmt.Sprintf("Branches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentVersionValidationError{
					field:  fmt.Sprintf("Branches[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentVersionValidationError{
						field:  fmt.Sprintf("Changes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentVersionValidationError{
						field:  fmt.Sprintf("Changes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentVersionValidationError{
					field:  fmt.Sprintf("Changes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSummaries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentVersionValidationError{
						field:  fmt.Sprintf("Summaries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentVersionValidationError{
						field:  fmt.Sprintf("Summaries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentVersionValidationError{
					field:  fmt.Sprintf("Summaries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentVersionMultiError(errors)
	}

	return nil
}

// DocumentVersionMultiError is an error wrapping multiple validation errors
// returned by DocumentVersion.ValidateAll() if the designated constraints
// aren't met.
type DocumentVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentVersionMultiError) AllErrors() []error { return m }

// DocumentVersionValidationError is the validation error returned by
// DocumentVersion.Validate if the designated constraints aren't met.
type DocumentVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentVersionValidationError) ErrorName() string { return "DocumentVersionValidationError" }

// Error satisfies the builtin error interface
func (e DocumentVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentVersionValidationError{}

// Validate checks the field values on DocumentBranch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DocumentBranch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentBranch with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentBranchMultiError,
// or nil if none found.
func (m *DocumentBranch) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentBranch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for BaseVersionHash

	// no validation rules for CurrentHeadHash

	// no validation rules for Purpose

	// no validation rules for Status

	// no validation rules for BranchMetadata

	// no validation rules for IsLocked

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentBranchValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentBranchValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentBranchValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMerges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentBranchValidationError{
						field:  fmt.Sprintf("Merges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentBranchValidationError{
						field:  fmt.Sprintf("Merges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentBranchValidationError{
					field:  fmt.Sprintf("Merges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentBranchValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentBranchValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentBranchValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMergeRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentBranchValidationError{
						field:  fmt.Sprintf("MergeRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentBranchValidationError{
						field:  fmt.Sprintf("MergeRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentBranchValidationError{
					field:  fmt.Sprintf("MergeRequests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentBranchMultiError(errors)
	}

	return nil
}

// DocumentBranchMultiError is an error wrapping multiple validation errors
// returned by DocumentBranch.ValidateAll() if the designated constraints
// aren't met.
type DocumentBranchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentBranchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentBranchMultiError) AllErrors() []error { return m }

// DocumentBranchValidationError is the validation error returned by
// DocumentBranch.Validate if the designated constraints aren't met.
type DocumentBranchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentBranchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentBranchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentBranchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentBranchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentBranchValidationError) ErrorName() string { return "DocumentBranchValidationError" }

// Error satisfies the builtin error interface
func (e DocumentBranchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentBranch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentBranchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentBranchValidationError{}

// Validate checks the field values on SignatureRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignatureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignatureRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignatureRequestMultiError, or nil if none found.
func (m *SignatureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignatureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	// no validation rules for SignerEmail

	// no validation rules for SignerName

	// no validation rules for Role

	// no validation rules for AuthenticationMethod

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureRequestValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureRequestValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureRequestValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequiresMfa

	// no validation rules for SignatureType

	// no validation rules for DocumentId

	for idx, item := range m.GetSignatureBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignatureRequestValidationError{
						field:  fmt.Sprintf("SignatureBlocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignatureRequestValidationError{
						field:  fmt.Sprintf("SignatureBlocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignatureRequestValidationError{
					field:  fmt.Sprintf("SignatureBlocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureRequestValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureRequestValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureRequestValidationError{
				field:  "Workflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignatureRequestMultiError(errors)
	}

	return nil
}

// SignatureRequestMultiError is an error wrapping multiple validation errors
// returned by SignatureRequest.ValidateAll() if the designated constraints
// aren't met.
type SignatureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignatureRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignatureRequestMultiError) AllErrors() []error { return m }

// SignatureRequestValidationError is the validation error returned by
// SignatureRequest.Validate if the designated constraints aren't met.
type SignatureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignatureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignatureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignatureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignatureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignatureRequestValidationError) ErrorName() string { return "SignatureRequestValidationError" }

// Error satisfies the builtin error interface
func (e SignatureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignatureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignatureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignatureRequestValidationError{}

// Validate checks the field values on ContractIntelligence with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractIntelligence) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractIntelligence with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractIntelligenceMultiError, or nil if none found.
func (m *ContractIntelligence) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractIntelligence) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ContractType

	// no validation rules for RiskScores

	// no validation rules for DetectedClauses

	// no validation rules for ComplianceScores

	// no validation rules for Jurisdiction

	// no validation rules for SemanticAnalysis

	if all {
		switch v := interface{}(m.GetAnalysisDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractIntelligenceValidationError{
					field:  "AnalysisDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractIntelligenceValidationError{
					field:  "AnalysisDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnalysisDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractIntelligenceValidationError{
				field:  "AnalysisDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRiskAssessments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContractIntelligenceValidationError{
						field:  fmt.Sprintf("RiskAssessments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContractIntelligenceValidationError{
						field:  fmt.Sprintf("RiskAssessments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContractIntelligenceValidationError{
					field:  fmt.Sprintf("RiskAssessments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetComplianceChecks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContractIntelligenceValidationError{
						field:  fmt.Sprintf("ComplianceChecks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContractIntelligenceValidationError{
						field:  fmt.Sprintf("ComplianceChecks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContractIntelligenceValidationError{
					field:  fmt.Sprintf("ComplianceChecks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ContractIntelligenceMultiError(errors)
	}

	return nil
}

// ContractIntelligenceMultiError is an error wrapping multiple validation
// errors returned by ContractIntelligence.ValidateAll() if the designated
// constraints aren't met.
type ContractIntelligenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractIntelligenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractIntelligenceMultiError) AllErrors() []error { return m }

// ContractIntelligenceValidationError is the validation error returned by
// ContractIntelligence.Validate if the designated constraints aren't met.
type ContractIntelligenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractIntelligenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractIntelligenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractIntelligenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractIntelligenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractIntelligenceValidationError) ErrorName() string {
	return "ContractIntelligenceValidationError"
}

// Error satisfies the builtin error interface
func (e ContractIntelligenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractIntelligence.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractIntelligenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractIntelligenceValidationError{}

// Validate checks the field values on MarketplaceApp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MarketplaceApp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarketplaceApp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MarketplaceAppMultiError,
// or nil if none found.
func (m *MarketplaceApp) ValidateAll() error {
	return m.validate(true)
}

func (m *MarketplaceApp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for DeveloperId

	// no validation rules for Category

	// no validation rules for PricingModel

	// no validation rules for PricingTiers

	// no validation rules for IsVerified

	// no validation rules for Rating

	// no validation rules for InstallationCount

	// no validation rules for Metadata

	// no validation rules for DocumentationUrl

	// no validation rules for SupportEmail

	// no validation rules for PrivacyPolicyUrl

	// no validation rules for TermsUrl

	if all {
		switch v := interface{}(m.GetPublishedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketplaceAppValidationError{
					field:  "PublishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketplaceAppValidationError{
					field:  "PublishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPublishedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketplaceAppValidationError{
				field:  "PublishedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketplaceAppValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketplaceAppValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketplaceAppValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketplaceAppValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstallations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Installations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Installations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketplaceAppValidationError{
					field:  fmt.Sprintf("Installations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnalytics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Analytics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Analytics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketplaceAppValidationError{
					field:  fmt.Sprintf("Analytics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetReviews() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Reviews[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Reviews[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketplaceAppValidationError{
					field:  fmt.Sprintf("Reviews[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketplaceAppValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketplaceAppValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketplaceAppValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetWebhooks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Webhooks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Webhooks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketplaceAppValidationError{
					field:  fmt.Sprintf("Webhooks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPermissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketplaceAppValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketplaceAppValidationError{
					field:  fmt.Sprintf("Permissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MarketplaceAppMultiError(errors)
	}

	return nil
}

// MarketplaceAppMultiError is an error wrapping multiple validation errors
// returned by MarketplaceApp.ValidateAll() if the designated constraints
// aren't met.
type MarketplaceAppMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarketplaceAppMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarketplaceAppMultiError) AllErrors() []error { return m }

// MarketplaceAppValidationError is the validation error returned by
// MarketplaceApp.Validate if the designated constraints aren't met.
type MarketplaceAppValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarketplaceAppValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarketplaceAppValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarketplaceAppValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarketplaceAppValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarketplaceAppValidationError) ErrorName() string { return "MarketplaceAppValidationError" }

// Error satisfies the builtin error interface
func (e MarketplaceAppValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarketplaceApp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarketplaceAppValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarketplaceAppValidationError{}

// Validate checks the field values on DocumentSnapshot with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentSnapshotMultiError, or nil if none found.
func (m *DocumentSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for FileId

	// no validation rules for SnapshotHash

	// no validation rules for Content

	// no validation rules for AuthorId

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentSnapshotValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentSnapshotValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentSnapshotValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentSnapshotMultiError(errors)
	}

	return nil
}

// DocumentSnapshotMultiError is an error wrapping multiple validation errors
// returned by DocumentSnapshot.ValidateAll() if the designated constraints
// aren't met.
type DocumentSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentSnapshotMultiError) AllErrors() []error { return m }

// DocumentSnapshotValidationError is the validation error returned by
// DocumentSnapshot.Validate if the designated constraints aren't met.
type DocumentSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentSnapshotValidationError) ErrorName() string { return "DocumentSnapshotValidationError" }

// Error satisfies the builtin error interface
func (e DocumentSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentSnapshotValidationError{}

// Validate checks the field values on TemplateVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TemplateVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateVersionMultiError, or nil if none found.
func (m *TemplateVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TemplateId

	// no validation rules for Version

	// no validation rules for BaseContent

	// no validation rules for Metadata

	// no validation rules for AuthorId

	// no validation rules for ChangeDescription

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemplateVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemplateVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemplateVersionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TemplateVersionMultiError(errors)
	}

	return nil
}

// TemplateVersionMultiError is an error wrapping multiple validation errors
// returned by TemplateVersion.ValidateAll() if the designated constraints
// aren't met.
type TemplateVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateVersionMultiError) AllErrors() []error { return m }

// TemplateVersionValidationError is the validation error returned by
// TemplateVersion.Validate if the designated constraints aren't met.
type TemplateVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateVersionValidationError) ErrorName() string { return "TemplateVersionValidationError" }

// Error satisfies the builtin error interface
func (e TemplateVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateVersionValidationError{}

// Validate checks the field values on ExplanationBlock with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExplanationBlock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExplanationBlock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExplanationBlockMultiError, or nil if none found.
func (m *ExplanationBlock) ValidateAll() error {
	return m.validate(true)
}

func (m *ExplanationBlock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TemplateId

	// no validation rules for SectionIdentifier

	// no validation rules for ExplanationText

	// no validation rules for ComplexityLevel

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExplanationBlockValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExplanationBlockValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExplanationBlockValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExplanationBlockValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExplanationBlockValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExplanationBlockValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExplanationBlockMultiError(errors)
	}

	return nil
}

// ExplanationBlockMultiError is an error wrapping multiple validation errors
// returned by ExplanationBlock.ValidateAll() if the designated constraints
// aren't met.
type ExplanationBlockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExplanationBlockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExplanationBlockMultiError) AllErrors() []error { return m }

// ExplanationBlockValidationError is the validation error returned by
// ExplanationBlock.Validate if the designated constraints aren't met.
type ExplanationBlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExplanationBlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExplanationBlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExplanationBlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExplanationBlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExplanationBlockValidationError) ErrorName() string { return "ExplanationBlockValidationError" }

// Error satisfies the builtin error interface
func (e ExplanationBlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExplanationBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExplanationBlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExplanationBlockValidationError{}

// Validate checks the field values on AIAssistanceLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AIAssistanceLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIAssistanceLog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AIAssistanceLogMultiError, or nil if none found.
func (m *AIAssistanceLog) ValidateAll() error {
	return m.validate(true)
}

func (m *AIAssistanceLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DocumentId

	// no validation rules for InteractionType

	// no validation rules for UserQuery

	// no validation rules for AiResponse

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIAssistanceLogValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIAssistanceLogValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIAssistanceLogValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIAssistanceLogMultiError(errors)
	}

	return nil
}

// AIAssistanceLogMultiError is an error wrapping multiple validation errors
// returned by AIAssistanceLog.ValidateAll() if the designated constraints
// aren't met.
type AIAssistanceLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIAssistanceLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIAssistanceLogMultiError) AllErrors() []error { return m }

// AIAssistanceLogValidationError is the validation error returned by
// AIAssistanceLog.Validate if the designated constraints aren't met.
type AIAssistanceLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIAssistanceLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIAssistanceLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIAssistanceLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIAssistanceLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIAssistanceLogValidationError) ErrorName() string { return "AIAssistanceLogValidationError" }

// Error satisfies the builtin error interface
func (e AIAssistanceLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIAssistanceLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIAssistanceLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIAssistanceLogValidationError{}

// Validate checks the field values on NegotiationHistory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NegotiationHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NegotiationHistory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NegotiationHistoryMultiError, or nil if none found.
func (m *NegotiationHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *NegotiationHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DocumentId

	for idx, item := range m.GetRounds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NegotiationHistoryValidationError{
						field:  fmt.Sprintf("Rounds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NegotiationHistoryValidationError{
						field:  fmt.Sprintf("Rounds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NegotiationHistoryValidationError{
					field:  fmt.Sprintf("Rounds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CurrentStatus

	if all {
		switch v := interface{}(m.GetStartedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NegotiationHistoryValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NegotiationHistoryValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NegotiationHistoryValidationError{
				field:  "StartedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NegotiationHistoryValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NegotiationHistoryValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NegotiationHistoryValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NegotiationHistoryMultiError(errors)
	}

	return nil
}

// NegotiationHistoryMultiError is an error wrapping multiple validation errors
// returned by NegotiationHistory.ValidateAll() if the designated constraints
// aren't met.
type NegotiationHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NegotiationHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NegotiationHistoryMultiError) AllErrors() []error { return m }

// NegotiationHistoryValidationError is the validation error returned by
// NegotiationHistory.Validate if the designated constraints aren't met.
type NegotiationHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NegotiationHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NegotiationHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NegotiationHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NegotiationHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NegotiationHistoryValidationError) ErrorName() string {
	return "NegotiationHistoryValidationError"
}

// Error satisfies the builtin error interface
func (e NegotiationHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNegotiationHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NegotiationHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NegotiationHistoryValidationError{}

// Validate checks the field values on NegotiationRound with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NegotiationRound) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NegotiationRound with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NegotiationRoundMultiError, or nil if none found.
func (m *NegotiationRound) ValidateAll() error {
	return m.validate(true)
}

func (m *NegotiationRound) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for HistoryId

	// no validation rules for RoundNumber

	// no validation rules for ProposerId

	// no validation rules for ProposalContent

	// no validation rules for ResponseContent

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NegotiationRoundValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NegotiationRoundValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NegotiationRoundValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NegotiationRoundMultiError(errors)
	}

	return nil
}

// NegotiationRoundMultiError is an error wrapping multiple validation errors
// returned by NegotiationRound.ValidateAll() if the designated constraints
// aren't met.
type NegotiationRoundMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NegotiationRoundMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NegotiationRoundMultiError) AllErrors() []error { return m }

// NegotiationRoundValidationError is the validation error returned by
// NegotiationRound.Validate if the designated constraints aren't met.
type NegotiationRoundValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NegotiationRoundValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NegotiationRoundValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NegotiationRoundValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NegotiationRoundValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NegotiationRoundValidationError) ErrorName() string { return "NegotiationRoundValidationError" }

// Error satisfies the builtin error interface
func (e NegotiationRoundValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNegotiationRound.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NegotiationRoundValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NegotiationRoundValidationError{}

// Validate checks the field values on ChangeSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChangeSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChangeSetMultiError, or nil
// if none found.
func (m *ChangeSet) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for VersionId

	// no validation rules for ChangeType

	// no validation rules for ContentBefore

	// no validation rules for ContentAfter

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSetValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSetValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSetValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChangeSetMultiError(errors)
	}

	return nil
}

// ChangeSetMultiError is an error wrapping multiple validation errors returned
// by ChangeSet.ValidateAll() if the designated constraints aren't met.
type ChangeSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSetMultiError) AllErrors() []error { return m }

// ChangeSetValidationError is the validation error returned by
// ChangeSet.Validate if the designated constraints aren't met.
type ChangeSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSetValidationError) ErrorName() string { return "ChangeSetValidationError" }

// Error satisfies the builtin error interface
func (e ChangeSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSetValidationError{}

// Validate checks the field values on ContextualSummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContextualSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContextualSummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContextualSummaryMultiError, or nil if none found.
func (m *ContextualSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *ContextualSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for VersionId

	// no validation rules for SummaryType

	// no validation rules for Content

	// no validation rules for TargetAudience

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContextualSummaryValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContextualSummaryValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContextualSummaryValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContextualSummaryMultiError(errors)
	}

	return nil
}

// ContextualSummaryMultiError is an error wrapping multiple validation errors
// returned by ContextualSummary.ValidateAll() if the designated constraints
// aren't met.
type ContextualSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContextualSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContextualSummaryMultiError) AllErrors() []error { return m }

// ContextualSummaryValidationError is the validation error returned by
// ContextualSummary.Validate if the designated constraints aren't met.
type ContextualSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContextualSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContextualSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContextualSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContextualSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContextualSummaryValidationError) ErrorName() string {
	return "ContextualSummaryValidationError"
}

// Error satisfies the builtin error interface
func (e ContextualSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContextualSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContextualSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContextualSummaryValidationError{}

// Validate checks the field values on BranchMerge with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BranchMerge) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BranchMerge with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BranchMergeMultiError, or
// nil if none found.
func (m *BranchMerge) ValidateAll() error {
	return m.validate(true)
}

func (m *BranchMerge) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for BranchId

	// no validation rules for SourceBranch

	// no validation rules for TargetBranch

	// no validation rules for MergeStatus

	// no validation rules for MergeStrategy

	// no validation rules for MergerId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchMergeValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchMergeValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchMergeValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchMergeValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchMergeValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchMergeValidationError{
				field:  "CompletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BranchMergeMultiError(errors)
	}

	return nil
}

// BranchMergeMultiError is an error wrapping multiple validation errors
// returned by BranchMerge.ValidateAll() if the designated constraints aren't met.
type BranchMergeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchMergeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchMergeMultiError) AllErrors() []error { return m }

// BranchMergeValidationError is the validation error returned by
// BranchMerge.Validate if the designated constraints aren't met.
type BranchMergeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchMergeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchMergeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchMergeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchMergeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchMergeValidationError) ErrorName() string { return "BranchMergeValidationError" }

// Error satisfies the builtin error interface
func (e BranchMergeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranchMerge.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchMergeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchMergeValidationError{}

// Validate checks the field values on SignatureBlock with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignatureBlock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignatureBlock with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignatureBlockMultiError,
// or nil if none found.
func (m *SignatureBlock) ValidateAll() error {
	return m.validate(true)
}

func (m *SignatureBlock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RequestId

	// no validation rules for BlockType

	// no validation rules for PageNumber

	// no validation rules for XPosition

	// no validation rules for YPosition

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for IsRequired

	// no validation rules for SignatureData

	if all {
		switch v := interface{}(m.GetSignedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureBlockValidationError{
					field:  "SignedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureBlockValidationError{
					field:  "SignedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureBlockValidationError{
				field:  "SignedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignatureBlockMultiError(errors)
	}

	return nil
}

// SignatureBlockMultiError is an error wrapping multiple validation errors
// returned by SignatureBlock.ValidateAll() if the designated constraints
// aren't met.
type SignatureBlockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignatureBlockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignatureBlockMultiError) AllErrors() []error { return m }

// SignatureBlockValidationError is the validation error returned by
// SignatureBlock.Validate if the designated constraints aren't met.
type SignatureBlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignatureBlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignatureBlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignatureBlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignatureBlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignatureBlockValidationError) ErrorName() string { return "SignatureBlockValidationError" }

// Error satisfies the builtin error interface
func (e SignatureBlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignatureBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignatureBlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignatureBlockValidationError{}

// Validate checks the field values on SignatureWorkflow with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignatureWorkflow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignatureWorkflow with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignatureWorkflowMultiError, or nil if none found.
func (m *SignatureWorkflow) ValidateAll() error {
	return m.validate(true)
}

func (m *SignatureWorkflow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RequestId

	// no validation rules for CurrentSigner

	// no validation rules for WorkflowStatus

	// no validation rules for ParallelSigning

	// no validation rules for RequireAllSignatures

	if all {
		switch v := interface{}(m.GetDeadline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureWorkflowValidationError{
					field:  "Deadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureWorkflowValidationError{
					field:  "Deadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeadline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureWorkflowValidationError{
				field:  "Deadline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureWorkflowValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureWorkflowValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureWorkflowValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureWorkflowValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureWorkflowValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureWorkflowValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignatureWorkflowMultiError(errors)
	}

	return nil
}

// SignatureWorkflowMultiError is an error wrapping multiple validation errors
// returned by SignatureWorkflow.ValidateAll() if the designated constraints
// aren't met.
type SignatureWorkflowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignatureWorkflowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignatureWorkflowMultiError) AllErrors() []error { return m }

// SignatureWorkflowValidationError is the validation error returned by
// SignatureWorkflow.Validate if the designated constraints aren't met.
type SignatureWorkflowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignatureWorkflowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignatureWorkflowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignatureWorkflowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignatureWorkflowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignatureWorkflowValidationError) ErrorName() string {
	return "SignatureWorkflowValidationError"
}

// Error satisfies the builtin error interface
func (e SignatureWorkflowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignatureWorkflow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignatureWorkflowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignatureWorkflowValidationError{}

// Validate checks the field values on RiskAssessment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RiskAssessment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RiskAssessment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RiskAssessmentMultiError,
// or nil if none found.
func (m *RiskAssessment) ValidateAll() error {
	return m.validate(true)
}

func (m *RiskAssessment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for IntelligenceId

	// no validation rules for RiskType

	// no validation rules for RiskScore

	// no validation rules for AssessmentDetails

	// no validation rules for AssessorId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RiskAssessmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RiskAssessmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RiskAssessmentValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RiskAssessmentMultiError(errors)
	}

	return nil
}

// RiskAssessmentMultiError is an error wrapping multiple validation errors
// returned by RiskAssessment.ValidateAll() if the designated constraints
// aren't met.
type RiskAssessmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RiskAssessmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RiskAssessmentMultiError) AllErrors() []error { return m }

// RiskAssessmentValidationError is the validation error returned by
// RiskAssessment.Validate if the designated constraints aren't met.
type RiskAssessmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RiskAssessmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RiskAssessmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RiskAssessmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RiskAssessmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RiskAssessmentValidationError) ErrorName() string { return "RiskAssessmentValidationError" }

// Error satisfies the builtin error interface
func (e RiskAssessmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRiskAssessment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RiskAssessmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RiskAssessmentValidationError{}

// Validate checks the field values on ComplianceCheck with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ComplianceCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComplianceCheck with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComplianceCheckMultiError, or nil if none found.
func (m *ComplianceCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *ComplianceCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for IntelligenceId

	// no validation rules for ComplianceStandard

	// no validation rules for CheckResult

	// no validation rules for RemediationSteps

	if all {
		switch v := interface{}(m.GetCheckDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComplianceCheckValidationError{
					field:  "CheckDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComplianceCheckValidationError{
					field:  "CheckDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComplianceCheckValidationError{
				field:  "CheckDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComplianceCheckMultiError(errors)
	}

	return nil
}

// ComplianceCheckMultiError is an error wrapping multiple validation errors
// returned by ComplianceCheck.ValidateAll() if the designated constraints
// aren't met.
type ComplianceCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComplianceCheckMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComplianceCheckMultiError) AllErrors() []error { return m }

// ComplianceCheckValidationError is the validation error returned by
// ComplianceCheck.Validate if the designated constraints aren't met.
type ComplianceCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComplianceCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComplianceCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComplianceCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComplianceCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComplianceCheckValidationError) ErrorName() string { return "ComplianceCheckValidationError" }

// Error satisfies the builtin error interface
func (e ComplianceCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComplianceCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComplianceCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComplianceCheckValidationError{}

// Validate checks the field values on AppVersion with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AppVersionMultiError, or
// nil if none found.
func (m *AppVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *AppVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for VersionNumber

	// no validation rules for Changelog

	// no validation rules for Requirements

	// no validation rules for IsPublic

	if all {
		switch v := interface{}(m.GetReleaseDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppVersionValidationError{
					field:  "ReleaseDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppVersionValidationError{
					field:  "ReleaseDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppVersionValidationError{
				field:  "ReleaseDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppVersionMultiError(errors)
	}

	return nil
}

// AppVersionMultiError is an error wrapping multiple validation errors
// returned by AppVersion.ValidateAll() if the designated constraints aren't met.
type AppVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppVersionMultiError) AllErrors() []error { return m }

// AppVersionValidationError is the validation error returned by
// AppVersion.Validate if the designated constraints aren't met.
type AppVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppVersionValidationError) ErrorName() string { return "AppVersionValidationError" }

// Error satisfies the builtin error interface
func (e AppVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppVersionValidationError{}

// Validate checks the field values on AppInstallation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AppInstallation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppInstallation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppInstallationMultiError, or nil if none found.
func (m *AppInstallation) ValidateAll() error {
	return m.validate(true)
}

func (m *AppInstallation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for WorkspaceId

	// no validation rules for VersionInstalled

	// no validation rules for Configuration

	// no validation rules for InstallationStatus

	if all {
		switch v := interface{}(m.GetInstalledAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppInstallationValidationError{
					field:  "InstalledAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppInstallationValidationError{
					field:  "InstalledAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstalledAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppInstallationValidationError{
				field:  "InstalledAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastUsed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppInstallationValidationError{
					field:  "LastUsed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppInstallationValidationError{
					field:  "LastUsed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUsed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppInstallationValidationError{
				field:  "LastUsed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppInstallationMultiError(errors)
	}

	return nil
}

// AppInstallationMultiError is an error wrapping multiple validation errors
// returned by AppInstallation.ValidateAll() if the designated constraints
// aren't met.
type AppInstallationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppInstallationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppInstallationMultiError) AllErrors() []error { return m }

// AppInstallationValidationError is the validation error returned by
// AppInstallation.Validate if the designated constraints aren't met.
type AppInstallationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppInstallationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppInstallationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppInstallationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppInstallationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppInstallationValidationError) ErrorName() string { return "AppInstallationValidationError" }

// Error satisfies the builtin error interface
func (e AppInstallationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppInstallation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppInstallationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppInstallationValidationError{}

// Validate checks the field values on AppAnalytics with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppAnalytics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppAnalytics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AppAnalyticsMultiError, or
// nil if none found.
func (m *AppAnalytics) ValidateAll() error {
	return m.validate(true)
}

func (m *AppAnalytics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for MetricName

	// no validation rules for MetricValue

	// no validation rules for Dimensions

	if all {
		switch v := interface{}(m.GetRecordedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppAnalyticsValidationError{
					field:  "RecordedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppAnalyticsValidationError{
					field:  "RecordedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecordedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppAnalyticsValidationError{
				field:  "RecordedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppAnalyticsMultiError(errors)
	}

	return nil
}

// AppAnalyticsMultiError is an error wrapping multiple validation errors
// returned by AppAnalytics.ValidateAll() if the designated constraints aren't met.
type AppAnalyticsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppAnalyticsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppAnalyticsMultiError) AllErrors() []error { return m }

// AppAnalyticsValidationError is the validation error returned by
// AppAnalytics.Validate if the designated constraints aren't met.
type AppAnalyticsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppAnalyticsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppAnalyticsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppAnalyticsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppAnalyticsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppAnalyticsValidationError) ErrorName() string { return "AppAnalyticsValidationError" }

// Error satisfies the builtin error interface
func (e AppAnalyticsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppAnalytics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppAnalyticsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppAnalyticsValidationError{}

// Validate checks the field values on AppReview with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppReview) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppReview with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AppReviewMultiError, or nil
// if none found.
func (m *AppReview) ValidateAll() error {
	return m.validate(true)
}

func (m *AppReview) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for ReviewerId

	// no validation rules for Rating

	// no validation rules for ReviewText

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppReviewValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppReviewValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppReviewValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppReviewValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppReviewValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppReviewValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppReviewMultiError(errors)
	}

	return nil
}

// AppReviewMultiError is an error wrapping multiple validation errors returned
// by AppReview.ValidateAll() if the designated constraints aren't met.
type AppReviewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppReviewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppReviewMultiError) AllErrors() []error { return m }

// AppReviewValidationError is the validation error returned by
// AppReview.Validate if the designated constraints aren't met.
type AppReviewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppReviewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppReviewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppReviewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppReviewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppReviewValidationError) ErrorName() string { return "AppReviewValidationError" }

// Error satisfies the builtin error interface
func (e AppReviewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppReview.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppReviewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppReviewValidationError{}

// Validate checks the field values on AppDevelopmentInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppDevelopmentInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppDevelopmentInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppDevelopmentInfoMultiError, or nil if none found.
func (m *AppDevelopmentInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *AppDevelopmentInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for TestCoverage

	// no validation rules for PerformanceMetrics

	// no validation rules for DevelopmentStatus

	// no validation rules for RoadmapUrl

	if all {
		switch v := interface{}(m.GetLastSecurityAudit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppDevelopmentInfoValidationError{
					field:  "LastSecurityAudit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppDevelopmentInfoValidationError{
					field:  "LastSecurityAudit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastSecurityAudit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppDevelopmentInfoValidationError{
				field:  "LastSecurityAudit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppDevelopmentInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppDevelopmentInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppDevelopmentInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppDevelopmentInfoValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppDevelopmentInfoValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppDevelopmentInfoValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppDevelopmentInfoMultiError(errors)
	}

	return nil
}

// AppDevelopmentInfoMultiError is an error wrapping multiple validation errors
// returned by AppDevelopmentInfo.ValidateAll() if the designated constraints
// aren't met.
type AppDevelopmentInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppDevelopmentInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppDevelopmentInfoMultiError) AllErrors() []error { return m }

// AppDevelopmentInfoValidationError is the validation error returned by
// AppDevelopmentInfo.Validate if the designated constraints aren't met.
type AppDevelopmentInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppDevelopmentInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppDevelopmentInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppDevelopmentInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppDevelopmentInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppDevelopmentInfoValidationError) ErrorName() string {
	return "AppDevelopmentInfoValidationError"
}

// Error satisfies the builtin error interface
func (e AppDevelopmentInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppDevelopmentInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppDevelopmentInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppDevelopmentInfoValidationError{}

// Validate checks the field values on AppWebhook with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppWebhook) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppWebhook with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AppWebhookMultiError, or
// nil if none found.
func (m *AppWebhook) ValidateAll() error {
	return m.validate(true)
}

func (m *AppWebhook) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for Url

	// no validation rules for SecretKey

	// no validation rules for RetryCount

	// no validation rules for TimeoutSeconds

	// no validation rules for IsActive

	// no validation rules for Headers

	if all {
		switch v := interface{}(m.GetLastTriggered()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppWebhookValidationError{
					field:  "LastTriggered",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppWebhookValidationError{
					field:  "LastTriggered",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastTriggered()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppWebhookValidationError{
				field:  "LastTriggered",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppWebhookValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppWebhookValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppWebhookValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppWebhookMultiError(errors)
	}

	return nil
}

// AppWebhookMultiError is an error wrapping multiple validation errors
// returned by AppWebhook.ValidateAll() if the designated constraints aren't met.
type AppWebhookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppWebhookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppWebhookMultiError) AllErrors() []error { return m }

// AppWebhookValidationError is the validation error returned by
// AppWebhook.Validate if the designated constraints aren't met.
type AppWebhookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppWebhookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppWebhookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppWebhookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppWebhookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppWebhookValidationError) ErrorName() string { return "AppWebhookValidationError" }

// Error satisfies the builtin error interface
func (e AppWebhookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppWebhook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppWebhookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppWebhookValidationError{}

// Validate checks the field values on AppPermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AppPermissionMultiError, or
// nil if none found.
func (m *AppPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *AppPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppId

	// no validation rules for Scope

	// no validation rules for Description

	// no validation rules for IsRequired

	// no validation rules for Constraints

	// no validation rules for RequiresApproval

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppPermissionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppPermissionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppPermissionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppPermissionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppPermissionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppPermissionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppPermissionMultiError(errors)
	}

	return nil
}

// AppPermissionMultiError is an error wrapping multiple validation errors
// returned by AppPermission.ValidateAll() if the designated constraints
// aren't met.
type AppPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppPermissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppPermissionMultiError) AllErrors() []error { return m }

// AppPermissionValidationError is the validation error returned by
// AppPermission.Validate if the designated constraints aren't met.
type AppPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppPermissionValidationError) ErrorName() string { return "AppPermissionValidationError" }

// Error satisfies the builtin error interface
func (e AppPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppPermissionValidationError{}

// Validate checks the field values on BranchPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BranchPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BranchPolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BranchPolicyMultiError, or
// nil if none found.
func (m *BranchPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *BranchPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for BranchId

	// no validation rules for MinimumApprovals

	// no validation rules for EnforceLinearHistory

	// no validation rules for AllowForcePush

	// no validation rules for MergeRules

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchPolicyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchPolicyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchPolicyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchPolicyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchPolicyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchPolicyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BranchPolicyMultiError(errors)
	}

	return nil
}

// BranchPolicyMultiError is an error wrapping multiple validation errors
// returned by BranchPolicy.ValidateAll() if the designated constraints aren't met.
type BranchPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchPolicyMultiError) AllErrors() []error { return m }

// BranchPolicyValidationError is the validation error returned by
// BranchPolicy.Validate if the designated constraints aren't met.
type BranchPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchPolicyValidationError) ErrorName() string { return "BranchPolicyValidationError" }

// Error satisfies the builtin error interface
func (e BranchPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranchPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchPolicyValidationError{}

// Validate checks the field values on MergeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MergeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MergeRequestMultiError, or
// nil if none found.
func (m *MergeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SourceBranchId

	// no validation rules for TargetBranchId

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for AuthorId

	// no validation rules for Status

	// no validation rules for HasConflicts

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeRequestValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeRequestValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeRequestValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeRequestValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MergeRequestMultiError(errors)
	}

	return nil
}

// MergeRequestMultiError is an error wrapping multiple validation errors
// returned by MergeRequest.ValidateAll() if the designated constraints aren't met.
type MergeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeRequestMultiError) AllErrors() []error { return m }

// MergeRequestValidationError is the validation error returned by
// MergeRequest.Validate if the designated constraints aren't met.
type MergeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeRequestValidationError) ErrorName() string { return "MergeRequestValidationError" }

// Error satisfies the builtin error interface
func (e MergeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeRequestValidationError{}
