/**
 * User Service API
 * Solomon AI User Service API - Manages user profiles and authentication
 *
 * The version of the OpenAPI document: 1.0
 * Contact: yoanyomba@solomon-ai.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AddDefaultPocketsToBankAccountRequest } from '../model/addDefaultPocketsToBankAccountRequest';
import { AddDefaultPocketsToBankAccountResponse } from '../model/addDefaultPocketsToBankAccountResponse';
import { AddNoteToFinancialUserProfileRequest } from '../model/addNoteToFinancialUserProfileRequest';
import { AddNoteToFinancialUserProfileResponse } from '../model/addNoteToFinancialUserProfileResponse';
import { AddNoteToRecurringTransactionRequest } from '../model/addNoteToRecurringTransactionRequest';
import { AddNoteToRecurringTransactionResponse } from '../model/addNoteToRecurringTransactionResponse';
import { AddNoteToSmartGoalRequest } from '../model/addNoteToSmartGoalRequest';
import { AddNoteToSmartGoalResponse } from '../model/addNoteToSmartGoalResponse';
import { AddNoteToTransactionRequest } from '../model/addNoteToTransactionRequest';
import { AddNoteToTransactionResponse } from '../model/addNoteToTransactionResponse';
import { AddTransactionsToManuallyLinkedAccountRequest } from '../model/addTransactionsToManuallyLinkedAccountRequest';
import { AddTransactionsToManuallyLinkedAccountResponse } from '../model/addTransactionsToManuallyLinkedAccountResponse';
import { AuthenticationErrorMessageResponse } from '../model/authenticationErrorMessageResponse';
import { BadGatewayErrorMessageResponse } from '../model/badGatewayErrorMessageResponse';
import { BulkUpdateRecurringTransactionRequest } from '../model/bulkUpdateRecurringTransactionRequest';
import { BulkUpdateRecurringTransactionResponse } from '../model/bulkUpdateRecurringTransactionResponse';
import { BulkUpdateTransactionRequest } from '../model/bulkUpdateTransactionRequest';
import { BulkUpdateTransactionResponse } from '../model/bulkUpdateTransactionResponse';
import { CheckIfQuotaExceededResponse } from '../model/checkIfQuotaExceededResponse';
import { ConflictErrorMessageResponse } from '../model/conflictErrorMessageResponse';
import { CreateBankAccountRequest } from '../model/createBankAccountRequest';
import { CreateBankAccountResponse } from '../model/createBankAccountResponse';
import { CreateBudgetRequest } from '../model/createBudgetRequest';
import { CreateBudgetResponse } from '../model/createBudgetResponse';
import { CreateCreditAccountRequest } from '../model/createCreditAccountRequest';
import { CreateCreditAccountResponse } from '../model/createCreditAccountResponse';
import { CreateManualLinkRequest } from '../model/createManualLinkRequest';
import { CreateManualLinkResponse } from '../model/createManualLinkResponse';
import { CreateMilestoneRequest } from '../model/createMilestoneRequest';
import { CreateMilestoneResponse } from '../model/createMilestoneResponse';
import { CreateSmartGoalRequest } from '../model/createSmartGoalRequest';
import { CreateSmartGoalResponse } from '../model/createSmartGoalResponse';
import { CreateSubscriptionRequest } from '../model/createSubscriptionRequest';
import { CreateSubscriptionResponse } from '../model/createSubscriptionResponse';
import { CreateUserProfileRequest1 } from '../model/createUserProfileRequest1';
import { CreateUserProfileResponse1 } from '../model/createUserProfileResponse1';
import { DeleteBankAccountResponse } from '../model/deleteBankAccountResponse';
import { DeleteBudgetResponse } from '../model/deleteBudgetResponse';
import { DeleteLinkResponse } from '../model/deleteLinkResponse';
import { DeleteMilestoneResponse } from '../model/deleteMilestoneResponse';
import { DeleteNoteFromRecurringTransactionResponse } from '../model/deleteNoteFromRecurringTransactionResponse';
import { DeleteNoteFromSmartGoalResponse } from '../model/deleteNoteFromSmartGoalResponse';
import { DeleteNoteFromTransactionResponse } from '../model/deleteNoteFromTransactionResponse';
import { DeletePocketResponse } from '../model/deletePocketResponse';
import { DeleteRecurringTransactionResponse } from '../model/deleteRecurringTransactionResponse';
import { DeleteSmartGoalResponse } from '../model/deleteSmartGoalResponse';
import { DeleteTransactionResponse } from '../model/deleteTransactionResponse';
import { DeleteUserProfileResponse1 } from '../model/deleteUserProfileResponse1';
import { ForbiddenErrorMessageResponse } from '../model/forbiddenErrorMessageResponse';
import { GatewayTimeoutErrorMessageResponse } from '../model/gatewayTimeoutErrorMessageResponse';
import { GetAccountBalanceHistoryResponse } from '../model/getAccountBalanceHistoryResponse';
import { GetAllBudgetsResponse } from '../model/getAllBudgetsResponse';
import { GetBankAccountResponse } from '../model/getBankAccountResponse';
import { GetBudgetResponse } from '../model/getBudgetResponse';
import { GetCategoryMetricsFinancialSubProfileOverTimeResponse } from '../model/getCategoryMetricsFinancialSubProfileOverTimeResponse';
import { GetCategoryMonthlyTransactionCountResponse } from '../model/getCategoryMonthlyTransactionCountResponse';
import { GetDebtToIncomeRatioResponse } from '../model/getDebtToIncomeRatioResponse';
import { GetExpenseMetricsFinancialSubProfileOverTimeResponse } from '../model/getExpenseMetricsFinancialSubProfileOverTimeResponse';
import { GetExpenseMetricsResponse } from '../model/getExpenseMetricsResponse';
import { GetFinancialProfileResponse } from '../model/getFinancialProfileResponse';
import { GetForecastResponse } from '../model/getForecastResponse';
import { GetHistoricalAccountBalanceResponse } from '../model/getHistoricalAccountBalanceResponse';
import { GetIncomeExpenseRatioResponse } from '../model/getIncomeExpenseRatioResponse';
import { GetIncomeMetricsFinancialSubProfileOverTimeResponse } from '../model/getIncomeMetricsFinancialSubProfileOverTimeResponse';
import { GetIncomeMetricsResponse } from '../model/getIncomeMetricsResponse';
import { GetInvestmentAcccountResponse } from '../model/getInvestmentAcccountResponse';
import { GetLiabilityAccountResponse } from '../model/getLiabilityAccountResponse';
import { GetLinkResponse } from '../model/getLinkResponse';
import { GetLinksResponse } from '../model/getLinksResponse';
import { GetLocationMetricsFinancialSubProfileOverTimeResponse } from '../model/getLocationMetricsFinancialSubProfileOverTimeResponse';
import { GetMelodyFinancialContextResponse } from '../model/getMelodyFinancialContextResponse';
import { GetMerchantMetricsFinancialSubProfileOverTimeResponse } from '../model/getMerchantMetricsFinancialSubProfileOverTimeResponse';
import { GetMerchantMonthlyExpenditureResponse } from '../model/getMerchantMonthlyExpenditureResponse';
import { GetMilestoneResponse } from '../model/getMilestoneResponse';
import { GetMilestonesBySmartGoalIdResponse } from '../model/getMilestonesBySmartGoalIdResponse';
import { GetMonthlyBalanceResponse } from '../model/getMonthlyBalanceResponse';
import { GetMonthlyExpenditureResponse } from '../model/getMonthlyExpenditureResponse';
import { GetMonthlyIncomeResponse } from '../model/getMonthlyIncomeResponse';
import { GetMonthlySavingsResponse } from '../model/getMonthlySavingsResponse';
import { GetMonthlyTotalQuantityBySecurityAndUserResponse } from '../model/getMonthlyTotalQuantityBySecurityAndUserResponse';
import { GetMonthlyTransactionCountResponse } from '../model/getMonthlyTransactionCountResponse';
import { GetMortgageAccountResponse } from '../model/getMortgageAccountResponse';
import { GetNoteFromSmartGoalResponse } from '../model/getNoteFromSmartGoalResponse';
import { GetNoteFromTransactionResponse } from '../model/getNoteFromTransactionResponse';
import { GetNotesFromFinancialUserProfileResponse } from '../model/getNotesFromFinancialUserProfileResponse';
import { GetNotesFromSmartGoalResponse } from '../model/getNotesFromSmartGoalResponse';
import { GetPaymentChannelFinancialSubProfileOverTimeResponse } from '../model/getPaymentChannelFinancialSubProfileOverTimeResponse';
import { GetPaymentChannelMonthlyExpenditureResponse } from '../model/getPaymentChannelMonthlyExpenditureResponse';
import { GetPocketResponse } from '../model/getPocketResponse';
import { GetRecurringTransactionsForUserResponse } from '../model/getRecurringTransactionsForUserResponse';
import { GetSingleRecurringTransactionResponse } from '../model/getSingleRecurringTransactionResponse';
import { GetSmartGoalsByPocketIdResponse } from '../model/getSmartGoalsByPocketIdResponse';
import { GetSplitTransactionResponse } from '../model/getSplitTransactionResponse';
import { GetStudentLoanAccountResponse } from '../model/getStudentLoanAccountResponse';
import { GetTotalInvestmentBySecurityResponse } from '../model/getTotalInvestmentBySecurityResponse';
import { GetTransactionAggregatesResponse } from '../model/getTransactionAggregatesResponse';
import { GetTransactionResponse } from '../model/getTransactionResponse';
import { GetTransactionsBetweenTimeRangesResponse } from '../model/getTransactionsBetweenTimeRangesResponse';
import { GetTransactionsForBankAccountResponse } from '../model/getTransactionsForBankAccountResponse';
import { GetTransactionsForPastMonthResponse } from '../model/getTransactionsForPastMonthResponse';
import { GetTransactionsForPastWeekResponse } from '../model/getTransactionsForPastWeekResponse';
import { GetTransactionsResponse } from '../model/getTransactionsResponse';
import { GetUserAccountBalanceHistoryResponse } from '../model/getUserAccountBalanceHistoryResponse';
import { GetUserCategoryMonthlyExpenditureResponse } from '../model/getUserCategoryMonthlyExpenditureResponse';
import { GetUserCategoryMonthlyIncomeResponse } from '../model/getUserCategoryMonthlyIncomeResponse';
import { GetUserProfileResponse1 } from '../model/getUserProfileResponse1';
import { GoneErrorMessageResponse } from '../model/goneErrorMessageResponse';
import { HealthCheckResponse } from '../model/healthCheckResponse';
import { InternalErrorMessageResponse } from '../model/internalErrorMessageResponse';
import { ListRecurringTransactionNotesResponse } from '../model/listRecurringTransactionNotesResponse';
import { ListRecurringTransactionsForUserAndAccountResponse } from '../model/listRecurringTransactionsForUserAndAccountResponse';
import { ListTransactionNotesResponse } from '../model/listTransactionNotesResponse';
import { ListTransactionsAcrossAllAccountsResponse } from '../model/listTransactionsAcrossAllAccountsResponse';
import { ListTransactionsResponse } from '../model/listTransactionsResponse';
import { MethodNotAllowedErrorMessageResponse } from '../model/methodNotAllowedErrorMessageResponse';
import { NotFoundErrorMessageResponse } from '../model/notFoundErrorMessageResponse';
import { NotImplementedErrorMessageResponse } from '../model/notImplementedErrorMessageResponse';
import { PaymentRequiredErrorMessageResponse } from '../model/paymentRequiredErrorMessageResponse';
import { PlaidExchangeTokenRequest } from '../model/plaidExchangeTokenRequest';
import { PlaidExchangeTokenResponse } from '../model/plaidExchangeTokenResponse';
import { PlaidInitiateTokenExchangeRequest } from '../model/plaidInitiateTokenExchangeRequest';
import { PlaidInitiateTokenExchangeResponse } from '../model/plaidInitiateTokenExchangeResponse';
import { PlaidInitiateTokenUpdateRequest } from '../model/plaidInitiateTokenUpdateRequest';
import { PlaidInitiateTokenUpdateResponse } from '../model/plaidInitiateTokenUpdateResponse';
import { PlaidSyncAccountFromAccessTokenRequest } from '../model/plaidSyncAccountFromAccessTokenRequest';
import { PlaidSyncAccountFromAccessTokenResponse } from '../model/plaidSyncAccountFromAccessTokenResponse';
import { PollAsyncTaskExecutionStatusResponse } from '../model/pollAsyncTaskExecutionStatusResponse';
import { PreconditionFailedErrorMessageResponse } from '../model/preconditionFailedErrorMessageResponse';
import { RateLimitErrorMessageResponse } from '../model/rateLimitErrorMessageResponse';
import { ReadynessCheckResponse2 } from '../model/readynessCheckResponse2';
import { RecordAskCopilotQuestionRequest } from '../model/recordAskCopilotQuestionRequest';
import { RecordAskCopilotQuestionResponse } from '../model/recordAskCopilotQuestionResponse';
import { SearchTransactionsRequest } from '../model/searchTransactionsRequest';
import { SearchTransactionsResponse } from '../model/searchTransactionsResponse';
import { ServiceUnavailableErrorMessageResponse } from '../model/serviceUnavailableErrorMessageResponse';
import { SplitTransactionRequest } from '../model/splitTransactionRequest';
import { SplitTransactionResponse } from '../model/splitTransactionResponse';
import { Status } from '../model/status';
import { TooEarlyErrorMessageResponse } from '../model/tooEarlyErrorMessageResponse';
import { TriggerSyncRequest } from '../model/triggerSyncRequest';
import { TriggerSyncResponse } from '../model/triggerSyncResponse';
import { UnSplitTransactionsRequest } from '../model/unSplitTransactionsRequest';
import { UnSplitTransactionsResponse } from '../model/unSplitTransactionsResponse';
import { UnprocessableEntityErrorMessageResponse } from '../model/unprocessableEntityErrorMessageResponse';
import { UpdateBankAccountRequest } from '../model/updateBankAccountRequest';
import { UpdateBankAccountResponse } from '../model/updateBankAccountResponse';
import { UpdateBudgetRequest } from '../model/updateBudgetRequest';
import { UpdateBudgetResponse } from '../model/updateBudgetResponse';
import { UpdateMilestoneRequest } from '../model/updateMilestoneRequest';
import { UpdateMilestoneResponse } from '../model/updateMilestoneResponse';
import { UpdateNoteToRecurringTransactionRequest } from '../model/updateNoteToRecurringTransactionRequest';
import { UpdateNoteToRecurringTransactionResponse } from '../model/updateNoteToRecurringTransactionResponse';
import { UpdateNoteToSmartGoalRequest } from '../model/updateNoteToSmartGoalRequest';
import { UpdateNoteToSmartGoalResponse } from '../model/updateNoteToSmartGoalResponse';
import { UpdateNoteToTransactionRequest } from '../model/updateNoteToTransactionRequest';
import { UpdateNoteToTransactionResponse } from '../model/updateNoteToTransactionResponse';
import { UpdatePocketRequest } from '../model/updatePocketRequest';
import { UpdatePocketResponse } from '../model/updatePocketResponse';
import { UpdateRecurringTransactionRequest } from '../model/updateRecurringTransactionRequest';
import { UpdateRecurringTransactionResponse } from '../model/updateRecurringTransactionResponse';
import { UpdateSingleTransactionRequest } from '../model/updateSingleTransactionRequest';
import { UpdateSingleTransactionResponse } from '../model/updateSingleTransactionResponse';
import { UpdateSmartGoalRequest } from '../model/updateSmartGoalRequest';
import { UpdateSmartGoalResponse } from '../model/updateSmartGoalResponse';
import { UpdateUserProfileRequest } from '../model/updateUserProfileRequest';
import { UpdateUserProfileResponse } from '../model/updateUserProfileResponse';
import { ValidationErrorMessageResponse } from '../model/validationErrorMessageResponse';

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from '../model/models';
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://user-service.platform.svc.cluster.local:9896';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum FinancialServiceApiApiKeys {
  ApiKeyAuth,
  Bearer,
}

export class FinancialServiceApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    ApiKeyAuth: new ApiKeyAuth('header', 'X-API-Key'),
    Bearer: new ApiKeyAuth('header', 'Authorization'),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: FinancialServiceApiApiKeys, value: string) {
    (this.authentications as any)[FinancialServiceApiApiKeys[key]].apiKey =
      value;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * This endpoint adds a default pocket to a specific bank account of interest
   * @summary adds a default set of pockets to a specific bank account of interest
   * @param addDefaultPocketsToBankAccountRequest
   */
  public async addDefaultPocketsToBankAccount(
    addDefaultPocketsToBankAccountRequest: AddDefaultPocketsToBankAccountRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddDefaultPocketsToBankAccountResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/pocket/bank-account';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'addDefaultPocketsToBankAccountRequest' is not null or undefined
    if (
      addDefaultPocketsToBankAccountRequest === null ||
      addDefaultPocketsToBankAccountRequest === undefined
    ) {
      throw new Error(
        'Required parameter addDefaultPocketsToBankAccountRequest was null or undefined when calling addDefaultPocketsToBankAccount.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addDefaultPocketsToBankAccountRequest,
        'AddDefaultPocketsToBankAccountRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddDefaultPocketsToBankAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddDefaultPocketsToBankAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a note to a business account
   * @summary Adds a note to a business account
   * @param addNoteToFinancialUserProfileRequest
   */
  public async addNoteToFinancialUserProfile(
    addNoteToFinancialUserProfileRequest: AddNoteToFinancialUserProfileRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddNoteToFinancialUserProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/business/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'addNoteToFinancialUserProfileRequest' is not null or undefined
    if (
      addNoteToFinancialUserProfileRequest === null ||
      addNoteToFinancialUserProfileRequest === undefined
    ) {
      throw new Error(
        'Required parameter addNoteToFinancialUserProfileRequest was null or undefined when calling addNoteToFinancialUserProfile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addNoteToFinancialUserProfileRequest,
        'AddNoteToFinancialUserProfileRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddNoteToFinancialUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddNoteToFinancialUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a note to a transaction
   * @summary adds a note to a transaction
   * @param addNoteToRecurringTransactionRequest
   */
  public async addNoteToRecurringTransaction(
    addNoteToRecurringTransactionRequest: AddNoteToRecurringTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddNoteToRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'addNoteToRecurringTransactionRequest' is not null or undefined
    if (
      addNoteToRecurringTransactionRequest === null ||
      addNoteToRecurringTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter addNoteToRecurringTransactionRequest was null or undefined when calling addNoteToRecurringTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addNoteToRecurringTransactionRequest,
        'AddNoteToRecurringTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddNoteToRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddNoteToRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a note to a smart goal
   * @summary adds a note to a smart goal
   * @param addNoteToSmartGoalRequest
   */
  public async addNoteToSmartGoal(
    addNoteToSmartGoalRequest: AddNoteToSmartGoalRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddNoteToSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/smart-goal/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'addNoteToSmartGoalRequest' is not null or undefined
    if (
      addNoteToSmartGoalRequest === null ||
      addNoteToSmartGoalRequest === undefined
    ) {
      throw new Error(
        'Required parameter addNoteToSmartGoalRequest was null or undefined when calling addNoteToSmartGoal.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addNoteToSmartGoalRequest,
        'AddNoteToSmartGoalRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddNoteToSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddNoteToSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a note to a transaction
   * @summary adds a note to a transaction
   * @param addNoteToTransactionRequest
   */
  public async addNoteToTransaction(
    addNoteToTransactionRequest: AddNoteToTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddNoteToTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'addNoteToTransactionRequest' is not null or undefined
    if (
      addNoteToTransactionRequest === null ||
      addNoteToTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter addNoteToTransactionRequest was null or undefined when calling addNoteToTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addNoteToTransactionRequest,
        'AddNoteToTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddNoteToTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddNoteToTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds transactions to a manually linked account
   * @summary Adds transactions to a manually linked account
   * @param addTransactionsToManuallyLinkedAccountRequest Add transactions to an account.
   */
  public async addTransactionsToManuallyLinkedAccount(
    addTransactionsToManuallyLinkedAccountRequest: AddTransactionsToManuallyLinkedAccountRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddTransactionsToManuallyLinkedAccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/manual-linked-account/transactions';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'addTransactionsToManuallyLinkedAccountRequest' is not null or undefined
    if (
      addTransactionsToManuallyLinkedAccountRequest === null ||
      addTransactionsToManuallyLinkedAccountRequest === undefined
    ) {
      throw new Error(
        'Required parameter addTransactionsToManuallyLinkedAccountRequest was null or undefined when calling addTransactionsToManuallyLinkedAccount.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addTransactionsToManuallyLinkedAccountRequest,
        'AddTransactionsToManuallyLinkedAccountRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddTransactionsToManuallyLinkedAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddTransactionsToManuallyLinkedAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint checks if a user can ask his/her copilot a question
   * @summary Ask a question to copilot
   * @param recordAskCopilotQuestionRequest
   */
  public async askCopilotQuestion(
    recordAskCopilotQuestionRequest: RecordAskCopilotQuestionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RecordAskCopilotQuestionResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/copilot/quota/question';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'recordAskCopilotQuestionRequest' is not null or undefined
    if (
      recordAskCopilotQuestionRequest === null ||
      recordAskCopilotQuestionRequest === undefined
    ) {
      throw new Error(
        'Required parameter recordAskCopilotQuestionRequest was null or undefined when calling askCopilotQuestion.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        recordAskCopilotQuestionRequest,
        'RecordAskCopilotQuestionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RecordAskCopilotQuestionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RecordAskCopilotQuestionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a set of transactions
   * @summary update a transaction
   * @param bulkUpdateRecurringTransactionRequest
   */
  public async bulkUpdateRecurringTransaction(
    bulkUpdateRecurringTransactionRequest: BulkUpdateRecurringTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BulkUpdateRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/bulk';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'bulkUpdateRecurringTransactionRequest' is not null or undefined
    if (
      bulkUpdateRecurringTransactionRequest === null ||
      bulkUpdateRecurringTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter bulkUpdateRecurringTransactionRequest was null or undefined when calling bulkUpdateRecurringTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        bulkUpdateRecurringTransactionRequest,
        'BulkUpdateRecurringTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BulkUpdateRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BulkUpdateRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a set of transactions
   * @summary update a transaction
   * @param bulkUpdateTransactionRequest
   */
  public async bulkUpdateTransaction(
    bulkUpdateTransactionRequest: BulkUpdateTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BulkUpdateTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/bulk';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'bulkUpdateTransactionRequest' is not null or undefined
    if (
      bulkUpdateTransactionRequest === null ||
      bulkUpdateTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter bulkUpdateTransactionRequest was null or undefined when calling bulkUpdateTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        bulkUpdateTransactionRequest,
        'BulkUpdateTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BulkUpdateTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BulkUpdateTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint checks if a user has exceeded his/her copilot question quota
   * @summary Checks if the question quota has been exceeded
   * @param userId the account id associated with the user
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async checkIfQuotaExceeded(
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CheckIfQuotaExceededResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/copilot/quota/exceeded/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling checkIfQuotaExceeded.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling checkIfQuotaExceeded.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling checkIfQuotaExceeded.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling checkIfQuotaExceeded.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CheckIfQuotaExceededResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CheckIfQuotaExceededResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a bank account for a given user profile
   * @summary create a bank account for a given user profile
   * @param createBankAccountRequest
   */
  public async createBankAccount(
    createBankAccountRequest: CreateBankAccountRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateBankAccountResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/bank-account/profile';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createBankAccountRequest' is not null or undefined
    if (
      createBankAccountRequest === null ||
      createBankAccountRequest === undefined
    ) {
      throw new Error(
        'Required parameter createBankAccountRequest was null or undefined when calling createBankAccount.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createBankAccountRequest,
        'CreateBankAccountRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateBankAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateBankAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a budget
   * @summary create a budget
   * @param createBudgetRequest
   */
  public async createBudget(
    createBudgetRequest: CreateBudgetRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateBudgetResponse }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/budget';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createBudgetRequest' is not null or undefined
    if (createBudgetRequest === null || createBudgetRequest === undefined) {
      throw new Error(
        'Required parameter createBudgetRequest was null or undefined when calling createBudget.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createBudgetRequest,
        'CreateBudgetRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateBudgetResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateBudgetResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a credit account for a given user profile
   * @summary create a credit account for a given user profile
   * @param createCreditAccountRequest
   */
  public async createCreditAccount(
    createCreditAccountRequest: CreateCreditAccountRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateCreditAccountResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/credit-account/profile';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createCreditAccountRequest' is not null or undefined
    if (
      createCreditAccountRequest === null ||
      createCreditAccountRequest === undefined
    ) {
      throw new Error(
        'Required parameter createCreditAccountRequest was null or undefined when calling createCreditAccount.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createCreditAccountRequest,
        'CreateCreditAccountRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCreditAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCreditAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a link
   * @summary create link
   * @param createManualLinkRequest
   */
  public async createLink(
    createManualLinkRequest: CreateManualLinkRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateManualLinkResponse;
  }> {
    const localVarPath = this.basePath + '/financial-microservice/api/v1/link';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createManualLinkRequest' is not null or undefined
    if (
      createManualLinkRequest === null ||
      createManualLinkRequest === undefined
    ) {
      throw new Error(
        'Required parameter createManualLinkRequest was null or undefined when calling createLink.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createManualLinkRequest,
        'CreateManualLinkRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateManualLinkResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateManualLinkResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a milestone
   * @summary create a milestone
   * @param createMilestoneRequest
   */
  public async createMilestone(
    createMilestoneRequest: CreateMilestoneRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateMilestoneResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/milestone';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createMilestoneRequest' is not null or undefined
    if (
      createMilestoneRequest === null ||
      createMilestoneRequest === undefined
    ) {
      throw new Error(
        'Required parameter createMilestoneRequest was null or undefined when calling createMilestone.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createMilestoneRequest,
        'CreateMilestoneRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateMilestoneResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateMilestoneResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a smart goal
   * @summary create a smart goal
   * @param createSmartGoalRequest
   */
  public async createSmartGoal(
    createSmartGoalRequest: CreateSmartGoalRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/smart-goal';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createSmartGoalRequest' is not null or undefined
    if (
      createSmartGoalRequest === null ||
      createSmartGoalRequest === undefined
    ) {
      throw new Error(
        'Required parameter createSmartGoalRequest was null or undefined when calling createSmartGoal.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createSmartGoalRequest,
        'CreateSmartGoalRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enabled a user to create a new subscription against stripe
   * @summary Creates a new subscription for a given customer against stripe
   * @param createSubscriptionRequest
   */
  public async createSubscription(
    createSubscriptionRequest: CreateSubscriptionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateSubscriptionResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/stripe/subscription';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createSubscriptionRequest' is not null or undefined
    if (
      createSubscriptionRequest === null ||
      createSubscriptionRequest === undefined
    ) {
      throw new Error(
        'Required parameter createSubscriptionRequest was null or undefined when calling createSubscription.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createSubscriptionRequest,
        'CreateSubscriptionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateSubscriptionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateSubscriptionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs an a creation operation of a user profile based on the provided parametersThis operation is implemented as a distributed transactions as this operation can span multiple services
   * @summary create a user profile
   * @param createUserProfileRequest1 CreateUserProfileRequest represents the request object for creating a user profile in the financial service. This message encapsulates the essential information needed to establish a new financial user profile, including identification, contact details, and the type of financial profile.
   */
  public async createUserProfile1(
    createUserProfileRequest1: CreateUserProfileRequest1,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateUserProfileResponse1;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/profile';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createUserProfileRequest1' is not null or undefined
    if (
      createUserProfileRequest1 === null ||
      createUserProfileRequest1 === undefined
    ) {
      throw new Error(
        'Required parameter createUserProfileRequest1 was null or undefined when calling createUserProfile1.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUserProfileRequest1,
        'CreateUserProfileRequest1'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateUserProfileResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateUserProfileResponse1'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a budget
   * @summary delete a budget
   * @param budgetId The budget id Validations: - budget_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteBudget(
    budgetId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteBudgetResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/budget/{budgetId}'.replace(
        '{' + 'budgetId' + '}',
        encodeURIComponent(String(budgetId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'budgetId' is not null or undefined
    if (budgetId === null || budgetId === undefined) {
      throw new Error(
        'Required parameter budgetId was null or undefined when calling deleteBudget.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteBudget.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteBudget.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteBudget.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteBudget.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteBudgetResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteBudgetResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes the link if the link exists
   * @summary delete link by id
   * @param linkId The link id Validations: - link_id must be greater than 0
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteLink(
    linkId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteLinkResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/link/{linkId}/user/{userId}'
        .replace('{' + 'linkId' + '}', encodeURIComponent(String(linkId)))
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'linkId' is not null or undefined
    if (linkId === null || linkId === undefined) {
      throw new Error(
        'Required parameter linkId was null or undefined when calling deleteLink.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteLink.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteLink.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteLink.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteLink.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteLinkResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteLinkResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a milestone
   * @summary delete a milestone
   * @param milestoneId The milestone id Validations: - milestone_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteMilestone(
    milestoneId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteMilestoneResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/milestone/{milestoneId}'.replace(
        '{' + 'milestoneId' + '}',
        encodeURIComponent(String(milestoneId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'milestoneId' is not null or undefined
    if (milestoneId === null || milestoneId === undefined) {
      throw new Error(
        'Required parameter milestoneId was null or undefined when calling deleteMilestone.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteMilestone.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteMilestone.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteMilestone.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteMilestone.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteMilestoneResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteMilestoneResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a note from a transaction
   * @summary deletes a note from a transaction
   * @param transactionId The transaction id Validations: - transaction_id must be greater than 0
   * @param noteId The note id Validations: - note_id must be greater than 0
   * @param userId The user id
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteNoteFromRecurringTransaction(
    transactionId: string,
    noteId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteNoteFromRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/{transactionId}/note/{noteId}'
        .replace(
          '{' + 'transactionId' + '}',
          encodeURIComponent(String(transactionId))
        )
        .replace('{' + 'noteId' + '}', encodeURIComponent(String(noteId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling deleteNoteFromRecurringTransaction.'
      );
    }

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling deleteNoteFromRecurringTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteNoteFromRecurringTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteNoteFromRecurringTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteNoteFromRecurringTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteNoteFromRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteNoteFromRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a note from a smart goal
   * @summary deletes a note from a smart goal
   * @param noteId The note id Validations: - note_id must be greater than 0
   * @param smartGoalId The smart goal id Validations: - smart_goal_id must be greater than 0
   * @param userId The user id
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteNoteFromSmartGoal(
    noteId: string,
    smartGoalId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteNoteFromSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/smart-goal/note/{noteId}'.replace(
        '{' + 'noteId' + '}',
        encodeURIComponent(String(noteId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling deleteNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'smartGoalId' is not null or undefined
    if (smartGoalId === null || smartGoalId === undefined) {
      throw new Error(
        'Required parameter smartGoalId was null or undefined when calling deleteNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteNoteFromSmartGoal.'
      );
    }

    if (smartGoalId !== undefined) {
      localVarQueryParameters['smartGoalId'] = ObjectSerializer.serialize(
        smartGoalId,
        'string'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteNoteFromSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteNoteFromSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a note from a transaction
   * @summary deletes a note from a transaction
   * @param transactionId The transaction id Validations: - transaction_id must be greater than 0
   * @param noteId The note id Validations: - note_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteNoteFromTransaction(
    transactionId: string,
    noteId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteNoteFromTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/{transactionId}/note/{noteId}'
        .replace(
          '{' + 'transactionId' + '}',
          encodeURIComponent(String(transactionId))
        )
        .replace('{' + 'noteId' + '}', encodeURIComponent(String(noteId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling deleteNoteFromTransaction.'
      );
    }

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling deleteNoteFromTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteNoteFromTransaction.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteNoteFromTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteNoteFromTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteNoteFromTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteNoteFromTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteNoteFromTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a pocket
   * @summary deletes a pocket
   * @param pocketId The pocket id Validations: - pocket_id must be greater than 0
   * @param userId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deletePocket(
    pocketId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeletePocketResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/pocket/{pocketId}'.replace(
        '{' + 'pocketId' + '}',
        encodeURIComponent(String(pocketId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'pocketId' is not null or undefined
    if (pocketId === null || pocketId === undefined) {
      throw new Error(
        'Required parameter pocketId was null or undefined when calling deletePocket.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deletePocket.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deletePocket.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deletePocket.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deletePocket.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeletePocketResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeletePocketResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a smart goal
   * @summary delete a smart goal
   * @param smartGoalId The smart goal id Validations: - smart_goal_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteSmartGoal(
    smartGoalId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/smart-goal/{smartGoalId}'.replace(
        '{' + 'smartGoalId' + '}',
        encodeURIComponent(String(smartGoalId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'smartGoalId' is not null or undefined
    if (smartGoalId === null || smartGoalId === undefined) {
      throw new Error(
        'Required parameter smartGoalId was null or undefined when calling deleteSmartGoal.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteSmartGoal.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteSmartGoal.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteSmartGoal.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteSmartGoal.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a specific transaction based on the transaction id
   * @summary deletes a transaction by id
   * @param transactionId the transaction of interest we aim to delete
   * @param userId The user id
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteTransaction(
    transactionId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/{transactionId}'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling deleteTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteTransaction.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a specific transaction based on the transaction id
   * @summary deletes a transaction by id
   * @param transactionId the transaction of interest we aim to delete
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteTransaction1(
    transactionId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/{transactionId}'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling deleteTransaction1.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteTransaction1.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteTransaction1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteTransaction1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteTransaction1.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a delete operation on a user profile based on the provided parametersThis deletion operation spans multiple services (plaid) as user details are stored across a suite of our backend servicesThe operation itself is an atomic one of nature. Either all services successfully delete the recod or we fail the requestDivergent state is not expected to be encountered with this endpoint.
   * @summary deletes a bank account for a given user profile
   * @param bankAccountId The bank account id Validations: - bank_account_id must be greater than 0
   * @param userId The account ID associated with the user Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteUserProfile1(
    bankAccountId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteBankAccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/bank-account/{bankAccountId}'.replace(
        '{' + 'bankAccountId' + '}',
        encodeURIComponent(String(bankAccountId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'bankAccountId' is not null or undefined
    if (bankAccountId === null || bankAccountId === undefined) {
      throw new Error(
        'Required parameter bankAccountId was null or undefined when calling deleteUserProfile1.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteUserProfile1.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteUserProfile1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteUserProfile1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteUserProfile1.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteBankAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteBankAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a delete operation on a user profile based on the provided parameters
   * @summary deletes a user profile
   * @param userId The account ID associated with the user. NOTE: This user_id is the simfiny backend platform wide user id Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async deleteUserProfile2(
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteUserProfileResponse1;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/profile/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteUserProfile2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteUserProfile2.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteUserProfile2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteUserProfile2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteUserProfileResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteUserProfileResponse1'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the historical balance for a given account
   * @summary gets account balance of an account
   * @param userId
   * @param plaidAccountId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param profileType
   */
  public async getAccountBalance(
    userId: string,
    plaidAccountId: string,
    orgId: string,
    tenantId: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetHistoricalAccountBalanceResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/historical-account-balance/user/{userId}/plaid-account-id/{plaidAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'plaidAccountId' + '}',
          encodeURIComponent(String(plaidAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getAccountBalance.'
      );
    }

    // verify required parameter 'plaidAccountId' is not null or undefined
    if (plaidAccountId === null || plaidAccountId === undefined) {
      throw new Error(
        'Required parameter plaidAccountId was null or undefined when calling getAccountBalance.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getAccountBalance.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getAccountBalance.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetHistoricalAccountBalanceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetHistoricalAccountBalanceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This API could accept account_id as input parameters and return the account balance history for that account.
   * @summary Returns the account balance history for an account
   * @param plaidAccountId Account ID
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType Type of financial user profile
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getAccountBalanceHistory(
    plaidAccountId: string,
    pageNumber: string,
    pageSize: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetAccountBalanceHistoryResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/balance-history/account/{plaidAccountId}/pagenumber/{pageNumber}/pagesize/{pageSize}'
        .replace(
          '{' + 'plaidAccountId' + '}',
          encodeURIComponent(String(plaidAccountId))
        )
        .replace(
          '{' + 'pageNumber' + '}',
          encodeURIComponent(String(pageNumber))
        )
        .replace('{' + 'pageSize' + '}', encodeURIComponent(String(pageSize)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'plaidAccountId' is not null or undefined
    if (plaidAccountId === null || plaidAccountId === undefined) {
      throw new Error(
        'Required parameter plaidAccountId was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getAccountBalanceHistory.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAccountBalanceHistoryResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAccountBalanceHistoryResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns all budgets
   * @summary get all budgets
   * @param pocketId The pocket account id Validations: - pocket_account_id must be greater than 0
   * @param smartGoalId The smart goal id Validations: - smart_goal_id must be greater than 0
   * @param milestoneId The milestone id Validations: - milestone_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getAllBudgets(
    pocketId: string,
    smartGoalId: string,
    milestoneId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetAllBudgetsResponse }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/budget';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'pocketId' is not null or undefined
    if (pocketId === null || pocketId === undefined) {
      throw new Error(
        'Required parameter pocketId was null or undefined when calling getAllBudgets.'
      );
    }

    // verify required parameter 'smartGoalId' is not null or undefined
    if (smartGoalId === null || smartGoalId === undefined) {
      throw new Error(
        'Required parameter smartGoalId was null or undefined when calling getAllBudgets.'
      );
    }

    // verify required parameter 'milestoneId' is not null or undefined
    if (milestoneId === null || milestoneId === undefined) {
      throw new Error(
        'Required parameter milestoneId was null or undefined when calling getAllBudgets.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getAllBudgets.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getAllBudgets.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getAllBudgets.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getAllBudgets.'
      );
    }

    if (pocketId !== undefined) {
      localVarQueryParameters['pocketId'] = ObjectSerializer.serialize(
        pocketId,
        'string'
      );
    }

    if (smartGoalId !== undefined) {
      localVarQueryParameters['smartGoalId'] = ObjectSerializer.serialize(
        smartGoalId,
        'string'
      );
    }

    if (milestoneId !== undefined) {
      localVarQueryParameters['milestoneId'] = ObjectSerializer.serialize(
        milestoneId,
        'string'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAllBudgetsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAllBudgetsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the bank account if the user record id and bank account id exists example: /api/v1/bank-account?user_id=xxxxxx&&bank_account_id=xxxxxxx
   * @summary get a bank account for a given user profile
   * @param bankAccountId The bank account id Validations: - bank_account_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getBankAccount(
    bankAccountId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetBankAccountResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/bank-account/{bankAccountId}'.replace(
        '{' + 'bankAccountId' + '}',
        encodeURIComponent(String(bankAccountId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'bankAccountId' is not null or undefined
    if (bankAccountId === null || bankAccountId === undefined) {
      throw new Error(
        'Required parameter bankAccountId was null or undefined when calling getBankAccount.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getBankAccount.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getBankAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getBankAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getBankAccount.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetBankAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetBankAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the budget if the budget exists
   * @summary get budget by id
   * @param budgetId The budget id Validations: - budget_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getBudget(
    budgetId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetBudgetResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/budget/{budgetId}'.replace(
        '{' + 'budgetId' + '}',
        encodeURIComponent(String(budgetId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'budgetId' is not null or undefined
    if (budgetId === null || budgetId === undefined) {
      throw new Error(
        'Required parameter budgetId was null or undefined when calling getBudget.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getBudget.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getBudget.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getBudget.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getBudget.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetBudgetResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetBudgetResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets category metrics for a financial sub profile over time
   * @summary Gets category metrics for a financial sub profile over time
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param userId
   * @param profileType
   * @param personalFinanceCategoryPrimary
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   */
  public async getCategoryMetricsFinancialSubProfileOverTime(
    orgId: string,
    tenantId: string,
    userId?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    personalFinanceCategoryPrimary?: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCategoryMetricsFinancialSubProfileOverTimeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/category-metrics';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCategoryMetricsFinancialSubProfileOverTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCategoryMetricsFinancialSubProfileOverTime.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCategoryMetricsFinancialSubProfileOverTimeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCategoryMetricsFinancialSubProfileOverTimeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get monthly transaction count by user, month, and category
   * @param userId has to be present and defined
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param personalFinanceCategoryPrimary optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getCategoryMonthlyTransactionCount(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    personalFinanceCategoryPrimary?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCategoryMonthlyTransactionCountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/category-monthly-transaction-count/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCategoryMonthlyTransactionCount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCategoryMonthlyTransactionCount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCategoryMonthlyTransactionCount.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCategoryMonthlyTransactionCountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCategoryMonthlyTransactionCountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Debt-to-Income ratio by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getDebtToIncomeRatio(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetDebtToIncomeRatioResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/debt-to-income-ratio/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getDebtToIncomeRatio.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getDebtToIncomeRatio.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getDebtToIncomeRatio.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetDebtToIncomeRatioResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetDebtToIncomeRatioResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Expense Metrics by user, month and category
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optonal
   * @param personalFinanceCategoryPrimary optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getExpenseMetrics(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    personalFinanceCategoryPrimary?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetExpenseMetricsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/expenses/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getExpenseMetrics.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getExpenseMetrics.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getExpenseMetrics.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetExpenseMetricsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetExpenseMetricsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets expense metrics for a financial sub profile over time
   * @summary Gets expense metrics for a financial sub profile over time
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param userId
   * @param profileType
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   */
  public async getExpenseMetricsFinancialSubProfileOverTime(
    orgId: string,
    tenantId: string,
    userId?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetExpenseMetricsFinancialSubProfileOverTimeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/expense-metrics';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getExpenseMetricsFinancialSubProfileOverTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getExpenseMetricsFinancialSubProfileOverTime.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetExpenseMetricsFinancialSubProfileOverTimeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetExpenseMetricsFinancialSubProfileOverTimeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Financial Profile by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getFinancialProfile(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetFinancialProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/finance-profile/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getFinancialProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getFinancialProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getFinancialProfile.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetFinancialProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetFinancialProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the forecast if the forecast exists
   * @summary get forecast by id
   * @param smartGoalId The smart goal id Validations: - smart_goal_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getForecast(
    smartGoalId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetForecastResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/forecast/{smartGoalId}'.replace(
        '{' + 'smartGoalId' + '}',
        encodeURIComponent(String(smartGoalId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'smartGoalId' is not null or undefined
    if (smartGoalId === null || smartGoalId === undefined) {
      throw new Error(
        'Required parameter smartGoalId was null or undefined when calling getForecast.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getForecast.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getForecast.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getForecast.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getForecast.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetForecastResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetForecastResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Income Expense Ratio by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getIncomeExpenseRatio(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetIncomeExpenseRatioResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/income-expense-ratio/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getIncomeExpenseRatio.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getIncomeExpenseRatio.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getIncomeExpenseRatio.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetIncomeExpenseRatioResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetIncomeExpenseRatioResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Income Metrics by user, month and category
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param personalFinanceCategoryPrimary optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getIncomeMetrics(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    personalFinanceCategoryPrimary?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetIncomeMetricsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/income/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getIncomeMetrics.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getIncomeMetrics.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getIncomeMetrics.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetIncomeMetricsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetIncomeMetricsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets expense metrics for a financial sub profile over time
   * @summary Gets income metrics for a financial sub profile over time
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param userId
   * @param profileType
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   */
  public async getIncomeMetricsFinancialSubProfileOverTime(
    orgId: string,
    tenantId: string,
    userId?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetIncomeMetricsFinancialSubProfileOverTimeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/income-metrics';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getIncomeMetricsFinancialSubProfileOverTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getIncomeMetricsFinancialSubProfileOverTime.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetIncomeMetricsFinancialSubProfileOverTimeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetIncomeMetricsFinancialSubProfileOverTimeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the investment account if the investment account exists
   * @summary get investment account by id
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param investmentAccountId The investment account id Validations: - investment_account_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getInvestmentAccount(
    userId: string,
    investmentAccountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetInvestmentAcccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/account/{userId}/investment/{investmentAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'investmentAccountId' + '}',
          encodeURIComponent(String(investmentAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getInvestmentAccount.'
      );
    }

    // verify required parameter 'investmentAccountId' is not null or undefined
    if (investmentAccountId === null || investmentAccountId === undefined) {
      throw new Error(
        'Required parameter investmentAccountId was null or undefined when calling getInvestmentAccount.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getInvestmentAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getInvestmentAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getInvestmentAccount.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetInvestmentAcccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetInvestmentAcccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the liability account if the liability account exists
   * @summary get liability account by id
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param liabilityAccountId The liability account id Validations: - liability_account_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getLiabilityAccount(
    userId: string,
    liabilityAccountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetLiabilityAccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/account/{userId}/liability/{liabilityAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'liabilityAccountId' + '}',
          encodeURIComponent(String(liabilityAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getLiabilityAccount.'
      );
    }

    // verify required parameter 'liabilityAccountId' is not null or undefined
    if (liabilityAccountId === null || liabilityAccountId === undefined) {
      throw new Error(
        'Required parameter liabilityAccountId was null or undefined when calling getLiabilityAccount.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getLiabilityAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getLiabilityAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getLiabilityAccount.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetLiabilityAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetLiabilityAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the link if the link exists
   * @summary get link by id
   * @param linkId The link id Validations: - link_id must be greater than 0
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getLink(
    linkId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetLinkResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/link/{linkId}'.replace(
        '{' + 'linkId' + '}',
        encodeURIComponent(String(linkId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'linkId' is not null or undefined
    if (linkId === null || linkId === undefined) {
      throw new Error(
        'Required parameter linkId was null or undefined when calling getLink.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getLink.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getLink.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getLink.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getLink.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetLinkResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetLinkResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the links
   * @summary get links
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getLinks(
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetLinksResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/links/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getLinks.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getLinks.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getLinks.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getLinks.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetLinksResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetLinksResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets location metrics for a financial sub profile over time
   * @summary Gets income metrics for a financial sub profile over time
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param userId
   * @param profileType
   * @param month
   * @param locationCity
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   */
  public async getLocationMetricsFinancialSubProfileOverTime(
    orgId: string,
    tenantId: string,
    userId?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    month?: number,
    locationCity?: string,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetLocationMetricsFinancialSubProfileOverTimeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/location-metrics';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getLocationMetricsFinancialSubProfileOverTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getLocationMetricsFinancialSubProfileOverTime.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (locationCity !== undefined) {
      localVarQueryParameters['locationCity'] = ObjectSerializer.serialize(
        locationCity,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetLocationMetricsFinancialSubProfileOverTimeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetLocationMetricsFinancialSubProfileOverTimeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Melody Financial Context
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param profileType
   */
  public async getMelodyFinancialContext(
    userId: string,
    orgId: string,
    tenantId: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMelodyFinancialContextResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/melody-financial-context/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMelodyFinancialContext.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMelodyFinancialContext.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMelodyFinancialContext.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMelodyFinancialContextResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMelodyFinancialContextResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets merchant metrics for a financial sub profile over time
   * @summary Gets merchant metrics for a financial sub profile over time
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param userId
   * @param profileType
   * @param month
   * @param merchantName
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   */
  public async getMerchantMetricsFinancialSubProfileOverTime(
    orgId: string,
    tenantId: string,
    userId?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    month?: number,
    merchantName?: string,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMerchantMetricsFinancialSubProfileOverTimeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/merchant-metrics';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMerchantMetricsFinancialSubProfileOverTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMerchantMetricsFinancialSubProfileOverTime.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (merchantName !== undefined) {
      localVarQueryParameters['merchantName'] = ObjectSerializer.serialize(
        merchantName,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMerchantMetricsFinancialSubProfileOverTimeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMerchantMetricsFinancialSubProfileOverTimeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Merchant Monthly Expenditure by user, month and merchant name
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param merchantName optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMerchantMonthlyExpenditure(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    merchantName?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMerchantMonthlyExpenditureResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/merchant-monthly-expenditure/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMerchantMonthlyExpenditure.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMerchantMonthlyExpenditure.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMerchantMonthlyExpenditure.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (merchantName !== undefined) {
      localVarQueryParameters['merchantName'] = ObjectSerializer.serialize(
        merchantName,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMerchantMonthlyExpenditureResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMerchantMonthlyExpenditureResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the milestone if the milestone exists
   * @summary get milestone by id
   * @param milestoneId The milestone id Validations: - milestone_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getMilestone(
    milestoneId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetMilestoneResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/milestone/{milestoneId}'.replace(
        '{' + 'milestoneId' + '}',
        encodeURIComponent(String(milestoneId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'milestoneId' is not null or undefined
    if (milestoneId === null || milestoneId === undefined) {
      throw new Error(
        'Required parameter milestoneId was null or undefined when calling getMilestone.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMilestone.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getMilestone.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMilestone.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMilestone.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMilestoneResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetMilestoneResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the milestones if the smart goal exists
   * @summary get milestones by smart goal id
   * @param smartGoalId The smart goal id Validations: - smart_goal_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getMilestones(
    smartGoalId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMilestonesBySmartGoalIdResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/milestone/smart-goal/{smartGoalId}'.replace(
        '{' + 'smartGoalId' + '}',
        encodeURIComponent(String(smartGoalId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'smartGoalId' is not null or undefined
    if (smartGoalId === null || smartGoalId === undefined) {
      throw new Error(
        'Required parameter smartGoalId was null or undefined when calling getMilestones.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMilestones.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getMilestones.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMilestones.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMilestones.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMilestonesBySmartGoalIdResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMilestonesBySmartGoalIdResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Monthly Balance by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month optional
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMonthlyBalance(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMonthlyBalanceResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/monthly-balance/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMonthlyBalance.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMonthlyBalance.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMonthlyBalance.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMonthlyBalanceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMonthlyBalanceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Monthly Expenditure by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMonthlyExpenditure(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMonthlyExpenditureResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/monthly-expenditure/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMonthlyExpenditure.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMonthlyExpenditure.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMonthlyExpenditure.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMonthlyExpenditureResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMonthlyExpenditureResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Monthly Income by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMonthlyIncome(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMonthlyIncomeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/monthly-income/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMonthlyIncome.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMonthlyIncome.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMonthlyIncome.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMonthlyIncomeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMonthlyIncomeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Monthly Savings by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMonthlySavings(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMonthlySavingsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/monthly-savings/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMonthlySavings.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMonthlySavings.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMonthlySavings.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMonthlySavingsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMonthlySavingsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Monthly Total Quantity of Security by user, month and security
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param securityId
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMonthlyTotalQuantityBySecurityAndUser(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    securityId?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMonthlyTotalQuantityBySecurityAndUserResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/monthly-total-quantity-by-security-and-user/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMonthlyTotalQuantityBySecurityAndUser.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMonthlyTotalQuantityBySecurityAndUser.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMonthlyTotalQuantityBySecurityAndUser.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (securityId !== undefined) {
      localVarQueryParameters['securityId'] = ObjectSerializer.serialize(
        securityId,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMonthlyTotalQuantityBySecurityAndUserResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMonthlyTotalQuantityBySecurityAndUserResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Monthly Transaction Count by user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getMonthlyTransactionCount(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMonthlyTransactionCountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/monthly-transaction-count/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMonthlyTransactionCount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMonthlyTransactionCount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMonthlyTransactionCount.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMonthlyTransactionCountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMonthlyTransactionCountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the mortgage account if the mortgage account exists
   * @summary get mortgage account by id
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param mortgageAccountId The mortage account id Validations: - mortage_account_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getMortageAccount(
    userId: string,
    mortgageAccountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetMortgageAccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/account/{userId}/mortgage/{mortgageAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'mortgageAccountId' + '}',
          encodeURIComponent(String(mortgageAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getMortageAccount.'
      );
    }

    // verify required parameter 'mortgageAccountId' is not null or undefined
    if (mortgageAccountId === null || mortgageAccountId === undefined) {
      throw new Error(
        'Required parameter mortgageAccountId was null or undefined when calling getMortageAccount.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getMortageAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getMortageAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getMortageAccount.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetMortgageAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetMortgageAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a note from a smart goal
   * @summary gets a note from a smart goal
   * @param noteId The note id Validations: - note_id must be greater than 0
   * @param userId The user id
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getNoteFromSmartGoal(
    noteId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetNoteFromSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/smart-goal/note/{noteId}'.replace(
        '{' + 'noteId' + '}',
        encodeURIComponent(String(noteId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling getNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getNoteFromSmartGoal.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getNoteFromSmartGoal.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetNoteFromSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetNoteFromSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a note from a transaction
   * @summary gets a note from a transaction
   * @param transactionId The transaction id Validations: - transaction_id must be greater than 0
   * @param noteId The note id Validations: - note_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getNoteFromTransaction(
    transactionId: string,
    noteId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetNoteFromTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/{transactionId}/note/{noteId}'
        .replace(
          '{' + 'transactionId' + '}',
          encodeURIComponent(String(transactionId))
        )
        .replace('{' + 'noteId' + '}', encodeURIComponent(String(noteId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling getNoteFromTransaction.'
      );
    }

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling getNoteFromTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getNoteFromTransaction.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getNoteFromTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getNoteFromTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getNoteFromTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetNoteFromTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetNoteFromTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets notes from a business account
   * @summary Gets notes from a business account
   * @param businessAccountUserId The business account id Validations: - business_account_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getNotesFromFinancialUserProfile(
    businessAccountUserId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetNotesFromFinancialUserProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/business/{businessAccountUserId}/{profileType}/note'
        .replace(
          '{' + 'businessAccountUserId' + '}',
          encodeURIComponent(String(businessAccountUserId))
        )
        .replace(
          '{' + 'profileType' + '}',
          encodeURIComponent(String(profileType))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'businessAccountUserId' is not null or undefined
    if (businessAccountUserId === null || businessAccountUserId === undefined) {
      throw new Error(
        'Required parameter businessAccountUserId was null or undefined when calling getNotesFromFinancialUserProfile.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getNotesFromFinancialUserProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getNotesFromFinancialUserProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getNotesFromFinancialUserProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetNotesFromFinancialUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetNotesFromFinancialUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets notes from a smart goal
   * @summary gets notes from a smart goal
   * @param smartGoalId The smart goal id Validations: - smart_goal_id must be greater than 0
   * @param userId The user id
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getNotesFromSmartGoal(
    smartGoalId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetNotesFromSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/smart-goal/{smartGoalId}/note'.replace(
        '{' + 'smartGoalId' + '}',
        encodeURIComponent(String(smartGoalId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'smartGoalId' is not null or undefined
    if (smartGoalId === null || smartGoalId === undefined) {
      throw new Error(
        'Required parameter smartGoalId was null or undefined when calling getNotesFromSmartGoal.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getNotesFromSmartGoal.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getNotesFromSmartGoal.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getNotesFromSmartGoal.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getNotesFromSmartGoal.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetNotesFromSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetNotesFromSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets payment metrics for a financial sub profile over time
   * @summary Gets payment metrics for a financial sub profile over time
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param userId
   * @param profileType
   * @param month
   * @param paymentChannel
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   */
  public async getPaymentChannelFinancialSubProfileOverTime(
    orgId: string,
    tenantId: string,
    userId?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    month?: number,
    paymentChannel?: string,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetPaymentChannelFinancialSubProfileOverTimeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/financial-profile/payment-channel-metrics';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPaymentChannelFinancialSubProfileOverTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPaymentChannelFinancialSubProfileOverTime.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (paymentChannel !== undefined) {
      localVarQueryParameters['paymentChannel'] = ObjectSerializer.serialize(
        paymentChannel,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPaymentChannelFinancialSubProfileOverTimeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPaymentChannelFinancialSubProfileOverTimeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Payment Channel Monthly Expenditure by user, month, and payment channel
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param paymentChannel
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getPaymentChannelMonthlyExpenditure(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    paymentChannel?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetPaymentChannelMonthlyExpenditureResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/payment-channel-expenditure/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPaymentChannelMonthlyExpenditure.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPaymentChannelMonthlyExpenditure.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPaymentChannelMonthlyExpenditure.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (paymentChannel !== undefined) {
      localVarQueryParameters['paymentChannel'] = ObjectSerializer.serialize(
        paymentChannel,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPaymentChannelMonthlyExpenditureResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPaymentChannelMonthlyExpenditureResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the pocket if the pocket exists example: /api/v1/pocket/xxxxxxx
   * @summary get a pocket
   * @param pocketId The pocket account id Validations: - pocket_account_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getPocket(
    pocketId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPocketResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/pocket/{pocketId}'.replace(
        '{' + 'pocketId' + '}',
        encodeURIComponent(String(pocketId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'pocketId' is not null or undefined
    if (pocketId === null || pocketId === undefined) {
      throw new Error(
        'Required parameter pocketId was null or undefined when calling getPocket.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPocket.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getPocket.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPocket.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPocket.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPocketResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetPocketResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a specific transaction based on the transaction id
   * @summary lists a set of transactions against a given account of interest
   * @param transactionId the transaction of interest we aim to obtain
   * @param userId The user id
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getRecurringTransaction(
    transactionId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetSingleRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/{transactionId}'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling getRecurringTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getRecurringTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getRecurringTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getRecurringTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetSingleRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetSingleRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the recurring transactions for a given user id
   * @summary get recurring transactions
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param pageNumber
   * @param pageSize
   */
  public async getRecurringTransactionsForUser(
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetRecurringTransactionsForUserResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring-transactions/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getRecurringTransactionsForUser.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getRecurringTransactionsForUser.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getRecurringTransactionsForUser.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getRecurringTransactionsForUser.'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetRecurringTransactionsForUserResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetRecurringTransactionsForUserResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the smart goals if the pocket exists
   * @summary get smart goals by pocket id
   * @param pocketId The pocket account id Validations: - pocket_account_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getSmartGoalsByPocketId(
    pocketId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetSmartGoalsByPocketIdResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/smart-goal/pocket/{pocketId}'.replace(
        '{' + 'pocketId' + '}',
        encodeURIComponent(String(pocketId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'pocketId' is not null or undefined
    if (pocketId === null || pocketId === undefined) {
      throw new Error(
        'Required parameter pocketId was null or undefined when calling getSmartGoalsByPocketId.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getSmartGoalsByPocketId.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getSmartGoalsByPocketId.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getSmartGoalsByPocketId.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getSmartGoalsByPocketId.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetSmartGoalsByPocketIdResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetSmartGoalsByPocketIdResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a split transaction that was split previously into multiple transactions
   * @summary gets a split transaction
   * @param transactionId The transaction id Validations: - transaction_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getSplitTransaction(
    transactionId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetSplitTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/{transactionId}/split'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling getSplitTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getSplitTransaction.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getSplitTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getSplitTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getSplitTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetSplitTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetSplitTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the student loan account if the student loan account exists
   * @summary get student loan account by id
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param studentLoanAccountId The student loan account id Validations: - student_loan_account_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getStudentLoanAccount(
    userId: string,
    studentLoanAccountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetStudentLoanAccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/account/{userId}/student-loan/{studentLoanAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'studentLoanAccountId' + '}',
          encodeURIComponent(String(studentLoanAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getStudentLoanAccount.'
      );
    }

    // verify required parameter 'studentLoanAccountId' is not null or undefined
    if (studentLoanAccountId === null || studentLoanAccountId === undefined) {
      throw new Error(
        'Required parameter studentLoanAccountId was null or undefined when calling getStudentLoanAccount.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getStudentLoanAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getStudentLoanAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getStudentLoanAccount.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetStudentLoanAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetStudentLoanAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get Total Investment by user and security
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param securityId
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getTotalInvestmentBySecurity(
    userId: string,
    orgId: string,
    tenantId: string,
    securityId?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTotalInvestmentBySecurityResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/total-investment/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTotalInvestmentBySecurity.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTotalInvestmentBySecurity.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTotalInvestmentBySecurity.'
      );
    }

    if (securityId !== undefined) {
      localVarQueryParameters['securityId'] = ObjectSerializer.serialize(
        securityId,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTotalInvestmentBySecurityResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTotalInvestmentBySecurityResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a specific transaction based on the transaction id
   * @summary lists a set of transactions against a given account of interest
   * @param transactionId the transaction of interest we aim to obtain
   * @param userId The user id
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getTransaction(
    transactionId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetTransactionResponse }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/{transactionId}'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling getTransaction.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTransaction.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getTransaction.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTransaction.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTransaction.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the transactions for a given user id and a business account id
   * @summary get transactions tied to a bank account and account id
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param plaidAccountId
   * @param pageNumber
   * @param pageSize
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getTransactions(
    userId: string,
    plaidAccountId: string,
    pageNumber: string,
    pageSize: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransactionsForBankAccountResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/user/{userId}/plaid-account-id/{plaidAccountId}/pageNumber/{pageNumber}/pageSize/{pageSize}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'plaidAccountId' + '}',
          encodeURIComponent(String(plaidAccountId))
        )
        .replace(
          '{' + 'pageNumber' + '}',
          encodeURIComponent(String(pageNumber))
        )
        .replace('{' + 'pageSize' + '}', encodeURIComponent(String(pageSize)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTransactions.'
      );
    }

    // verify required parameter 'plaidAccountId' is not null or undefined
    if (plaidAccountId === null || plaidAccountId === undefined) {
      throw new Error(
        'Required parameter plaidAccountId was null or undefined when calling getTransactions.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getTransactions.'
      );
    }

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getTransactions.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getTransactions.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTransactions.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTransactions.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionsForBankAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionsForBankAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the transactions for a given user id
   * @summary get transactions
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param pageNumber
   * @param pageSize
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async getTransactions1(
    userId: string,
    pageNumber: string,
    pageSize: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransactionsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/{userId}/pageNumber/{pageNumber}/pageSize/{pageSize}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'pageNumber' + '}',
          encodeURIComponent(String(pageNumber))
        )
        .replace('{' + 'pageSize' + '}', encodeURIComponent(String(pageSize)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTransactions1.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getTransactions1.'
      );
    }

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getTransactions1.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getTransactions1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTransactions1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTransactions1.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the transactions for a given user id and time example: /api/v1/users/{user_id}/accounts/{account_id}/transactions?start_time={start_time}&end_time={end_time}
   * @summary get transactions by time
   * @param userId The user id Validations: - user_id must be greater than 0
   * @param accountId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param startDate start date
   * @param endDate end date
   * @param page Current page number
   * @param limit Number of transactions per page
   * @param financialAccountType
   */
  public async getTransactionsByTime(
    userId: string,
    accountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    startDate?: Date,
    endDate?: Date,
    page?: number,
    limit?: number,
    financialAccountType?:
      | 'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED'
      | 'FINANCIAL_ACCOUNT_TYPE_BANK'
      | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT'
      | 'FINANCIAL_ACCOUNT_TYPE_CREDIT'
      | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE'
      | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransactionsBetweenTimeRangesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/users/{userId}/accounts/{accountId}/transactions/range'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'accountId' + '}',
          encodeURIComponent(String(accountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTransactionsByTime.'
      );
    }

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        'Required parameter accountId was null or undefined when calling getTransactionsByTime.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getTransactionsByTime.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTransactionsByTime.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTransactionsByTime.'
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters['startDate'] = ObjectSerializer.serialize(
        startDate,
        'Date'
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters['endDate'] = ObjectSerializer.serialize(
        endDate,
        'Date'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (financialAccountType !== undefined) {
      localVarQueryParameters['financialAccountType'] =
        ObjectSerializer.serialize(
          financialAccountType,
          "'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED' | 'FINANCIAL_ACCOUNT_TYPE_BANK' | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT' | 'FINANCIAL_ACCOUNT_TYPE_CREDIT' | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE' | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN'"
        );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionsBetweenTimeRangesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionsBetweenTimeRangesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the transactions for a given user id over the past month example: /api/v1/users/{user_id}/transactions/month/accounts/{plaid_account_id}
   * @summary Get transactions for the past month
   * @param userId
   * @param plaidAccountId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param page Current page number
   * @param limit Number of transactions per page
   * @param financialAccountType
   */
  public async getTransactionsForPastMonth(
    userId: string,
    plaidAccountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    page?: number,
    limit?: number,
    financialAccountType?:
      | 'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED'
      | 'FINANCIAL_ACCOUNT_TYPE_BANK'
      | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT'
      | 'FINANCIAL_ACCOUNT_TYPE_CREDIT'
      | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE'
      | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransactionsForPastMonthResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/users/{userId}/transactions/month/accounts/{plaidAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'plaidAccountId' + '}',
          encodeURIComponent(String(plaidAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTransactionsForPastMonth.'
      );
    }

    // verify required parameter 'plaidAccountId' is not null or undefined
    if (plaidAccountId === null || plaidAccountId === undefined) {
      throw new Error(
        'Required parameter plaidAccountId was null or undefined when calling getTransactionsForPastMonth.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getTransactionsForPastMonth.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTransactionsForPastMonth.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTransactionsForPastMonth.'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (financialAccountType !== undefined) {
      localVarQueryParameters['financialAccountType'] =
        ObjectSerializer.serialize(
          financialAccountType,
          "'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED' | 'FINANCIAL_ACCOUNT_TYPE_BANK' | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT' | 'FINANCIAL_ACCOUNT_TYPE_CREDIT' | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE' | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN'"
        );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionsForPastMonthResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionsForPastMonthResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint returns the transactions for a given user id and time example: /api/v1/users/{user_id}/transactions/week/accounts/{plaid_account_id}
   * @summary get transactions for the past week
   * @param userId
   * @param plaidAccountId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param page Current page number
   * @param limit Number of transactions per page
   * @param financialAccountType
   */
  public async getTransactionsForPastWeek(
    userId: string,
    plaidAccountId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    page?: number,
    limit?: number,
    financialAccountType?:
      | 'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED'
      | 'FINANCIAL_ACCOUNT_TYPE_BANK'
      | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT'
      | 'FINANCIAL_ACCOUNT_TYPE_CREDIT'
      | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE'
      | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransactionsForPastWeekResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/users/{userId}/transactions/week/accounts/{plaidAccountId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'plaidAccountId' + '}',
          encodeURIComponent(String(plaidAccountId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTransactionsForPastWeek.'
      );
    }

    // verify required parameter 'plaidAccountId' is not null or undefined
    if (plaidAccountId === null || plaidAccountId === undefined) {
      throw new Error(
        'Required parameter plaidAccountId was null or undefined when calling getTransactionsForPastWeek.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getTransactionsForPastWeek.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTransactionsForPastWeek.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTransactionsForPastWeek.'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (financialAccountType !== undefined) {
      localVarQueryParameters['financialAccountType'] =
        ObjectSerializer.serialize(
          financialAccountType,
          "'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED' | 'FINANCIAL_ACCOUNT_TYPE_BANK' | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT' | 'FINANCIAL_ACCOUNT_TYPE_CREDIT' | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE' | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN'"
        );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionsForPastWeekResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionsForPastWeekResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This API could accept user_id as input parameters and return the account balance history for that user.
   * @summary Returns the account balance history for a user
   * @param userId User ID
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param profileType
   */
  public async getUserAccountBalanceHistory(
    userId: string,
    pageNumber: string,
    pageSize: string,
    orgId: string,
    tenantId: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserAccountBalanceHistoryResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/balance-history/user/{userId}/pagenumber/{pageNumber}/pagesize/{pageSize}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'pageNumber' + '}',
          encodeURIComponent(String(pageNumber))
        )
        .replace('{' + 'pageSize' + '}', encodeURIComponent(String(pageSize)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserAccountBalanceHistory.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getUserAccountBalanceHistory.'
      );
    }

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getUserAccountBalanceHistory.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserAccountBalanceHistory.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserAccountBalanceHistory.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserAccountBalanceHistoryResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserAccountBalanceHistoryResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This API could accept user_id as an input parameter and return the monthly category expenditure for that user.
   * @summary Returns the monthly category expenditure for a user
   * @param userId User ID
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param personalFinanceCategoryPrimary Personal finance category
   * @param month Month in the format of YYYYMM
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getUserCategoryMonthlyExpenditure(
    userId: string,
    orgId: string,
    tenantId: string,
    personalFinanceCategoryPrimary?: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserCategoryMonthlyExpenditureResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/category-monthly-expenditure/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserCategoryMonthlyExpenditure.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserCategoryMonthlyExpenditure.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserCategoryMonthlyExpenditure.'
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserCategoryMonthlyExpenditureResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserCategoryMonthlyExpenditureResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get monthly income by user for a specific category
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param personalFinanceCategoryPrimary
   * @param month
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async getUserCategoryMonthlyIncome(
    userId: string,
    orgId: string,
    tenantId: string,
    personalFinanceCategoryPrimary?: string,
    month?: number,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserCategoryMonthlyIncomeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/category-monthly-income/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserCategoryMonthlyIncome.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserCategoryMonthlyIncome.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserCategoryMonthlyIncome.'
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserCategoryMonthlyIncomeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserCategoryMonthlyIncomeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Queries and obtains a user profile based on the provided parameters
   * @summary Gets a user profile
   * @param userId The account ID associated with the user. NOTE: This user_id is the simfiny backend platform wide user id Validations: - user_id must be greater than 0
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param bypassCache bypass_cache is a flag to bypass the cache and fetch the data from the source this is very valuable when we want to get the latest data from the source
   */
  public async getUserProfile1(
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    bypassCache?: boolean,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserProfileResponse1;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/profile/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserProfile1.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserProfile1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserProfile1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserProfile1.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (bypassCache !== undefined) {
      localVarQueryParameters['bypassCache'] = ObjectSerializer.serialize(
        bypassCache,
        'boolean'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserProfileResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserProfileResponse1'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a healc check on the service
   * @summary health check
   */
  public async healthCheck2(
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: HealthCheckResponse }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/health';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: HealthCheckResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'HealthCheckResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint lists notes from a transaction
   * @summary lists notes from a transaction
   * @param transactionId The transaction id Validations: - transaction_id must be greater than 0
   * @param userId The user id
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async listRecurringTransactionNotes(
    transactionId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListRecurringTransactionNotesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/{transactionId}/notes'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling listRecurringTransactionNotes.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listRecurringTransactionNotes.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listRecurringTransactionNotes.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listRecurringTransactionNotes.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListRecurringTransactionNotesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListRecurringTransactionNotesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a list of transactions against a given account of interest
   * @summary lists a set of transactions against a given account of interest
   * @param accountId
   * @param userId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param pageNumber
   * @param pageSize
   * @param financialAccountType
   */
  public async listRecurringTransactionsForUserAndAccount(
    accountId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    pageNumber?: string,
    pageSize?: string,
    financialAccountType?:
      | 'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED'
      | 'FINANCIAL_ACCOUNT_TYPE_BANK'
      | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT'
      | 'FINANCIAL_ACCOUNT_TYPE_CREDIT'
      | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE'
      | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListRecurringTransactionsForUserAndAccountResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/transactions/recurrings';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        'Required parameter accountId was null or undefined when calling listRecurringTransactionsForUserAndAccount.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listRecurringTransactionsForUserAndAccount.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling listRecurringTransactionsForUserAndAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listRecurringTransactionsForUserAndAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listRecurringTransactionsForUserAndAccount.'
      );
    }

    if (accountId !== undefined) {
      localVarQueryParameters['accountId'] = ObjectSerializer.serialize(
        accountId,
        'string'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (financialAccountType !== undefined) {
      localVarQueryParameters['financialAccountType'] =
        ObjectSerializer.serialize(
          financialAccountType,
          "'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED' | 'FINANCIAL_ACCOUNT_TYPE_BANK' | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT' | 'FINANCIAL_ACCOUNT_TYPE_CREDIT' | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE' | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN'"
        );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListRecurringTransactionsForUserAndAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListRecurringTransactionsForUserAndAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint lists notes from a transaction
   * @summary lists notes from a transaction
   * @param transactionId The transaction id Validations: - transaction_id must be greater than 0
   * @param userId
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async listTransactionNotes(
    transactionId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTransactionNotesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/{transactionId}/notes'.replace(
        '{' + 'transactionId' + '}',
        encodeURIComponent(String(transactionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error(
        'Required parameter transactionId was null or undefined when calling listTransactionNotes.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listTransactionNotes.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling listTransactionNotes.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listTransactionNotes.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTransactionNotes.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTransactionNotesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTransactionNotesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a list of transactions against a given account of interest
   * @summary lists a set of transactions against a given account of interest
   * @param accountId
   * @param userId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param pageNumber
   * @param pageSize
   * @param financialAccountType
   */
  public async listTransactions(
    accountId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    pageNumber?: string,
    pageSize?: string,
    financialAccountType?:
      | 'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED'
      | 'FINANCIAL_ACCOUNT_TYPE_BANK'
      | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT'
      | 'FINANCIAL_ACCOUNT_TYPE_CREDIT'
      | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE'
      | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTransactionsResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/transactions';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        'Required parameter accountId was null or undefined when calling listTransactions.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listTransactions.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling listTransactions.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listTransactions.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTransactions.'
      );
    }

    if (accountId !== undefined) {
      localVarQueryParameters['accountId'] = ObjectSerializer.serialize(
        accountId,
        'string'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (financialAccountType !== undefined) {
      localVarQueryParameters['financialAccountType'] =
        ObjectSerializer.serialize(
          financialAccountType,
          "'FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED' | 'FINANCIAL_ACCOUNT_TYPE_BANK' | 'FINANCIAL_ACCOUNT_TYPE_INVESTMENT' | 'FINANCIAL_ACCOUNT_TYPE_CREDIT' | 'FINANCIAL_ACCOUNT_TYPE_MORTGAGE' | 'FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN'"
        );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTransactionsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTransactionsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint gets a list of transactions across all connected accounts
   * @summary lists a set of transactions across all connected accounts
   * @param userId
   * @param profileType
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param pageNumber
   * @param pageSize
   */
  public async listTransactions1(
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    pageNumber?: string,
    pageSize?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTransactionsAcrossAllAccountsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/all_accounts';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listTransactions1.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling listTransactions1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listTransactions1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTransactions1.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTransactionsAcrossAllAccountsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTransactionsAcrossAllAccountsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint exchanges a plaid link token for a plaid access token
   * @summary exchange plaid token
   * @param plaidExchangeTokenRequest
   */
  public async plaidExchangeToken(
    plaidExchangeTokenRequest: PlaidExchangeTokenRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: PlaidExchangeTokenResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/plaid/exchange-token';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'plaidExchangeTokenRequest' is not null or undefined
    if (
      plaidExchangeTokenRequest === null ||
      plaidExchangeTokenRequest === undefined
    ) {
      throw new Error(
        'Required parameter plaidExchangeTokenRequest was null or undefined when calling plaidExchangeToken.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        plaidExchangeTokenRequest,
        'PlaidExchangeTokenRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PlaidExchangeTokenResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'PlaidExchangeTokenResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint initiates a plaid link token creation
   * @summary initiate plaid setup
   * @param plaidInitiateTokenExchangeRequest
   */
  public async plaidInitiateTokenExchange(
    plaidInitiateTokenExchangeRequest: PlaidInitiateTokenExchangeRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: PlaidInitiateTokenExchangeResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/plaid/initiate-token-exchange';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'plaidInitiateTokenExchangeRequest' is not null or undefined
    if (
      plaidInitiateTokenExchangeRequest === null ||
      plaidInitiateTokenExchangeRequest === undefined
    ) {
      throw new Error(
        'Required parameter plaidInitiateTokenExchangeRequest was null or undefined when calling plaidInitiateTokenExchange.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        plaidInitiateTokenExchangeRequest,
        'PlaidInitiateTokenExchangeRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PlaidInitiateTokenExchangeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'PlaidInitiateTokenExchangeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint initiates a plaid link token update
   * @summary initiate plaid link token update
   * @param plaidInitiateTokenUpdateRequest
   */
  public async plaidInitiateTokenUpdate(
    plaidInitiateTokenUpdateRequest: PlaidInitiateTokenUpdateRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: PlaidInitiateTokenUpdateResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/plaid/initiate-token-update';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'plaidInitiateTokenUpdateRequest' is not null or undefined
    if (
      plaidInitiateTokenUpdateRequest === null ||
      plaidInitiateTokenUpdateRequest === undefined
    ) {
      throw new Error(
        'Required parameter plaidInitiateTokenUpdateRequest was null or undefined when calling plaidInitiateTokenUpdate.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        plaidInitiateTokenUpdateRequest,
        'PlaidInitiateTokenUpdateRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PlaidInitiateTokenUpdateResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'PlaidInitiateTokenUpdateResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint syncs accounts based on plaid access token
   * @summary sync accounts based on plaid access token
   * @param plaidSyncAccountFromAccessTokenRequest
   */
  public async plaidSyncAccountFromAccessToken(
    plaidSyncAccountFromAccessTokenRequest: PlaidSyncAccountFromAccessTokenRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: PlaidSyncAccountFromAccessTokenResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/plaid/sync-access-token';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'plaidSyncAccountFromAccessTokenRequest' is not null or undefined
    if (
      plaidSyncAccountFromAccessTokenRequest === null ||
      plaidSyncAccountFromAccessTokenRequest === undefined
    ) {
      throw new Error(
        'Required parameter plaidSyncAccountFromAccessTokenRequest was null or undefined when calling plaidSyncAccountFromAccessToken.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        plaidSyncAccountFromAccessTokenRequest,
        'PlaidSyncAccountFromAccessTokenRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PlaidSyncAccountFromAccessTokenResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'PlaidSyncAccountFromAccessTokenResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint polls the status of an async task
   * @summary polls the status of an async task
   * @param workflowId The task id Validations: - workflow id cannot be empty
   * @param runId The run id Validations: - run id cannot be empty
   * @param userId The user id
   * @param profileType Type of financial user profile
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   */
  public async pollAsyncTaskExecutionStatus(
    workflowId: string,
    runId: string,
    userId: string,
    profileType:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: PollAsyncTaskExecutionStatusResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/async-task/{workflowId}/run/{runId}'
        .replace(
          '{' + 'workflowId' + '}',
          encodeURIComponent(String(workflowId))
        )
        .replace('{' + 'runId' + '}', encodeURIComponent(String(runId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workflowId' is not null or undefined
    if (workflowId === null || workflowId === undefined) {
      throw new Error(
        'Required parameter workflowId was null or undefined when calling pollAsyncTaskExecutionStatus.'
      );
    }

    // verify required parameter 'runId' is not null or undefined
    if (runId === null || runId === undefined) {
      throw new Error(
        'Required parameter runId was null or undefined when calling pollAsyncTaskExecutionStatus.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling pollAsyncTaskExecutionStatus.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling pollAsyncTaskExecutionStatus.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling pollAsyncTaskExecutionStatus.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling pollAsyncTaskExecutionStatus.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PollAsyncTaskExecutionStatusResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'PollAsyncTaskExecutionStatusResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a readiness check on the service
   * @summary readyness check
   */
  public async readynessCheck2(
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ReadynessCheckResponse2;
  }> {
    const localVarPath = this.basePath + '/financial-microservice/api/v1/ready';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReadynessCheckResponse2;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReadynessCheckResponse2'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint searches transactions based on a search query and returns a list of transactions that match the search query
   * @summary searches transactions
   * @param searchTransactionsRequest
   */
  public async searchTransactions(
    searchTransactionsRequest: SearchTransactionsRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: SearchTransactionsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/search';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'searchTransactionsRequest' is not null or undefined
    if (
      searchTransactionsRequest === null ||
      searchTransactionsRequest === undefined
    ) {
      throw new Error(
        'Required parameter searchTransactionsRequest was null or undefined when calling searchTransactions.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        searchTransactionsRequest,
        'SearchTransactionsRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchTransactionsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'SearchTransactionsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint splits a transaction into multiple transactions
   * @summary splits a transaction
   * @param splitTransactionRequest
   */
  public async splitTransaction(
    splitTransactionRequest: SplitTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: SplitTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/split';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'splitTransactionRequest' is not null or undefined
    if (
      splitTransactionRequest === null ||
      splitTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter splitTransactionRequest was null or undefined when calling splitTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        splitTransactionRequest,
        'SplitTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SplitTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'SplitTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This API could accept user_id and month as input parameters and return the aggregated transactions for that user and month.
   * @summary Returns the aggregated transactions for a user and month
   * @param userId
   * @param orgId Organization identifier for multi-org support
   * @param tenantId Tenant identifier for multi-tenancy support
   * @param month
   * @param personalFinanceCategoryPrimary
   * @param locationCity
   * @param paymentChannel
   * @param merchantName
   * @param pageNumber
   * @param pageSize Number of items to return per page.
   * @param profileType
   */
  public async transactionAggregates(
    userId: string,
    orgId: string,
    tenantId: string,
    month?: number,
    personalFinanceCategoryPrimary?: string,
    locationCity?: string,
    paymentChannel?: string,
    merchantName?: string,
    pageNumber?: string,
    pageSize?: string,
    profileType?:
      | 'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED'
      | 'FINANCIAL_USER_PROFILE_TYPE_USER'
      | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransactionAggregatesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/analytics/transaction-aggregates/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling transactionAggregates.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling transactionAggregates.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling transactionAggregates.'
      );
    }

    if (month !== undefined) {
      localVarQueryParameters['month'] = ObjectSerializer.serialize(
        month,
        'number'
      );
    }

    if (personalFinanceCategoryPrimary !== undefined) {
      localVarQueryParameters['personalFinanceCategoryPrimary'] =
        ObjectSerializer.serialize(personalFinanceCategoryPrimary, 'string');
    }

    if (locationCity !== undefined) {
      localVarQueryParameters['locationCity'] = ObjectSerializer.serialize(
        locationCity,
        'string'
      );
    }

    if (paymentChannel !== undefined) {
      localVarQueryParameters['paymentChannel'] = ObjectSerializer.serialize(
        paymentChannel,
        'string'
      );
    }

    if (merchantName !== undefined) {
      localVarQueryParameters['merchantName'] = ObjectSerializer.serialize(
        merchantName,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED' | 'FINANCIAL_USER_PROFILE_TYPE_USER' | 'FINANCIAL_USER_PROFILE_TYPE_BUSINESS'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTransactionAggregatesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTransactionAggregatesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint triggers a sync
   * @summary Triggers a sync
   * @param triggerSyncRequest
   */
  public async triggerSync(
    triggerSyncRequest: TriggerSyncRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: TriggerSyncResponse }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/sync/trigger';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'triggerSyncRequest' is not null or undefined
    if (triggerSyncRequest === null || triggerSyncRequest === undefined) {
      throw new Error(
        'Required parameter triggerSyncRequest was null or undefined when calling triggerSync.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        triggerSyncRequest,
        'TriggerSyncRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TriggerSyncResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'TriggerSyncResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint unsplit a transaction that was split previously into multiple transactions
   * @summary unsplit a transaction
   * @param unSplitTransactionsRequest
   */
  public async unsplitTransactions(
    unSplitTransactionsRequest: UnSplitTransactionsRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UnSplitTransactionsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/unsplit';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'unSplitTransactionsRequest' is not null or undefined
    if (
      unSplitTransactionsRequest === null ||
      unSplitTransactionsRequest === undefined
    ) {
      throw new Error(
        'Required parameter unSplitTransactionsRequest was null or undefined when calling unsplitTransactions.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        unSplitTransactionsRequest,
        'UnSplitTransactionsRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UnSplitTransactionsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UnSplitTransactionsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a bank account if the user record id and bank account id exists
   * @summary update a bank account for a given user profile
   * @param updateBankAccountRequest
   */
  public async updateBankAccount(
    updateBankAccountRequest: UpdateBankAccountRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateBankAccountResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/bank-account';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateBankAccountRequest' is not null or undefined
    if (
      updateBankAccountRequest === null ||
      updateBankAccountRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateBankAccountRequest was null or undefined when calling updateBankAccount.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateBankAccountRequest,
        'UpdateBankAccountRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateBankAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateBankAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint Updates a note to a transaction
   * @summary Updates a note to a transaction
   * @param updateNoteToRecurringTransactionRequest
   */
  public async updateNoteToRecurringTransaction(
    updateNoteToRecurringTransactionRequest: UpdateNoteToRecurringTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateNoteToRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/recurring/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateNoteToRecurringTransactionRequest' is not null or undefined
    if (
      updateNoteToRecurringTransactionRequest === null ||
      updateNoteToRecurringTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateNoteToRecurringTransactionRequest was null or undefined when calling updateNoteToRecurringTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateNoteToRecurringTransactionRequest,
        'UpdateNoteToRecurringTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateNoteToRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateNoteToRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a note to a smart goal
   * @summary updates a note to a smart goal
   * @param updateNoteToSmartGoalRequest
   */
  public async updateNoteToSmartGoal(
    updateNoteToSmartGoalRequest: UpdateNoteToSmartGoalRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateNoteToSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/smart-goal/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateNoteToSmartGoalRequest' is not null or undefined
    if (
      updateNoteToSmartGoalRequest === null ||
      updateNoteToSmartGoalRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateNoteToSmartGoalRequest was null or undefined when calling updateNoteToSmartGoal.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateNoteToSmartGoalRequest,
        'UpdateNoteToSmartGoalRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateNoteToSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateNoteToSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint Updates a note to a transaction
   * @summary Updates a note to a transaction
   * @param updateNoteToTransactionRequest
   */
  public async updateNoteToTransaction(
    updateNoteToTransactionRequest: UpdateNoteToTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateNoteToTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/transaction/note';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateNoteToTransactionRequest' is not null or undefined
    if (
      updateNoteToTransactionRequest === null ||
      updateNoteToTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateNoteToTransactionRequest was null or undefined when calling updateNoteToTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateNoteToTransactionRequest,
        'UpdateNoteToTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateNoteToTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateNoteToTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a pocket
   * @summary updates a pocket
   * @param updatePocketRequest
   */
  public async updatePocket(
    updatePocketRequest: UpdatePocketRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdatePocketResponse }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/pocket';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updatePocketRequest' is not null or undefined
    if (updatePocketRequest === null || updatePocketRequest === undefined) {
      throw new Error(
        'Required parameter updatePocketRequest was null or undefined when calling updatePocket.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updatePocketRequest,
        'UpdatePocketRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdatePocketResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdatePocketResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a transaction
   * @summary update a transaction
   * @param updateSingleTransactionRequest
   */
  public async updateSingleTransaction(
    updateSingleTransactionRequest: UpdateSingleTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateSingleTransactionResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/financial-microservice/api/v1/transactions/single-transaction';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateSingleTransactionRequest' is not null or undefined
    if (
      updateSingleTransactionRequest === null ||
      updateSingleTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateSingleTransactionRequest was null or undefined when calling updateSingleTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateSingleTransactionRequest,
        'UpdateSingleTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateSingleTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateSingleTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a smart goal
   * @summary update a smart goal
   * @param updateSmartGoalRequest
   */
  public async updateSmartGoal(
    updateSmartGoalRequest: UpdateSmartGoalRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateSmartGoalResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/smart-goal';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateSmartGoalRequest' is not null or undefined
    if (
      updateSmartGoalRequest === null ||
      updateSmartGoalRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateSmartGoalRequest was null or undefined when calling updateSmartGoal.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateSmartGoalRequest,
        'UpdateSmartGoalRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateSmartGoalResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateSmartGoalResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a transaction
   * @summary update a transaction
   * @param updateRecurringTransactionRequest
   */
  public async updateTransaction(
    updateRecurringTransactionRequest: UpdateRecurringTransactionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateRecurringTransactionResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/transactions/recurring';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateRecurringTransactionRequest' is not null or undefined
    if (
      updateRecurringTransactionRequest === null ||
      updateRecurringTransactionRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateRecurringTransactionRequest was null or undefined when calling updateTransaction.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateRecurringTransactionRequest,
        'UpdateRecurringTransactionRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateRecurringTransactionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateRecurringTransactionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs an updates operation on a user profile based on the provided parameters
   * @summary update a user profile
   * @param updateUserProfileRequest
   */
  public async updateUserProfile(
    updateUserProfileRequest: UpdateUserProfileRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateUserProfileResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/profile';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateUserProfileRequest' is not null or undefined
    if (
      updateUserProfileRequest === null ||
      updateUserProfileRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateUserProfileRequest was null or undefined when calling updateUserProfile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateUserProfileRequest,
        'UpdateUserProfileRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a budget
   * @summary updates a budget
   * @param updateBudgetRequest
   */
  public async updatesBudget(
    updateBudgetRequest: UpdateBudgetRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateBudgetResponse }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/budget';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateBudgetRequest' is not null or undefined
    if (updateBudgetRequest === null || updateBudgetRequest === undefined) {
      throw new Error(
        'Required parameter updateBudgetRequest was null or undefined when calling updatesBudget.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateBudgetRequest,
        'UpdateBudgetRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateBudgetResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateBudgetResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a milestone
   * @summary updates a milestone
   * @param updateMilestoneRequest
   */
  public async updatesMilestone(
    updateMilestoneRequest: UpdateMilestoneRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateMilestoneResponse;
  }> {
    const localVarPath =
      this.basePath + '/financial-microservice/api/v1/milestone';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateMilestoneRequest' is not null or undefined
    if (
      updateMilestoneRequest === null ||
      updateMilestoneRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateMilestoneRequest was null or undefined when calling updatesMilestone.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateMilestoneRequest,
        'UpdateMilestoneRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateMilestoneResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateMilestoneResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
