/**
 * User Service API
 * Solomon AI User Service API - Manages user profiles and authentication
 *
 * The version of the OpenAPI document: 1.0
 * Contact: yoanyomba@solomon-ai.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AcceptFollowProfileResponse } from '../model/acceptFollowProfileResponse';
import { AddCommentQualityScoreResponse } from '../model/addCommentQualityScoreResponse';
import { AddPostQualityScoreResponse } from '../model/addPostQualityScoreResponse';
import { AddPostToPublicationResponse } from '../model/addPostToPublicationResponse';
import { AddPostToThreadResponse } from '../model/addPostToThreadResponse';
import { AddPublicationEditorResponse } from '../model/addPublicationEditorResponse';
import { AuthenticationErrorMessageResponse } from '../model/authenticationErrorMessageResponse';
import { BadGatewayErrorMessageResponse } from '../model/badGatewayErrorMessageResponse';
import { BlockUserProfileResponse } from '../model/blockUserProfileResponse';
import { BookmarkPostResponse } from '../model/bookmarkPostResponse';
import { BookmarkPublicationResponse } from '../model/bookmarkPublicationResponse';
import { Comment } from '../model/comment';
import { CommunityProfile } from '../model/communityProfile';
import { ConflictErrorMessageResponse } from '../model/conflictErrorMessageResponse';
import { CreateCommentReplyBody } from '../model/createCommentReplyBody';
import { CreateCommentReplyResponse } from '../model/createCommentReplyResponse';
import { CreateCommentResponse } from '../model/createCommentResponse';
import { CreateCommunityProfileBody } from '../model/createCommunityProfileBody';
import { CreateCommunityProfileResponse } from '../model/createCommunityProfileResponse';
import { CreateNoteBody } from '../model/createNoteBody';
import { CreateNoteResponse } from '../model/createNoteResponse';
import { CreatePollResponse } from '../model/createPollResponse';
import { CreatePostResponse } from '../model/createPostResponse';
import { CreatePublicationResponse } from '../model/createPublicationResponse';
import { CreateTopicResponse } from '../model/createTopicResponse';
import { CreateUserProfileRequest } from '../model/createUserProfileRequest';
import { CreateUserProfileResponse } from '../model/createUserProfileResponse';
import { DeleteCommentReplyResponse } from '../model/deleteCommentReplyResponse';
import { DeleteCommunityProfileResponse } from '../model/deleteCommunityProfileResponse';
import { DeleteNoteResponse } from '../model/deleteNoteResponse';
import { DeletePollResponse } from '../model/deletePollResponse';
import { DeletePostFromPublicationResponse } from '../model/deletePostFromPublicationResponse';
import { DeletePostResponse } from '../model/deletePostResponse';
import { DeletePublicationEditorResponse } from '../model/deletePublicationEditorResponse';
import { DeletePublicationResponse } from '../model/deletePublicationResponse';
import { DeleteUserProfileResponse } from '../model/deleteUserProfileResponse';
import { DiscoverProfilesResponse } from '../model/discoverProfilesResponse';
import { EditCommentReplyBody } from '../model/editCommentReplyBody';
import { EditCommentReplyResponse } from '../model/editCommentReplyResponse';
import { EditCommunityProfileRequest } from '../model/editCommunityProfileRequest';
import { EditNoteResponse } from '../model/editNoteResponse';
import { EditPostResponse } from '../model/editPostResponse';
import { EditUserProfileResponse } from '../model/editUserProfileResponse';
import { FollowCommunityProfileResponse } from '../model/followCommunityProfileResponse';
import { FollowProfileResponse } from '../model/followProfileResponse';
import { ForbiddenErrorMessageResponse } from '../model/forbiddenErrorMessageResponse';
import { GatewayTimeoutErrorMessageResponse } from '../model/gatewayTimeoutErrorMessageResponse';
import { GetAccountsFollowingResponse } from '../model/getAccountsFollowingResponse';
import { GetBlogPostsByTagResponse } from '../model/getBlogPostsByTagResponse';
import { GetBookmarkedPostsResponse } from '../model/getBookmarkedPostsResponse';
import { GetCannyUserSSOTokenResponse } from '../model/getCannyUserSSOTokenResponse';
import { GetCommentRepliesResponse } from '../model/getCommentRepliesResponse';
import { GetCommunitiesUserFollowsResponse } from '../model/getCommunitiesUserFollowsResponse';
import { GetCommunityBlogPostsResponse } from '../model/getCommunityBlogPostsResponse';
import { GetCommunityFeedResponse } from '../model/getCommunityFeedResponse';
import { GetCommunityProfileResponse } from '../model/getCommunityProfileResponse';
import { GetCommunityProfilesResponse } from '../model/getCommunityProfilesResponse';
import { GetFollowersResponse } from '../model/getFollowersResponse';
import { GetPendingFollowsResponse } from '../model/getPendingFollowsResponse';
import { GetPollResponse } from '../model/getPollResponse';
import { GetPollsResponse } from '../model/getPollsResponse';
import { GetPostResponse } from '../model/getPostResponse';
import { GetPostThreadResponse } from '../model/getPostThreadResponse';
import { GetPostsByCategoryResponse } from '../model/getPostsByCategoryResponse';
import { GetPostsByTopicResponse } from '../model/getPostsByTopicResponse';
import { GetPostsResponse } from '../model/getPostsResponse';
import { GetPublicationResponse } from '../model/getPublicationResponse';
import { GetTopicsOfCommunitiesUserFollowsResponse } from '../model/getTopicsOfCommunitiesUserFollowsResponse';
import { GetUserFeedResponse } from '../model/getUserFeedResponse';
import { GetUserProfileResponse } from '../model/getUserProfileResponse';
import { GetUserProfilesResponse } from '../model/getUserProfilesResponse';
import { GoneErrorMessageResponse } from '../model/goneErrorMessageResponse';
import { HealthCheckResponse1 } from '../model/healthCheckResponse1';
import { InternalErrorMessageResponse } from '../model/internalErrorMessageResponse';
import { MethodNotAllowedErrorMessageResponse } from '../model/methodNotAllowedErrorMessageResponse';
import { NotFoundErrorMessageResponse } from '../model/notFoundErrorMessageResponse';
import { NotImplementedErrorMessageResponse } from '../model/notImplementedErrorMessageResponse';
import { Note } from '../model/note';
import { PaymentRequiredErrorMessageResponse } from '../model/paymentRequiredErrorMessageResponse';
import { PollPost } from '../model/pollPost';
import { Post } from '../model/post';
import { PreconditionFailedErrorMessageResponse } from '../model/preconditionFailedErrorMessageResponse';
import { Publication } from '../model/publication';
import { RateLimitErrorMessageResponse } from '../model/rateLimitErrorMessageResponse';
import { ReactToCommentReplyResponse } from '../model/reactToCommentReplyResponse';
import { ReactToCommentResponse } from '../model/reactToCommentResponse';
import { ReactToPostResponse } from '../model/reactToPostResponse';
import { ReadynessCheckResponse1 } from '../model/readynessCheckResponse1';
import { RemoveBookmarkedPostResponse } from '../model/removeBookmarkedPostResponse';
import { RemovePostFromThreadResponse } from '../model/removePostFromThreadResponse';
import { ReportCommentBody } from '../model/reportCommentBody';
import { ReportCommentReplyBody } from '../model/reportCommentReplyBody';
import { ReportCommentReplyResponse } from '../model/reportCommentReplyResponse';
import { ReportCommentResponse } from '../model/reportCommentResponse';
import { ReportPostResponse } from '../model/reportPostResponse';
import { RespondToPollBody } from '../model/respondToPollBody';
import { RespondToPollResponse } from '../model/respondToPollResponse';
import { ServiceUnavailableErrorMessageResponse } from '../model/serviceUnavailableErrorMessageResponse';
import { SharePostResponse } from '../model/sharePostResponse';
import { Status } from '../model/status';
import { TooEarlyErrorMessageResponse } from '../model/tooEarlyErrorMessageResponse';
import { Topic } from '../model/topic';
import { UnprocessableEntityErrorMessageResponse } from '../model/unprocessableEntityErrorMessageResponse';
import { UserProfile } from '../model/userProfile';
import { ValidationErrorMessageResponse } from '../model/validationErrorMessageResponse';

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from '../model/models';
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://user-service.platform.svc.cluster.local:9896';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum SocialServiceApiApiKeys {
  ApiKeyAuth,
  Bearer,
}

export class SocialServiceApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    ApiKeyAuth: new ApiKeyAuth('header', 'X-API-Key'),
    Bearer: new ApiKeyAuth('header', 'Authorization'),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SocialServiceApiApiKeys, value: string) {
    (this.authentications as any)[SocialServiceApiApiKeys[key]].apiKey = value;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * This endpoint enables a client to accept a follow request from a source a user profile
   * @summary Accepts a user\'s follow request
   * @param followRecordId The id of the follow record | type: uint64
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async acceptFollowProfile(
    followRecordId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AcceptFollowProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/follow-requests/{followRecordId}/accept'.replace(
        '{' + 'followRecordId' + '}',
        encodeURIComponent(String(followRecordId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'followRecordId' is not null or undefined
    if (followRecordId === null || followRecordId === undefined) {
      throw new Error(
        'Required parameter followRecordId was null or undefined when calling acceptFollowProfile.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling acceptFollowProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling acceptFollowProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling acceptFollowProfile.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AcceptFollowProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AcceptFollowProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to add a quality score to a comment
   * @summary Add Comment Quality Score
   * @param userId
   * @param postId
   * @param commentId
   * @param postType The type of post being reacted to | type: string
   * @param orgId
   * @param tenantId
   * @param body
   */
  public async addCommentQualityScore(
    userId: string,
    postId: string,
    commentId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    body: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddCommentQualityScoreResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/quality'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace(
          '{' + 'commentId' + '}',
          encodeURIComponent(String(commentId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling addCommentQualityScore.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling addCommentQualityScore.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling addCommentQualityScore.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling addCommentQualityScore.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling addCommentQualityScore.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addCommentQualityScore.'
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling addCommentQualityScore.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'string'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddCommentQualityScoreResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddCommentQualityScoreResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client add a quality score to a post
   * @summary Adds a quality score to a post
   * @param userId
   * @param postId
   * @param postType The type of post being reacted to | type: string
   * @param orgId
   * @param tenantId
   * @param body
   */
  public async addPostQualityScore(
    userId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    body: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddPostQualityScoreResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/quality'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling addPostQualityScore.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling addPostQualityScore.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling addPostQualityScore.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling addPostQualityScore.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addPostQualityScore.'
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling addPostQualityScore.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'string'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddPostQualityScoreResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddPostQualityScoreResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to add a post to a publication
   * @summary Add a post to a publication
   * @param editorUserId
   * @param publicationId
   * @param orgId
   * @param tenantId
   * @param post
   */
  public async addPostToPublication(
    editorUserId: string,
    publicationId: string,
    orgId: string,
    tenantId: string,
    post: Post,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddPostToPublicationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/editor/{editorUserId}/publication/{publicationId}'
        .replace(
          '{' + 'editorUserId' + '}',
          encodeURIComponent(String(editorUserId))
        )
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'editorUserId' is not null or undefined
    if (editorUserId === null || editorUserId === undefined) {
      throw new Error(
        'Required parameter editorUserId was null or undefined when calling addPostToPublication.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling addPostToPublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling addPostToPublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addPostToPublication.'
      );
    }

    // verify required parameter 'post' is not null or undefined
    if (post === null || post === undefined) {
      throw new Error(
        'Required parameter post was null or undefined when calling addPostToPublication.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(post, 'Post'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddPostToPublicationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddPostToPublicationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to add a post to a thread
   * @summary Adds A Post To A Thread
   * @param userId
   * @param parentPostId
   * @param postType
   * @param orgId
   * @param tenantId
   * @param post
   */
  public async addPostToThread(
    userId: string,
    parentPostId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    post: Post,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddPostToThreadResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/thread/{parentPostId}/type/{postType}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'parentPostId' + '}',
          encodeURIComponent(String(parentPostId))
        )
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling addPostToThread.'
      );
    }

    // verify required parameter 'parentPostId' is not null or undefined
    if (parentPostId === null || parentPostId === undefined) {
      throw new Error(
        'Required parameter parentPostId was null or undefined when calling addPostToThread.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling addPostToThread.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling addPostToThread.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addPostToThread.'
      );
    }

    // verify required parameter 'post' is not null or undefined
    if (post === null || post === undefined) {
      throw new Error(
        'Required parameter post was null or undefined when calling addPostToThread.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(post, 'Post'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddPostToThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddPostToThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to add an editor to a publication
   * @summary Adds an editor to a publication
   * @param adminUserId
   * @param publicationId
   * @param editorUserId
   * @param orgId
   * @param tenantId
   */
  public async addPublicationEditor(
    adminUserId: string,
    publicationId: string,
    editorUserId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddPublicationEditorResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/admin/{adminUserId}/publication/{publicationId}/editor/{editorUserId}'
        .replace(
          '{' + 'adminUserId' + '}',
          encodeURIComponent(String(adminUserId))
        )
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        )
        .replace(
          '{' + 'editorUserId' + '}',
          encodeURIComponent(String(editorUserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'adminUserId' is not null or undefined
    if (adminUserId === null || adminUserId === undefined) {
      throw new Error(
        'Required parameter adminUserId was null or undefined when calling addPublicationEditor.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling addPublicationEditor.'
      );
    }

    // verify required parameter 'editorUserId' is not null or undefined
    if (editorUserId === null || editorUserId === undefined) {
      throw new Error(
        'Required parameter editorUserId was null or undefined when calling addPublicationEditor.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling addPublicationEditor.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addPublicationEditor.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddPublicationEditorResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddPublicationEditorResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to block a user profile
   * @summary blocks a user profile
   * @param sourceUserId the user ID trying to block another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param targetUserId the user ID being blocked by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async blockUserProfile(
    sourceUserId: string,
    targetUserId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BlockUserProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/source/{sourceUserId}/block/target/{targetUserId}'
        .replace(
          '{' + 'sourceUserId' + '}',
          encodeURIComponent(String(sourceUserId))
        )
        .replace(
          '{' + 'targetUserId' + '}',
          encodeURIComponent(String(targetUserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'sourceUserId' is not null or undefined
    if (sourceUserId === null || sourceUserId === undefined) {
      throw new Error(
        'Required parameter sourceUserId was null or undefined when calling blockUserProfile.'
      );
    }

    // verify required parameter 'targetUserId' is not null or undefined
    if (targetUserId === null || targetUserId === undefined) {
      throw new Error(
        'Required parameter targetUserId was null or undefined when calling blockUserProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling blockUserProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling blockUserProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BlockUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BlockUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to bookmark a post
   * @summary Bookmarks a post
   * @param userId
   * @param postId
   * @param orgId
   * @param tenantId
   */
  public async bookmarkPost(
    userId: string,
    postId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: BookmarkPostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/bookmark/{postId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling bookmarkPost.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling bookmarkPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling bookmarkPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling bookmarkPost.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BookmarkPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'BookmarkPostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to bookmark a publication
   * @summary Bookmarks a publication
   * @param userId
   * @param publicationId
   * @param orgId
   * @param tenantId
   */
  public async bookmarkPublication(
    userId: string,
    publicationId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BookmarkPublicationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/publication/{publicationId}/bookmark'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling bookmarkPublication.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling bookmarkPublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling bookmarkPublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling bookmarkPublication.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BookmarkPublicationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BookmarkPublicationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create a comment
   * @summary Create A Commnet
   * @param userId the user ID trying to create a comment (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param postId The ID of the post to whom to add the comment | type: string
   * @param accountType The type of account making the request to create a comment | type: string
   * @param postType The type of post being reacted to | type: string
   * @param orgId
   * @param tenantId
   * @param comment The actual comment payload | type: json_object
   * @param communityProfileId The ID of the community trying to create a comment | type: uint64
   */
  public async createComment(
    userId: string,
    postId: string,
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    comment: Comment,
    communityProfileId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateCommentResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createComment.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling createComment.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling createComment.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling createComment.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling createComment.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling createComment.'
      );
    }

    // verify required parameter 'comment' is not null or undefined
    if (comment === null || comment === undefined) {
      throw new Error(
        'Required parameter comment was null or undefined when calling createComment.'
      );
    }

    if (communityProfileId !== undefined) {
      localVarQueryParameters['communityProfileId'] =
        ObjectSerializer.serialize(communityProfileId, 'string');
    }

    if (accountType !== undefined) {
      localVarQueryParameters['accountType'] = ObjectSerializer.serialize(
        accountType,
        "'ACCOUNT_TYPE_UNSPECIFIED' | 'ACCOUNT_TYPE_USER' | 'ACCOUNT_TYPE_COMMUNITY'"
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(comment, 'Comment'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommentResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommentResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to reply to a comment
   * @summary Reply To A Comment
   * @param userId
   * @param postId
   * @param commentId
   * @param createCommentReplyBody
   */
  public async createCommentReply(
    userId: string,
    postId: string,
    commentId: string,
    createCommentReplyBody: CreateCommentReplyBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateCommentReplyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace(
          '{' + 'commentId' + '}',
          encodeURIComponent(String(commentId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createCommentReply.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling createCommentReply.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling createCommentReply.'
      );
    }

    // verify required parameter 'createCommentReplyBody' is not null or undefined
    if (
      createCommentReplyBody === null ||
      createCommentReplyBody === undefined
    ) {
      throw new Error(
        'Required parameter createCommentReplyBody was null or undefined when calling createCommentReply.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createCommentReplyBody,
        'CreateCommentReplyBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommentReplyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommentReplyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create a community profile
   * @summary Create a community Profile
   * @param userId the user ID trying to create this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param createCommunityProfileBody
   */
  public async createCommunityProfile(
    userId: string,
    createCommunityProfileBody: CreateCommunityProfileBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateCommunityProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/community-profiles/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createCommunityProfile.'
      );
    }

    // verify required parameter 'createCommunityProfileBody' is not null or undefined
    if (
      createCommunityProfileBody === null ||
      createCommunityProfileBody === undefined
    ) {
      throw new Error(
        'Required parameter createCommunityProfileBody was null or undefined when calling createCommunityProfile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createCommunityProfileBody,
        'CreateCommunityProfileBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommunityProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommunityProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create and associate a not to a post
   * @summary Creates and associates a note to a given post
   * @param userId
   * @param postId
   * @param createNoteBody
   */
  public async createNote(
    userId: string,
    postId: string,
    createNoteBody: CreateNoteBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateNoteResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/note'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createNote.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling createNote.'
      );
    }

    // verify required parameter 'createNoteBody' is not null or undefined
    if (createNoteBody === null || createNoteBody === undefined) {
      throw new Error(
        'Required parameter createNoteBody was null or undefined when calling createNote.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createNoteBody, 'CreateNoteBody'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateNoteResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateNoteResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create a poll
   * @summary Create a poll
   * @param userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   * @param pollPost The post payload | type: json_object
   */
  public async createPoll(
    userId: string,
    orgId: string,
    tenantId: string,
    pollPost: PollPost,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreatePollResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/poll'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createPoll.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling createPoll.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling createPoll.'
      );
    }

    // verify required parameter 'pollPost' is not null or undefined
    if (pollPost === null || pollPost === undefined) {
      throw new Error(
        'Required parameter pollPost was null or undefined when calling createPoll.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(pollPost, 'PollPost'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreatePollResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreatePollResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create a post
   * @summary Create a post
   * @param userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param accountType The type of profile making the request | type: string
   * @param orgId
   * @param tenantId
   * @param post The post payload | type: json_object
   * @param communityProfileId The ID of the community profile attempting to create the post  | type: uint64
   */
  public async createPost(
    userId: string,
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    orgId: string,
    tenantId: string,
    post: Post,
    communityProfileId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreatePostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createPost.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling createPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling createPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling createPost.'
      );
    }

    // verify required parameter 'post' is not null or undefined
    if (post === null || post === undefined) {
      throw new Error(
        'Required parameter post was null or undefined when calling createPost.'
      );
    }

    if (communityProfileId !== undefined) {
      localVarQueryParameters['communityProfileId'] =
        ObjectSerializer.serialize(communityProfileId, 'string');
    }

    if (accountType !== undefined) {
      localVarQueryParameters['accountType'] = ObjectSerializer.serialize(
        accountType,
        "'ACCOUNT_TYPE_UNSPECIFIED' | 'ACCOUNT_TYPE_USER' | 'ACCOUNT_TYPE_COMMUNITY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(post, 'Post'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreatePostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreatePostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to creare a publication
   * @summary Creates a publication
   * @param userId
   * @param orgId
   * @param tenantId
   * @param publication
   */
  public async createPublication(
    userId: string,
    orgId: string,
    tenantId: string,
    publication: Publication,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreatePublicationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/publication'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createPublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling createPublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling createPublication.'
      );
    }

    // verify required parameter 'publication' is not null or undefined
    if (publication === null || publication === undefined) {
      throw new Error(
        'Required parameter publication was null or undefined when calling createPublication.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(publication, 'Publication'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreatePublicationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreatePublicationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create a topic
   * @summary Create A Topic
   * @param userId the user ID trying to whom the community is tied to (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param communityProfileId the community profile to associate the topic to | type: uint64
   * @param orgId
   * @param tenantId
   * @param topic topic payload | type: json_object
   */
  public async createTopic(
    userId: string,
    communityProfileId: string,
    orgId: string,
    tenantId: string,
    topic: Topic,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateTopicResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/community/{communityProfileId}/topic'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'communityProfileId' + '}',
          encodeURIComponent(String(communityProfileId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling createTopic.'
      );
    }

    // verify required parameter 'communityProfileId' is not null or undefined
    if (communityProfileId === null || communityProfileId === undefined) {
      throw new Error(
        'Required parameter communityProfileId was null or undefined when calling createTopic.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling createTopic.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling createTopic.'
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        'Required parameter topic was null or undefined when calling createTopic.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(topic, 'Topic'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateTopicResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateTopicResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to create a user profile
   * @summary creates a user profile
   * @param createUserProfileRequest CreateUserProfileRequest represents the request object for creating a user profile in the social service. This message encapsulates the essential information needed to establish a new social user profile, including identification, contact details, and profile preferences.
   */
  public async createUserProfile(
    createUserProfileRequest: CreateUserProfileRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateUserProfileResponse;
  }> {
    const localVarPath = this.basePath + '/social-microservice/api/v1/users';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createUserProfileRequest' is not null or undefined
    if (
      createUserProfileRequest === null ||
      createUserProfileRequest === undefined
    ) {
      throw new Error(
        'Required parameter createUserProfileRequest was null or undefined when calling createUserProfile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUserProfileRequest,
        'CreateUserProfileRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a comment
   * @summary Delete A Comment
   * @param postId The ID of the post trying to be deleted | type: string
   * @param commentId The ID of the comment trying to be delete | type: string
   * @param postType The type of post being reacted to | type: string
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async deleteComment(
    postId: string,
    commentId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateCommentResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/post/{postId}/comment/{commentId}'
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace(
          '{' + 'commentId' + '}',
          encodeURIComponent(String(commentId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling deleteComment.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling deleteComment.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling deleteComment.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteComment.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteComment.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteComment.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommentResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommentResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a comment reply
   * @summary Delete A Comment Reply
   * @param userId
   * @param postId
   * @param commentId
   * @param replyId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async deleteCommentReply(
    userId: string,
    postId: string,
    commentId: string,
    replyId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteCommentReplyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace('{' + 'replyId' + '}', encodeURIComponent(String(replyId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteCommentReply.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling deleteCommentReply.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling deleteCommentReply.'
      );
    }

    // verify required parameter 'replyId' is not null or undefined
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling deleteCommentReply.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling deleteCommentReply.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteCommentReply.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteCommentReply.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteCommentReplyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteCommentReplyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a community profile
   * @summary Delete Community Profile
   * @param userId the user ID trying to delete this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param communityProfileId
   * @param orgId
   * @param tenantId
   */
  public async deleteCommunityProfile(
    userId: string,
    communityProfileId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteCommunityProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/community-profiles/{communityProfileId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'communityProfileId' + '}',
          encodeURIComponent(String(communityProfileId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteCommunityProfile.'
      );
    }

    // verify required parameter 'communityProfileId' is not null or undefined
    if (communityProfileId === null || communityProfileId === undefined) {
      throw new Error(
        'Required parameter communityProfileId was null or undefined when calling deleteCommunityProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteCommunityProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteCommunityProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteCommunityProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteCommunityProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a note
   * @summary Delete a note
   * @param userId
   * @param postId
   * @param noteId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async deleteNote(
    userId: string,
    postId: string,
    noteId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteNoteResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/note/{noteId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'noteId' + '}', encodeURIComponent(String(noteId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteNote.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling deleteNote.'
      );
    }

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling deleteNote.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling deleteNote.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteNote.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteNote.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteNoteResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteNoteResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a poll
   * @summary Delete a poll
   * @param userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param postId The ID of the post attempted to be delete | type: string
   * @param orgId
   * @param tenantId
   */
  public async deletePoll(
    userId: string,
    postId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeletePollResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/poll/{postId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deletePoll.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling deletePoll.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deletePoll.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deletePoll.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeletePollResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeletePollResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a post
   * @summary Delete a post
   * @param userId the user ID trying to delete a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param postId The ID of the post attempted to be delete | type: string
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async deletePost(
    userId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeletePostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/type/{postType}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deletePost.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling deletePost.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling deletePost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deletePost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deletePost.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeletePostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeletePostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a post from a publication
   * @summary Deletes a post from a publication
   * @param editorUserId
   * @param publicationId
   * @param postId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async deletePostFromPublication(
    editorUserId: string,
    publicationId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeletePostFromPublicationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/editor/{editorUserId}/publication/{publicationId}/post/{postId}'
        .replace(
          '{' + 'editorUserId' + '}',
          encodeURIComponent(String(editorUserId))
        )
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        )
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'editorUserId' is not null or undefined
    if (editorUserId === null || editorUserId === undefined) {
      throw new Error(
        'Required parameter editorUserId was null or undefined when calling deletePostFromPublication.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling deletePostFromPublication.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling deletePostFromPublication.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling deletePostFromPublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deletePostFromPublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deletePostFromPublication.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeletePostFromPublicationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeletePostFromPublicationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a publication
   * @summary Deletes a publication
   * @param adminUserId
   * @param publicationId
   * @param orgId
   * @param tenantId
   */
  public async deletePublication(
    adminUserId: string,
    publicationId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeletePublicationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/admin/{adminUserId}/publication/{publicationId}'
        .replace(
          '{' + 'adminUserId' + '}',
          encodeURIComponent(String(adminUserId))
        )
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'adminUserId' is not null or undefined
    if (adminUserId === null || adminUserId === undefined) {
      throw new Error(
        'Required parameter adminUserId was null or undefined when calling deletePublication.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling deletePublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deletePublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deletePublication.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeletePublicationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeletePublicationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to add an editor to a publication
   * @summary Deletes an editor to a publication
   * @param adminUserId
   * @param publicationId
   * @param editorUserId
   * @param orgId
   * @param tenantId
   */
  public async deletePublicationEditor(
    adminUserId: string,
    publicationId: string,
    editorUserId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeletePublicationEditorResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/admin/{adminUserId}/publication/{publicationId}/editor/{editorUserId}'
        .replace(
          '{' + 'adminUserId' + '}',
          encodeURIComponent(String(adminUserId))
        )
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        )
        .replace(
          '{' + 'editorUserId' + '}',
          encodeURIComponent(String(editorUserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'adminUserId' is not null or undefined
    if (adminUserId === null || adminUserId === undefined) {
      throw new Error(
        'Required parameter adminUserId was null or undefined when calling deletePublicationEditor.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling deletePublicationEditor.'
      );
    }

    // verify required parameter 'editorUserId' is not null or undefined
    if (editorUserId === null || editorUserId === undefined) {
      throw new Error(
        'Required parameter editorUserId was null or undefined when calling deletePublicationEditor.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deletePublicationEditor.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deletePublicationEditor.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeletePublicationEditorResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeletePublicationEditorResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a user profile
   * @summary deletes a user profile
   * @param userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async deleteUserProfile(
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteUserProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteUserProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteUserProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteUserProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to discover a set of profiles he/she does not follow
   * @summary Discover Profiles
   * @param userId
   * @param limit
   * @param orgId
   * @param tenantId
   */
  public async discoverProfiles(
    userId: string,
    limit: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DiscoverProfilesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/discover/limit/{limit}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'limit' + '}', encodeURIComponent(String(limit)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling discoverProfiles.'
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling discoverProfiles.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling discoverProfiles.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling discoverProfiles.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DiscoverProfilesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DiscoverProfilesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to edit a comment reply
   * @summary Edit A Comment Reply
   * @param userId
   * @param postId
   * @param commentId
   * @param replyId
   * @param editCommentReplyBody
   */
  public async editCommentReply(
    userId: string,
    postId: string,
    commentId: string,
    replyId: string,
    editCommentReplyBody: EditCommentReplyBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: EditCommentReplyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace('{' + 'replyId' + '}', encodeURIComponent(String(replyId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling editCommentReply.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling editCommentReply.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling editCommentReply.'
      );
    }

    // verify required parameter 'replyId' is not null or undefined
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling editCommentReply.'
      );
    }

    // verify required parameter 'editCommentReplyBody' is not null or undefined
    if (editCommentReplyBody === null || editCommentReplyBody === undefined) {
      throw new Error(
        'Required parameter editCommentReplyBody was null or undefined when calling editCommentReply.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        editCommentReplyBody,
        'EditCommentReplyBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: EditCommentReplyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'EditCommentReplyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to update a community profile
   * @summary Edit a community Profile
   * @param userId the user ID trying to update this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param communityProfileId The community profile ID of the community being updated | type: uint64
   * @param orgId
   * @param tenantId
   * @param communityProfile The community profile being updated | type: json_object
   */
  public async editCommunityProfile(
    userId: string,
    communityProfileId: string,
    orgId: string,
    tenantId: string,
    communityProfile: CommunityProfile,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: EditCommunityProfileRequest;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/community-profiles/{communityProfileId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'communityProfileId' + '}',
          encodeURIComponent(String(communityProfileId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling editCommunityProfile.'
      );
    }

    // verify required parameter 'communityProfileId' is not null or undefined
    if (communityProfileId === null || communityProfileId === undefined) {
      throw new Error(
        'Required parameter communityProfileId was null or undefined when calling editCommunityProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling editCommunityProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling editCommunityProfile.'
      );
    }

    // verify required parameter 'communityProfile' is not null or undefined
    if (communityProfile === null || communityProfile === undefined) {
      throw new Error(
        'Required parameter communityProfile was null or undefined when calling editCommunityProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(communityProfile, 'CommunityProfile'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: EditCommunityProfileRequest;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'EditCommunityProfileRequest'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to update a note
   * @summary Update a note
   * @param userId
   * @param postId
   * @param noteId
   * @param postType
   * @param orgId
   * @param tenantId
   * @param note
   */
  public async editNote(
    userId: string,
    postId: string,
    noteId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    note: Note,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: EditNoteResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/note/{noteId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'noteId' + '}', encodeURIComponent(String(noteId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling editNote.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling editNote.'
      );
    }

    // verify required parameter 'noteId' is not null or undefined
    if (noteId === null || noteId === undefined) {
      throw new Error(
        'Required parameter noteId was null or undefined when calling editNote.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling editNote.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling editNote.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling editNote.'
      );
    }

    // verify required parameter 'note' is not null or undefined
    if (note === null || note === undefined) {
      throw new Error(
        'Required parameter note was null or undefined when calling editNote.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(note, 'Note'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: EditNoteResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'EditNoteResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to edit a post by id
   * @summary Edits a post by id
   * @param postId The ID of the post to be updated | type: string
   * @param postType
   * @param userId
   * @param orgId
   * @param tenantId
   * @param post The post payload | type: json_object
   */
  public async editPost(
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    userId: string,
    orgId: string,
    tenantId: string,
    post: Post,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: EditPostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/post/{postId}/type/{postType}'
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling editPost.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling editPost.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling editPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling editPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling editPost.'
      );
    }

    // verify required parameter 'post' is not null or undefined
    if (post === null || post === undefined) {
      throw new Error(
        'Required parameter post was null or undefined when calling editPost.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(post, 'Post'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: EditPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'EditPostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs an updates operation on a user profile based on the provided parametersThis update operation can span multiple services on specific cases (such as when the client is explicitly attempting to update the email of the user)All update operations are atomic by nature hence we should not expect any form of divergent state
   * @summary update a user profile
   * @param userId the user ID trying to update this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   * @param userProfile the profile payload | type: json_object
   */
  public async editUserProfile(
    userId: string,
    orgId: string,
    tenantId: string,
    userProfile: UserProfile,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: EditUserProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling editUserProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling editUserProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling editUserProfile.'
      );
    }

    // verify required parameter 'userProfile' is not null or undefined
    if (userProfile === null || userProfile === undefined) {
      throw new Error(
        'Required parameter userProfile was null or undefined when calling editUserProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(userProfile, 'UserProfile'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: EditUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'EditUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to follow a community profile
   * @summary Follows A Community Profile
   * @param sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param targetCommunityProfileId the targetCommunityProfileID ID being followed by another user
   * @param orgId
   * @param tenantId
   */
  public async followCommunityProfile(
    sourceUserId: string,
    targetCommunityProfileId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: FollowCommunityProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/source/{sourceUserId}/follow/community-profiles/{targetCommunityProfileId}'
        .replace(
          '{' + 'sourceUserId' + '}',
          encodeURIComponent(String(sourceUserId))
        )
        .replace(
          '{' + 'targetCommunityProfileId' + '}',
          encodeURIComponent(String(targetCommunityProfileId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'sourceUserId' is not null or undefined
    if (sourceUserId === null || sourceUserId === undefined) {
      throw new Error(
        'Required parameter sourceUserId was null or undefined when calling followCommunityProfile.'
      );
    }

    // verify required parameter 'targetCommunityProfileId' is not null or undefined
    if (
      targetCommunityProfileId === null ||
      targetCommunityProfileId === undefined
    ) {
      throw new Error(
        'Required parameter targetCommunityProfileId was null or undefined when calling followCommunityProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling followCommunityProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling followCommunityProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: FollowCommunityProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'FollowCommunityProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to follow a user profile
   * @summary follow a user profile
   * @param sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param targetUserId the user ID being followed by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async followProfile(
    sourceUserId: string,
    targetUserId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: FollowProfileResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/source/{sourceUserId}/follow/target/{targetUserId}'
        .replace(
          '{' + 'sourceUserId' + '}',
          encodeURIComponent(String(sourceUserId))
        )
        .replace(
          '{' + 'targetUserId' + '}',
          encodeURIComponent(String(targetUserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'sourceUserId' is not null or undefined
    if (sourceUserId === null || sourceUserId === undefined) {
      throw new Error(
        'Required parameter sourceUserId was null or undefined when calling followProfile.'
      );
    }

    // verify required parameter 'targetUserId' is not null or undefined
    if (targetUserId === null || targetUserId === undefined) {
      throw new Error(
        'Required parameter targetUserId was null or undefined when calling followProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling followProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling followProfile.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: FollowProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'FollowProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all the accounts a given user follows
   * @summary Get Communities and users you are following
   * @param userId
   * @param profileId
   * @param accountType the account type of the user whoses followers are being requested
   * @param limit
   * @param orgId
   * @param tenantId
   */
  public async getAccountsFollowing(
    userId: string,
    profileId: string,
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    limit: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetAccountsFollowingResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/profile/{profileId}/account-type/{accountType}/following'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'profileId' + '}', encodeURIComponent(String(profileId)))
        .replace(
          '{' + 'accountType' + '}',
          encodeURIComponent(String(accountType))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getAccountsFollowing.'
      );
    }

    // verify required parameter 'profileId' is not null or undefined
    if (profileId === null || profileId === undefined) {
      throw new Error(
        'Required parameter profileId was null or undefined when calling getAccountsFollowing.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling getAccountsFollowing.'
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getAccountsFollowing.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getAccountsFollowing.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getAccountsFollowing.'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAccountsFollowingResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAccountsFollowingResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to query a set of blog posts tied to a tag
   * @summary Get blog posts by tag
   * @param tag
   * @param postType The type of post being reacted to | type: string
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getBlogPostsByTag(
    tag: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetBlogPostsByTagResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/posts/blog/tag/{tag}'.replace(
        '{' + 'tag' + '}',
        encodeURIComponent(String(tag))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tag' is not null or undefined
    if (tag === null || tag === undefined) {
      throw new Error(
        'Required parameter tag was null or undefined when calling getBlogPostsByTag.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling getBlogPostsByTag.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getBlogPostsByTag.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getBlogPostsByTag.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getBlogPostsByTag.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetBlogPostsByTagResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetBlogPostsByTagResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all bookmarked posts of a given user
   * @summary Get Bookmarked Posts
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getBookmarkedPosts(
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetBookmarkedPostsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/bookmarks/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getBookmarkedPosts.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getBookmarkedPosts.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getBookmarkedPosts.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetBookmarkedPostsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetBookmarkedPostsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches a user sso token for canny
   * @summary Retrieves user sso token for canny
   * @param userId
   * @param email
   * @param orgId
   * @param tenantId
   */
  public async getCannyUserSSOToken1(
    userId: string,
    email: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCannyUserSSOTokenResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/user/{userId}/canny/email/{email}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCannyUserSSOToken1.'
      );
    }

    // verify required parameter 'email' is not null or undefined
    if (email === null || email === undefined) {
      throw new Error(
        'Required parameter email was null or undefined when calling getCannyUserSSOToken1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCannyUserSSOToken1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCannyUserSSOToken1.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCannyUserSSOTokenResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCannyUserSSOTokenResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get comment replies
   * @summary Get Comment Replies
   * @param userId
   * @param postId
   * @param commentId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async getCommentReplies(
    userId: string,
    postId: string,
    commentId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommentRepliesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/replies'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace(
          '{' + 'commentId' + '}',
          encodeURIComponent(String(commentId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommentReplies.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling getCommentReplies.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling getCommentReplies.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling getCommentReplies.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommentReplies.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommentReplies.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommentRepliesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommentRepliesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all the communities a user follows
   * @summary Gets all the communities a user follows
   * @param userId the user ID who\&#39;s communities follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param limit the max number of communities to return | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async getCommunitiesUserFollows(
    userId: string,
    limit: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommunitiesUserFollowsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/communities-followed'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommunitiesUserFollows.'
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getCommunitiesUserFollows.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommunitiesUserFollows.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommunitiesUserFollows.'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommunitiesUserFollowsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommunitiesUserFollowsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get community blog posts
   * @summary Get community blog posts
   * @param communityProfileId
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getCommunityBlogPosts(
    communityProfileId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommunityBlogPostsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/community-profiles/{communityProfileId}/posts/blog'.replace(
        '{' + 'communityProfileId' + '}',
        encodeURIComponent(String(communityProfileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'communityProfileId' is not null or undefined
    if (communityProfileId === null || communityProfileId === undefined) {
      throw new Error(
        'Required parameter communityProfileId was null or undefined when calling getCommunityBlogPosts.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommunityBlogPosts.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommunityBlogPosts.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommunityBlogPosts.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommunityBlogPostsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommunityBlogPostsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client query a community feed
   * @summary Gets A Community Feed
   * @param communityProfileId The ID of the community we are trying to obtain the feed for | type: uint64
   * @param feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
   * @param accountType The type of account making the request to obtain the feed | type: string
   * @param userId
   * @param orgId
   * @param tenantId
   * @param nextPageToken
   */
  public async getCommunityFeed(
    communityProfileId: string,
    feedType:
      | 'FEED_TYPE_UNSPECIFIED'
      | 'FEED_TYPE_PERSONAL'
      | 'FEED_TYPE_NEWS'
      | 'FEED_TYPE_NOTIFICATION',
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    userId: string,
    orgId: string,
    tenantId: string,
    nextPageToken?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommunityFeedResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/community-profiles/{communityProfileId}/timeline'.replace(
        '{' + 'communityProfileId' + '}',
        encodeURIComponent(String(communityProfileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'communityProfileId' is not null or undefined
    if (communityProfileId === null || communityProfileId === undefined) {
      throw new Error(
        'Required parameter communityProfileId was null or undefined when calling getCommunityFeed.'
      );
    }

    // verify required parameter 'feedType' is not null or undefined
    if (feedType === null || feedType === undefined) {
      throw new Error(
        'Required parameter feedType was null or undefined when calling getCommunityFeed.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling getCommunityFeed.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommunityFeed.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommunityFeed.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommunityFeed.'
      );
    }

    if (feedType !== undefined) {
      localVarQueryParameters['feedType'] = ObjectSerializer.serialize(
        feedType,
        "'FEED_TYPE_UNSPECIFIED' | 'FEED_TYPE_PERSONAL' | 'FEED_TYPE_NEWS' | 'FEED_TYPE_NOTIFICATION'"
      );
    }

    if (accountType !== undefined) {
      localVarQueryParameters['accountType'] = ObjectSerializer.serialize(
        accountType,
        "'ACCOUNT_TYPE_UNSPECIFIED' | 'ACCOUNT_TYPE_USER' | 'ACCOUNT_TYPE_COMMUNITY'"
      );
    }

    if (nextPageToken !== undefined) {
      localVarQueryParameters['nextPageToken'] = ObjectSerializer.serialize(
        nextPageToken,
        'string'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommunityFeedResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommunityFeedResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get a community profile
   * @summary Get a community Profile
   * @param communityId The communityID associated with the community being requested  | type: uint64
   * @param requestorProfileId The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
   * @param requestorProfileType The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getCommunityProfile(
    communityId: string,
    requestorProfileId: string,
    requestorProfileType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommunityProfileResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/social/community-profiles/{communityId}/requestor/{requestorProfileId}/profile-type/{requestorProfileType}'
        .replace(
          '{' + 'communityId' + '}',
          encodeURIComponent(String(communityId))
        )
        .replace(
          '{' + 'requestorProfileId' + '}',
          encodeURIComponent(String(requestorProfileId))
        )
        .replace(
          '{' + 'requestorProfileType' + '}',
          encodeURIComponent(String(requestorProfileType))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'communityId' is not null or undefined
    if (communityId === null || communityId === undefined) {
      throw new Error(
        'Required parameter communityId was null or undefined when calling getCommunityProfile.'
      );
    }

    // verify required parameter 'requestorProfileId' is not null or undefined
    if (requestorProfileId === null || requestorProfileId === undefined) {
      throw new Error(
        'Required parameter requestorProfileId was null or undefined when calling getCommunityProfile.'
      );
    }

    // verify required parameter 'requestorProfileType' is not null or undefined
    if (requestorProfileType === null || requestorProfileType === undefined) {
      throw new Error(
        'Required parameter requestorProfileType was null or undefined when calling getCommunityProfile.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommunityProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommunityProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommunityProfile.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommunityProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommunityProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get community profiles
   * @summary Get Community Profiles
   * @param pageSize
   * @param pageNumber
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getCommunityProfiles(
    pageSize: number,
    pageNumber: number,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommunityProfilesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/community-profiles/page-size/{pageSize}/page-number/{pageNumber}'
        .replace('{' + 'pageSize' + '}', encodeURIComponent(String(pageSize)))
        .replace(
          '{' + 'pageNumber' + '}',
          encodeURIComponent(String(pageNumber))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getCommunityProfiles.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getCommunityProfiles.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommunityProfiles.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommunityProfiles.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommunityProfiles.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommunityProfilesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommunityProfilesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all the followers following a given user
   * @summary Get Users Following you
   * @param userId
   * @param profileId
   * @param limit
   * @param orgId
   * @param tenantId
   */
  public async getFollowers(
    userId: string,
    profileId: string,
    limit: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetFollowersResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/profile/{profileId}/followers'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'profileId' + '}',
          encodeURIComponent(String(profileId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getFollowers.'
      );
    }

    // verify required parameter 'profileId' is not null or undefined
    if (profileId === null || profileId === undefined) {
      throw new Error(
        'Required parameter profileId was null or undefined when calling getFollowers.'
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getFollowers.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getFollowers.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getFollowers.'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetFollowersResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetFollowersResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all the pending follow requests
   * @summary Get Pending Follow Requests
   * @param userId the user ID who\&#39;s pending request we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async getPendingFollows(
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetPendingFollowsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/follow/pending-requests'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPendingFollows.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPendingFollows.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPendingFollows.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPendingFollowsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPendingFollowsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to query a poll by id
   * @summary Get a poll
   * @param userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param postId The ID of the post attempted to be delete | type: string
   * @param orgId
   * @param tenantId
   */
  public async getPoll(
    userId: string,
    postId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPollResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/poll/{postId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPoll.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling getPoll.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPoll.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPoll.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPollResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetPollResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to query all polls tied to a given user id
   * @summary Get all the polls of a given user
   * @param userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async getPolls(
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPollsResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/polls'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPolls.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPolls.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPolls.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPollsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetPollsResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get a post
   * @summary Get a post
   * @param userId the user ID trying to obtain a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param postId The ID of the post to obtain | type: string
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async getPost(
    userId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/type/{postType}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPost.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling getPost.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling getPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPost.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetPostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to query a post\'s thread
   * @summary Gets A Post\'s Thread
   * @param userId
   * @param postId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async getPostThread(
    userId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPostThreadResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/thread/{postId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPostThread.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling getPostThread.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling getPostThread.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPostThread.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPostThread.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPostThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPostThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to query all posts tied to a given user id
   * @summary Get all the posts of a given user
   * @param userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param orgId
   * @param tenantId
   */
  public async getPosts(
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPostsResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/posts'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPosts.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPosts.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPosts.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPostsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetPostsResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all posts tied to a category
   * @summary Get all posts associated with a category
   * @param userId
   * @param category
   * @param postType
   * @param limit
   * @param offset
   * @param orgId
   * @param tenantId
   */
  public async getPostsByCategory(
    userId: string,
    category:
      | 'CATEGORY_UNSPECIFIED'
      | 'CATEGORY_WORLD'
      | 'CATEGORY_BUSINESS'
      | 'CATEGORY_ECONOMICS'
      | 'CATEGORY_FOREIGN_POLICY'
      | 'CATEGORY_POLITICS'
      | 'CATEGORY_TECHNOLOGY'
      | 'CATEGORY_OTHER',
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    limit: string,
    offset: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetPostsByCategoryResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/user/{userId}/category/{category}/posts/{postType}/limit/{limit}/offset/{offset}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'category' + '}', encodeURIComponent(String(category)))
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)))
        .replace('{' + 'limit' + '}', encodeURIComponent(String(limit)))
        .replace('{' + 'offset' + '}', encodeURIComponent(String(offset)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPostsByCategory.'
      );
    }

    // verify required parameter 'category' is not null or undefined
    if (category === null || category === undefined) {
      throw new Error(
        'Required parameter category was null or undefined when calling getPostsByCategory.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling getPostsByCategory.'
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getPostsByCategory.'
      );
    }

    // verify required parameter 'offset' is not null or undefined
    if (offset === null || offset === undefined) {
      throw new Error(
        'Required parameter offset was null or undefined when calling getPostsByCategory.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPostsByCategory.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPostsByCategory.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPostsByCategoryResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPostsByCategoryResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get all posts tied to a topic
   * @summary Get all posts associated with a topic
   * @param communityProfileId the community profile to associate the topic to | type: uint64
   * @param topicName the name of a given topic | type: string
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getPostsByTopic(
    communityProfileId: string,
    topicName: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetPostsByTopicResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/community/{communityProfileId}/topic/{topicName}/posts'
        .replace(
          '{' + 'communityProfileId' + '}',
          encodeURIComponent(String(communityProfileId))
        )
        .replace(
          '{' + 'topicName' + '}',
          encodeURIComponent(String(topicName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'communityProfileId' is not null or undefined
    if (communityProfileId === null || communityProfileId === undefined) {
      throw new Error(
        'Required parameter communityProfileId was null or undefined when calling getPostsByTopic.'
      );
    }

    // verify required parameter 'topicName' is not null or undefined
    if (topicName === null || topicName === undefined) {
      throw new Error(
        'Required parameter topicName was null or undefined when calling getPostsByTopic.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPostsByTopic.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPostsByTopic.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPostsByTopic.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPostsByTopicResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPostsByTopicResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get a publication
   * @summary Gets a publication
   * @param userId
   * @param publicationId
   * @param orgId
   * @param tenantId
   */
  public async getPublication(
    userId: string,
    publicationId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetPublicationResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/publication/{publicationId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getPublication.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling getPublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getPublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getPublication.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetPublicationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetPublicationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get topics of communities a user follows
   * @summary Get Topics Of Communities User Follows
   * @param userId the user ID whose communities topics follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param limit
   * @param orgId
   * @param tenantId
   */
  public async getTopicsOfCommunitiesUserFollows(
    userId: string,
    limit: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTopicsOfCommunitiesUserFollowsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/topics'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getTopicsOfCommunitiesUserFollows.'
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getTopicsOfCommunitiesUserFollows.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getTopicsOfCommunitiesUserFollows.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTopicsOfCommunitiesUserFollows.'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTopicsOfCommunitiesUserFollowsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTopicsOfCommunitiesUserFollowsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client query a user feed
   * @summary Gets A Userfeed
   * @param userId the user ID trying to obtain a given feed (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
   * @param feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
   * @param accountType The type of account making the request to obtain the feed | type: string
   * @param orgId
   * @param tenantId
   * @param nextPageToken
   */
  public async getUserFeed(
    userId: string,
    feedType:
      | 'FEED_TYPE_UNSPECIFIED'
      | 'FEED_TYPE_PERSONAL'
      | 'FEED_TYPE_NEWS'
      | 'FEED_TYPE_NOTIFICATION',
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    orgId: string,
    tenantId: string,
    nextPageToken?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetUserFeedResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/timeline'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserFeed.'
      );
    }

    // verify required parameter 'feedType' is not null or undefined
    if (feedType === null || feedType === undefined) {
      throw new Error(
        'Required parameter feedType was null or undefined when calling getUserFeed.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling getUserFeed.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserFeed.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserFeed.'
      );
    }

    if (feedType !== undefined) {
      localVarQueryParameters['feedType'] = ObjectSerializer.serialize(
        feedType,
        "'FEED_TYPE_UNSPECIFIED' | 'FEED_TYPE_PERSONAL' | 'FEED_TYPE_NEWS' | 'FEED_TYPE_NOTIFICATION'"
      );
    }

    if (accountType !== undefined) {
      localVarQueryParameters['accountType'] = ObjectSerializer.serialize(
        accountType,
        "'ACCOUNT_TYPE_UNSPECIFIED' | 'ACCOUNT_TYPE_USER' | 'ACCOUNT_TYPE_COMMUNITY'"
      );
    }

    if (nextPageToken !== undefined) {
      localVarQueryParameters['nextPageToken'] = ObjectSerializer.serialize(
        nextPageToken,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserFeedResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetUserFeedResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a query against the social service to obtain a user profile
   * @summary gets a user profile
   * @param userId The user ID associated with the profile we want to get | type: uint64
   * @param orgId
   * @param tenantId
   * @param requestorProfileId The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
   * @param requestorProfileType The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
   */
  public async getUserProfile(
    userId: string,
    orgId: string,
    tenantId: string,
    requestorProfileId?: string,
    requestorProfileType?:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetUserProfileResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserProfile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserProfile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserProfile.'
      );
    }

    if (requestorProfileId !== undefined) {
      localVarQueryParameters['requestorProfileId'] =
        ObjectSerializer.serialize(requestorProfileId, 'string');
    }

    if (requestorProfileType !== undefined) {
      localVarQueryParameters['requestorProfileType'] =
        ObjectSerializer.serialize(
          requestorProfileType,
          "'ACCOUNT_TYPE_UNSPECIFIED' | 'ACCOUNT_TYPE_USER' | 'ACCOUNT_TYPE_COMMUNITY'"
        );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserProfileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserProfileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to get a number of user profiles in a paginated manner
   * @summary Gets a set of user profiles
   * @param pageSize
   * @param pageNumber
   * @param userId
   * @param orgId
   * @param tenantId
   */
  public async getUserProfiles(
    pageSize: number,
    pageNumber: number,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserProfilesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/page-size/{pageSize}/page-number/{pageNumber}'
        .replace('{' + 'pageSize' + '}', encodeURIComponent(String(pageSize)))
        .replace(
          '{' + 'pageNumber' + '}',
          encodeURIComponent(String(pageNumber))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getUserProfiles.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getUserProfiles.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserProfiles.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getUserProfiles.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserProfiles.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserProfilesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserProfilesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a healc check on the service
   * @summary health check
   */
  public async healthCheck1(
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: HealthCheckResponse1 }> {
    const localVarPath = this.basePath + '/social-microservice/api/v1/health';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: HealthCheckResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'HealthCheckResponse1');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to react to a comment
   * @summary Reacts to a comment
   * @param userId
   * @param postId
   * @param commentId
   * @param accountType
   * @param reaction
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async reactToComment(
    userId: string,
    postId: string,
    commentId: string,
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    reaction:
      | 'REACTION_UNSPECIFIED'
      | 'REACTION_LIKE'
      | 'REACTION_LOVE'
      | 'REACTION_HAHA'
      | 'REACTION_WOW'
      | 'REACTION_SAD'
      | 'REACTION_ANGRY'
      | 'REACTION_DISLIKE',
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ReactToCommentResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/account-type/{accountType}/reaction/{reaction}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace(
          '{' + 'accountType' + '}',
          encodeURIComponent(String(accountType))
        )
        .replace('{' + 'reaction' + '}', encodeURIComponent(String(reaction)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'reaction' is not null or undefined
    if (reaction === null || reaction === undefined) {
      throw new Error(
        'Required parameter reaction was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling reactToComment.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling reactToComment.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReactToCommentResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReactToCommentResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to react to a comment reply
   * @summary Reacts to a comment reply
   * @param userId
   * @param postId
   * @param commentId
   * @param replyId
   * @param accountType
   * @param reaction
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async reactToCommentReply(
    userId: string,
    postId: string,
    commentId: string,
    replyId: string,
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    reaction:
      | 'REACTION_UNSPECIFIED'
      | 'REACTION_LIKE'
      | 'REACTION_LOVE'
      | 'REACTION_HAHA'
      | 'REACTION_WOW'
      | 'REACTION_SAD'
      | 'REACTION_ANGRY'
      | 'REACTION_DISLIKE',
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ReactToCommentReplyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}/account-type/{accountType}/reaction/{reaction}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace('{' + 'replyId' + '}', encodeURIComponent(String(replyId)))
        .replace(
          '{' + 'accountType' + '}',
          encodeURIComponent(String(accountType))
        )
        .replace('{' + 'reaction' + '}', encodeURIComponent(String(reaction)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'replyId' is not null or undefined
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'reaction' is not null or undefined
    if (reaction === null || reaction === undefined) {
      throw new Error(
        'Required parameter reaction was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling reactToCommentReply.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling reactToCommentReply.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReactToCommentReplyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReactToCommentReplyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to react to a post
   * @summary Reacts to a post
   * @param userId
   * @param postId
   * @param accountType
   * @param reaction
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async reactToPost(
    userId: string,
    postId: string,
    accountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_USER'
      | 'ACCOUNT_TYPE_COMMUNITY',
    reaction:
      | 'REACTION_UNSPECIFIED'
      | 'REACTION_LIKE'
      | 'REACTION_LOVE'
      | 'REACTION_HAHA'
      | 'REACTION_WOW'
      | 'REACTION_SAD'
      | 'REACTION_ANGRY'
      | 'REACTION_DISLIKE',
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ReactToPostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/account-type/{accountType}/reaction/{reaction}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace(
          '{' + 'accountType' + '}',
          encodeURIComponent(String(accountType))
        )
        .replace('{' + 'reaction' + '}', encodeURIComponent(String(reaction)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling reactToPost.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling reactToPost.'
      );
    }

    // verify required parameter 'accountType' is not null or undefined
    if (accountType === null || accountType === undefined) {
      throw new Error(
        'Required parameter accountType was null or undefined when calling reactToPost.'
      );
    }

    // verify required parameter 'reaction' is not null or undefined
    if (reaction === null || reaction === undefined) {
      throw new Error(
        'Required parameter reaction was null or undefined when calling reactToPost.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling reactToPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling reactToPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling reactToPost.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReactToPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ReactToPostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a readiness check on the service
   * @summary readyness check
   */
  public async readynessCheck1(
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ReadynessCheckResponse1;
  }> {
    const localVarPath = this.basePath + '/social-microservice/api/v1/ready';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReadynessCheckResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReadynessCheckResponse1'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a bookmarked post
   * @summary Deletes A Bookmarked Post
   * @param userId
   * @param postId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async removeBookmarkedPost(
    userId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RemoveBookmarkedPostResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/bookmark'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling removeBookmarkedPost.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling removeBookmarkedPost.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling removeBookmarkedPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling removeBookmarkedPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling removeBookmarkedPost.'
      );
    }

    if (postType !== undefined) {
      localVarQueryParameters['postType'] = ObjectSerializer.serialize(
        postType,
        "'POST_TYPE_UNSPECIFIED' | 'POST_TYPE_POST' | 'POST_TYPE_REPOST' | 'POST_TYPE_QUESTION' | 'POST_TYPE_ACHIEVEMENT' | 'POST_TYPE_ANNOUNCEMENT' | 'POST_TYPE_POLL' | 'POST_TYPE_ARTICLE' | 'POST_TYPE_SHORT_STORY'"
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RemoveBookmarkedPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RemoveBookmarkedPostResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a bookmarked publication
   * @summary Deletes A Bookmarked Publication
   * @param userId
   * @param publicationId
   * @param orgId
   * @param tenantId
   */
  public async removeBookmarkedPublication(
    userId: string,
    publicationId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RemoveBookmarkedPostResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/publication/{publicationId}/bookmark'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'publicationId' + '}',
          encodeURIComponent(String(publicationId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling removeBookmarkedPublication.'
      );
    }

    // verify required parameter 'publicationId' is not null or undefined
    if (publicationId === null || publicationId === undefined) {
      throw new Error(
        'Required parameter publicationId was null or undefined when calling removeBookmarkedPublication.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling removeBookmarkedPublication.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling removeBookmarkedPublication.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RemoveBookmarkedPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RemoveBookmarkedPostResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to delete a post from a thread
   * @summary Deletes A Post From A Thread
   * @param userId
   * @param parentPostId
   * @param postType
   * @param participantPostId
   * @param orgId
   * @param tenantId
   */
  public async removePostFromThread(
    userId: string,
    parentPostId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    participantPostId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RemovePostFromThreadResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/thread/{parentPostId}/type/{postType}/target/{participantPostId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'parentPostId' + '}',
          encodeURIComponent(String(parentPostId))
        )
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)))
        .replace(
          '{' + 'participantPostId' + '}',
          encodeURIComponent(String(participantPostId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling removePostFromThread.'
      );
    }

    // verify required parameter 'parentPostId' is not null or undefined
    if (parentPostId === null || parentPostId === undefined) {
      throw new Error(
        'Required parameter parentPostId was null or undefined when calling removePostFromThread.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling removePostFromThread.'
      );
    }

    // verify required parameter 'participantPostId' is not null or undefined
    if (participantPostId === null || participantPostId === undefined) {
      throw new Error(
        'Required parameter participantPostId was null or undefined when calling removePostFromThread.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling removePostFromThread.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling removePostFromThread.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RemovePostFromThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RemovePostFromThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to report a comment
   * @summary Report A Comment
   * @param userId
   * @param postId
   * @param commentId
   * @param reportCommentBody
   */
  public async reportComment(
    userId: string,
    postId: string,
    commentId: string,
    reportCommentBody: ReportCommentBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ReportCommentResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/report'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace(
          '{' + 'commentId' + '}',
          encodeURIComponent(String(commentId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling reportComment.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling reportComment.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling reportComment.'
      );
    }

    // verify required parameter 'reportCommentBody' is not null or undefined
    if (reportCommentBody === null || reportCommentBody === undefined) {
      throw new Error(
        'Required parameter reportCommentBody was null or undefined when calling reportComment.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(reportCommentBody, 'ReportCommentBody'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReportCommentResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReportCommentResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to report a comment reply
   * @summary Report A Comment Reply
   * @param userId
   * @param postId
   * @param commentId
   * @param replyId
   * @param reportCommentReplyBody
   */
  public async reportCommentReply(
    userId: string,
    postId: string,
    commentId: string,
    replyId: string,
    reportCommentReplyBody: ReportCommentReplyBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ReportCommentReplyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}/report'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace('{' + 'replyId' + '}', encodeURIComponent(String(replyId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling reportCommentReply.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling reportCommentReply.'
      );
    }

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling reportCommentReply.'
      );
    }

    // verify required parameter 'replyId' is not null or undefined
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling reportCommentReply.'
      );
    }

    // verify required parameter 'reportCommentReplyBody' is not null or undefined
    if (
      reportCommentReplyBody === null ||
      reportCommentReplyBody === undefined
    ) {
      throw new Error(
        'Required parameter reportCommentReplyBody was null or undefined when calling reportCommentReply.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        reportCommentReplyBody,
        'ReportCommentReplyBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReportCommentReplyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReportCommentReplyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to report a post
   * @summary Report a post
   * @param userId
   * @param postId
   * @param postType
   * @param orgId
   * @param tenantId
   */
  public async reportPost(
    userId: string,
    postId: string,
    postType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ReportPostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/{postId}/type/{postType}/report'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'postId' + '}', encodeURIComponent(String(postId)))
        .replace('{' + 'postType' + '}', encodeURIComponent(String(postType)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling reportPost.'
      );
    }

    // verify required parameter 'postId' is not null or undefined
    if (postId === null || postId === undefined) {
      throw new Error(
        'Required parameter postId was null or undefined when calling reportPost.'
      );
    }

    // verify required parameter 'postType' is not null or undefined
    if (postType === null || postType === undefined) {
      throw new Error(
        'Required parameter postType was null or undefined when calling reportPost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling reportPost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling reportPost.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReportPostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ReportPostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to response to a poll
   * @summary Adds a user response to a given poll by a user
   * @param userId
   * @param pollId
   * @param respondToPollBody
   */
  public async respondToPoll(
    userId: string,
    pollId: string,
    respondToPollBody: RespondToPollBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: RespondToPollResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/poll/{pollId}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace('{' + 'pollId' + '}', encodeURIComponent(String(pollId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling respondToPoll.'
      );
    }

    // verify required parameter 'pollId' is not null or undefined
    if (pollId === null || pollId === undefined) {
      throw new Error(
        'Required parameter pollId was null or undefined when calling respondToPoll.'
      );
    }

    // verify required parameter 'respondToPollBody' is not null or undefined
    if (respondToPollBody === null || respondToPollBody === undefined) {
      throw new Error(
        'Required parameter respondToPollBody was null or undefined when calling respondToPoll.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(respondToPollBody, 'RespondToPollBody'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RespondToPollResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RespondToPollResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint enables a client to share a post
   * @summary Share a post
   * @param userId
   * @param parentPostId
   * @param parentPostType
   * @param orgId
   * @param tenantId
   * @param body
   */
  public async sharePost(
    userId: string,
    parentPostId: string,
    parentPostType:
      | 'POST_TYPE_UNSPECIFIED'
      | 'POST_TYPE_POST'
      | 'POST_TYPE_REPOST'
      | 'POST_TYPE_QUESTION'
      | 'POST_TYPE_ACHIEVEMENT'
      | 'POST_TYPE_ANNOUNCEMENT'
      | 'POST_TYPE_POLL'
      | 'POST_TYPE_ARTICLE'
      | 'POST_TYPE_SHORT_STORY',
    orgId: string,
    tenantId: string,
    body: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: SharePostResponse }> {
    const localVarPath =
      this.basePath +
      '/social-microservice/api/v1/users/{userId}/post/share/{parentPostId}/type/{parentPostType}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'parentPostId' + '}',
          encodeURIComponent(String(parentPostId))
        )
        .replace(
          '{' + 'parentPostType' + '}',
          encodeURIComponent(String(parentPostType))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling sharePost.'
      );
    }

    // verify required parameter 'parentPostId' is not null or undefined
    if (parentPostId === null || parentPostId === undefined) {
      throw new Error(
        'Required parameter parentPostId was null or undefined when calling sharePost.'
      );
    }

    // verify required parameter 'parentPostType' is not null or undefined
    if (parentPostType === null || parentPostType === undefined) {
      throw new Error(
        'Required parameter parentPostType was null or undefined when calling sharePost.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling sharePost.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling sharePost.'
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling sharePost.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'string'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SharePostResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'SharePostResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
