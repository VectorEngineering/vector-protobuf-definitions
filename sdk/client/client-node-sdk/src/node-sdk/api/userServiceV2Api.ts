/**
 * User Service API
 * Solomon AI User Service API - Manages user profiles and authentication
 *
 * The version of the OpenAPI document: 1.0
 * Contact: yoanyomba@solomon-ai.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AcceptTeamMemberInvitationBody } from '../model/acceptTeamMemberInvitationBody';
import { AcceptTeamMemberInvitationResponse } from '../model/acceptTeamMemberInvitationResponse';
import { AddOrganizationMemberToOrganizationBody } from '../model/addOrganizationMemberToOrganizationBody';
import { AddOrganizationMemberToOrganizationResponse } from '../model/addOrganizationMemberToOrganizationResponse';
import { AddRoleToTenantTeamBody } from '../model/addRoleToTenantTeamBody';
import { AddRoleToTenantTeamResponse } from '../model/addRoleToTenantTeamResponse';
import { AddTenantMemberBody } from '../model/addTenantMemberBody';
import { AddTenantMemberResponse } from '../model/addTenantMemberResponse';
import { AddUserToTeamBody } from '../model/addUserToTeamBody';
import { AddUserToTeamResponse } from '../model/addUserToTeamResponse';
import { AuthenticationErrorMessageResponse } from '../model/authenticationErrorMessageResponse';
import { BadGatewayErrorMessageResponse } from '../model/badGatewayErrorMessageResponse';
import { BulkAddTeamMembersBody } from '../model/bulkAddTeamMembersBody';
import { BulkAddTeamMembersResponse } from '../model/bulkAddTeamMembersResponse';
import { BulkRemoveTeamMembersBody } from '../model/bulkRemoveTeamMembersBody';
import { BulkRemoveTeamMembersResponse } from '../model/bulkRemoveTeamMembersResponse';
import { BulkRevokeOrgAPIKeysRequest } from '../model/bulkRevokeOrgAPIKeysRequest';
import { BulkRevokeOrgAPIKeysResponse } from '../model/bulkRevokeOrgAPIKeysResponse';
import { CheckEmailAndAuth0UserIdExistsResponse } from '../model/checkEmailAndAuth0UserIdExistsResponse';
import { CheckEmailExistsV2Response } from '../model/checkEmailExistsV2Response';
import { CheckUsernameExistsV2Response } from '../model/checkUsernameExistsV2Response';
import { ConflictErrorMessageResponse } from '../model/conflictErrorMessageResponse';
import { CreateOrganizationApiKeyRequest } from '../model/createOrganizationApiKeyRequest';
import { CreateOrganizationApiKeyResponse } from '../model/createOrganizationApiKeyResponse';
import { CreateOrganizationRequest } from '../model/createOrganizationRequest';
import { CreateOrganizationResponse } from '../model/createOrganizationResponse';
import { CreateRoleResponse } from '../model/createRoleResponse';
import { CreateTeamRequest } from '../model/createTeamRequest';
import { CreateTeamResponse } from '../model/createTeamResponse';
import { CreateTenantApiKeyRequest } from '../model/createTenantApiKeyRequest';
import { CreateTenantApiKeyResponse } from '../model/createTenantApiKeyResponse';
import { CreateTenantRequest } from '../model/createTenantRequest';
import { CreateTenantResponse } from '../model/createTenantResponse';
import { CreateTenantTeamRequest } from '../model/createTenantTeamRequest';
import { CreateTenantTeamResponse } from '../model/createTenantTeamResponse';
import { CreateUserV2Request } from '../model/createUserV2Request';
import { CreateUserV2Response } from '../model/createUserV2Response';
import { DeleteOrganizationApiKeyResponse } from '../model/deleteOrganizationApiKeyResponse';
import { DeleteOrganizationResponse } from '../model/deleteOrganizationResponse';
import { DeleteRoleFromTenantTeamResponse } from '../model/deleteRoleFromTenantTeamResponse';
import { DeleteRoleResponse } from '../model/deleteRoleResponse';
import { DeleteTeamResponse } from '../model/deleteTeamResponse';
import { DeleteTenantApiKeyResponse } from '../model/deleteTenantApiKeyResponse';
import { DeleteTenantResponse } from '../model/deleteTenantResponse';
import { DeleteTenantTeamResponse } from '../model/deleteTenantTeamResponse';
import { DeleteUserV2Response } from '../model/deleteUserV2Response';
import { ForbiddenErrorMessageResponse } from '../model/forbiddenErrorMessageResponse';
import { GatewayTimeoutErrorMessageResponse } from '../model/gatewayTimeoutErrorMessageResponse';
import { GetBusinessSettingsResponse } from '../model/getBusinessSettingsResponse';
import { GetCannyUserSSOTokenResponse } from '../model/getCannyUserSSOTokenResponse';
import { GetOrgAPIKeyPermissionsResponse } from '../model/getOrgAPIKeyPermissionsResponse';
import { GetOrganizationMemberResponse } from '../model/getOrganizationMemberResponse';
import { GetOrganizationResponse } from '../model/getOrganizationResponse';
import { GetRoleResponse } from '../model/getRoleResponse';
import { GetTeamResponse } from '../model/getTeamResponse';
import { GetTenantResponse } from '../model/getTenantResponse';
import { GetTenantTeamResponse } from '../model/getTenantTeamResponse';
import { GetUserByAuth0IDResponse } from '../model/getUserByAuth0IDResponse';
import { GetUserByAuthnIDV2Response } from '../model/getUserByAuthnIDV2Response';
import { GetUserByEmailOrUsernameV2Response } from '../model/getUserByEmailOrUsernameV2Response';
import { GetUserByEmailV2Response } from '../model/getUserByEmailV2Response';
import { GetUserByUsernameV2Response } from '../model/getUserByUsernameV2Response';
import { GetUserIdV2Response } from '../model/getUserIdV2Response';
import { GetUserV2Response } from '../model/getUserV2Response';
import { GoneErrorMessageResponse } from '../model/goneErrorMessageResponse';
import { HealthCheckResponse } from '../model/healthCheckResponse';
import { InternalErrorMessageResponse } from '../model/internalErrorMessageResponse';
import { InviteTeamMemberBody } from '../model/inviteTeamMemberBody';
import { InviteTeamMemberResponse } from '../model/inviteTeamMemberResponse';
import { ListOrganizationApiKeysResponse } from '../model/listOrganizationApiKeysResponse';
import { ListOrganizationAuditLogsResponse } from '../model/listOrganizationAuditLogsResponse';
import { ListOrganizationMembersResponse } from '../model/listOrganizationMembersResponse';
import { ListOrganizationsResponse } from '../model/listOrganizationsResponse';
import { ListRolesFromTenantTeamResponse } from '../model/listRolesFromTenantTeamResponse';
import { ListRolesResponse } from '../model/listRolesResponse';
import { ListTeamInvitesResponse } from '../model/listTeamInvitesResponse';
import { ListTenantApiKeysResponse } from '../model/listTenantApiKeysResponse';
import { ListTenantAuditLogsResponse } from '../model/listTenantAuditLogsResponse';
import { ListTenantTeamMembersResponse } from '../model/listTenantTeamMembersResponse';
import { ListTenantsResponse } from '../model/listTenantsResponse';
import { MethodNotAllowedErrorMessageResponse } from '../model/methodNotAllowedErrorMessageResponse';
import { NotFoundErrorMessageResponse } from '../model/notFoundErrorMessageResponse';
import { NotImplementedErrorMessageResponse } from '../model/notImplementedErrorMessageResponse';
import { Organization } from '../model/organization';
import { PasswordResetWebhookV2Response } from '../model/passwordResetWebhookV2Response';
import { PaymentRequiredErrorMessageResponse } from '../model/paymentRequiredErrorMessageResponse';
import { PreconditionFailedErrorMessageResponse } from '../model/preconditionFailedErrorMessageResponse';
import { RateLimitErrorMessageResponse } from '../model/rateLimitErrorMessageResponse';
import { ReadynessCheckResponse } from '../model/readynessCheckResponse';
import { RejectTeamMemberInvitationBody } from '../model/rejectTeamMemberInvitationBody';
import { RejectTeamMemberInvitationResponse } from '../model/rejectTeamMemberInvitationResponse';
import { RemoveOrganizationMemberFromOrganizationResponse } from '../model/removeOrganizationMemberFromOrganizationResponse';
import { RemoveTenantTeamMemberResponse } from '../model/removeTenantTeamMemberResponse';
import { RemoveUserFromTeamResponse } from '../model/removeUserFromTeamResponse';
import { Role } from '../model/role';
import { RotateOrgAPIKeyResponse } from '../model/rotateOrgAPIKeyResponse';
import { ServiceUnavailableErrorMessageResponse } from '../model/serviceUnavailableErrorMessageResponse';
import { Status } from '../model/status';
import { Team } from '../model/team';
import { TooEarlyErrorMessageResponse } from '../model/tooEarlyErrorMessageResponse';
import { UnprocessableEntityErrorMessageResponse } from '../model/unprocessableEntityErrorMessageResponse';
import { UpdateOrganizationResponse } from '../model/updateOrganizationResponse';
import { UpdateRoleResponse } from '../model/updateRoleResponse';
import { UpdateTeamResponse } from '../model/updateTeamResponse';
import { UpdateTenantRequest } from '../model/updateTenantRequest';
import { UpdateTenantResponse } from '../model/updateTenantResponse';
import { UpdateTenantTeamMemberRequest } from '../model/updateTenantTeamMemberRequest';
import { UpdateTenantTeamMemberResponse } from '../model/updateTenantTeamMemberResponse';
import { UpdateTenantTeamResponse } from '../model/updateTenantTeamResponse';
import { UpdateUserV2Request } from '../model/updateUserV2Request';
import { UpdateUserV2Response } from '../model/updateUserV2Response';
import { ValidationErrorMessageResponse } from '../model/validationErrorMessageResponse';
import { VerifyOrgAPIKeyRequest } from '../model/verifyOrgAPIKeyRequest';
import { VerifyOrgAPIKeyResponse } from '../model/verifyOrgAPIKeyResponse';
import { VerifyUserV2Response } from '../model/verifyUserV2Response';

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from '../model/models';
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://user-service.platform.svc.cluster.local:9896';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum UserServiceV2ApiApiKeys {
  ApiKeyAuth,
  Bearer,
}

export class UserServiceV2Api {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    ApiKeyAuth: new ApiKeyAuth('header', 'X-API-Key'),
    Bearer: new ApiKeyAuth('header', 'Authorization'),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: UserServiceV2ApiApiKeys, value: string) {
    (this.authentications as any)[UserServiceV2ApiApiKeys[key]].apiKey = value;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * This endpoint accepts an invitation for a member to join a tenant based on the provided tenant ID and member email.The acceptance process ensures that the member is properly associated with the tenant.
   * @summary Accepts a team member invitation
   * @param tenantId
   * @param acceptTeamMemberInvitationBody
   */
  public async acceptTeamMemberInvitation(
    tenantId: string,
    acceptTeamMemberInvitationBody: AcceptTeamMemberInvitationBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AcceptTeamMemberInvitationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/accept-teammember-invitation'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling acceptTeamMemberInvitation.'
      );
    }

    // verify required parameter 'acceptTeamMemberInvitationBody' is not null or undefined
    if (
      acceptTeamMemberInvitationBody === null ||
      acceptTeamMemberInvitationBody === undefined
    ) {
      throw new Error(
        'Required parameter acceptTeamMemberInvitationBody was null or undefined when calling acceptTeamMemberInvitation.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        acceptTeamMemberInvitationBody,
        'AcceptTeamMemberInvitationBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AcceptTeamMemberInvitationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AcceptTeamMemberInvitationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a member to an organization based on the provided organization ID and member ID.The addition process ensures that the member is properly associated with the organization.
   * @summary Adds a member to an organization
   * @param organizationId
   * @param addOrganizationMemberToOrganizationBody
   */
  public async addOrganizationMemberToOrganization(
    organizationId: string,
    addOrganizationMemberToOrganizationBody: AddOrganizationMemberToOrganizationBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddOrganizationMemberToOrganizationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization/{organizationId}/add-new-member'.replace(
        '{' + 'organizationId' + '}',
        encodeURIComponent(String(organizationId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling addOrganizationMemberToOrganization.'
      );
    }

    // verify required parameter 'addOrganizationMemberToOrganizationBody' is not null or undefined
    if (
      addOrganizationMemberToOrganizationBody === null ||
      addOrganizationMemberToOrganizationBody === undefined
    ) {
      throw new Error(
        'Required parameter addOrganizationMemberToOrganizationBody was null or undefined when calling addOrganizationMemberToOrganization.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addOrganizationMemberToOrganizationBody,
        'AddOrganizationMemberToOrganizationBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddOrganizationMemberToOrganizationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddOrganizationMemberToOrganizationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a role to a team based on the provided tenant ID, team ID, and role details.The addition process ensures that the role is properly associated with the team.
   * @summary Adds a role to a team
   * @param tenantId
   * @param teamId
   * @param addRoleToTenantTeamBody
   */
  public async addRoleToTenantTeam(
    tenantId: string,
    teamId: string,
    addRoleToTenantTeamBody: AddRoleToTenantTeamBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddRoleToTenantTeamResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/team/{teamId}/add-role'
        .replace('{' + 'tenantId' + '}', encodeURIComponent(String(tenantId)))
        .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addRoleToTenantTeam.'
      );
    }

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling addRoleToTenantTeam.'
      );
    }

    // verify required parameter 'addRoleToTenantTeamBody' is not null or undefined
    if (
      addRoleToTenantTeamBody === null ||
      addRoleToTenantTeamBody === undefined
    ) {
      throw new Error(
        'Required parameter addRoleToTenantTeamBody was null or undefined when calling addRoleToTenantTeam.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addRoleToTenantTeamBody,
        'AddRoleToTenantTeamBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddRoleToTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddRoleToTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a member to a tenant based on the provided tenant ID and member ID.The addition process ensures that the member is properly associated with the tenant.
   * @summary Adds a member to a tenant
   * @param tenantId
   * @param addTenantMemberBody
   */
  public async addTenantMember(
    tenantId: string,
    addTenantMemberBody: AddTenantMemberBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: AddTenantMemberResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/add-new-teammember'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling addTenantMember.'
      );
    }

    // verify required parameter 'addTenantMemberBody' is not null or undefined
    if (addTenantMemberBody === null || addTenantMemberBody === undefined) {
      throw new Error(
        'Required parameter addTenantMemberBody was null or undefined when calling addTenantMember.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        addTenantMemberBody,
        'AddTenantMemberBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddTenantMemberResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddTenantMemberResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a user to a team based on the provided team ID and user ID.The addition process ensures that the user is properly associated with the team.
   * @summary Adds a user to a team
   * @param teamId
   * @param addUserToTeamBody
   */
  public async addUserToTeam(
    teamId: string,
    addUserToTeamBody: AddUserToTeamBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: AddUserToTeamResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/team/{teamId}/add-new-user'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling addUserToTeam.'
      );
    }

    // verify required parameter 'addUserToTeamBody' is not null or undefined
    if (addUserToTeamBody === null || addUserToTeamBody === undefined) {
      throw new Error(
        'Required parameter addUserToTeamBody was null or undefined when calling addUserToTeam.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(addUserToTeamBody, 'AddUserToTeamBody'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AddUserToTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'AddUserToTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Adds multiple members to a team in a single operation
   * @summary Bulk add team members
   * @param teamId Team identifier (required)
   * @param bulkAddTeamMembersBody
   */
  public async bulkAddTeamMembers(
    teamId: string,
    bulkAddTeamMembersBody: BulkAddTeamMembersBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BulkAddTeamMembersResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/team/{teamId}/members/bulk-add'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling bulkAddTeamMembers.'
      );
    }

    // verify required parameter 'bulkAddTeamMembersBody' is not null or undefined
    if (
      bulkAddTeamMembersBody === null ||
      bulkAddTeamMembersBody === undefined
    ) {
      throw new Error(
        'Required parameter bulkAddTeamMembersBody was null or undefined when calling bulkAddTeamMembers.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        bulkAddTeamMembersBody,
        'BulkAddTeamMembersBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BulkAddTeamMembersResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BulkAddTeamMembersResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Removes multiple members from a team in a single operation
   * @summary Bulk remove team members
   * @param teamId Team identifier (required)
   * @param bulkRemoveTeamMembersBody
   */
  public async bulkRemoveTeamMembers(
    teamId: string,
    bulkRemoveTeamMembersBody: BulkRemoveTeamMembersBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BulkRemoveTeamMembersResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/team/{teamId}/members/bulk-remove'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling bulkRemoveTeamMembers.'
      );
    }

    // verify required parameter 'bulkRemoveTeamMembersBody' is not null or undefined
    if (
      bulkRemoveTeamMembersBody === null ||
      bulkRemoveTeamMembersBody === undefined
    ) {
      throw new Error(
        'Required parameter bulkRemoveTeamMembersBody was null or undefined when calling bulkRemoveTeamMembers.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        bulkRemoveTeamMembersBody,
        'BulkRemoveTeamMembersBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BulkRemoveTeamMembersResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BulkRemoveTeamMembersResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint revokes (deletes) multiple API keys in a single operation. It accepts a list of key IDs to be revoked.
   * @summary Revokes multiple API keys
   * @param bulkRevokeOrgAPIKeysRequest
   */
  public async bulkRevokeOrgAPIKeys(
    bulkRevokeOrgAPIKeysRequest: BulkRevokeOrgAPIKeysRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BulkRevokeOrgAPIKeysResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/api-keys/bulk-revoke';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'bulkRevokeOrgAPIKeysRequest' is not null or undefined
    if (
      bulkRevokeOrgAPIKeysRequest === null ||
      bulkRevokeOrgAPIKeysRequest === undefined
    ) {
      throw new Error(
        'Required parameter bulkRevokeOrgAPIKeysRequest was null or undefined when calling bulkRevokeOrgAPIKeys.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        bulkRevokeOrgAPIKeysRequest,
        'BulkRevokeOrgAPIKeysRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BulkRevokeOrgAPIKeysResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BulkRevokeOrgAPIKeysResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Checks if an email and auth0 user id exists or not
   * @summary Checks that an email and auth0 user id exists or not
   * @param email The email of the user of interest
   * @param supabaseAuth0UserId The auth0 user id of the user
   * @param organizationId
   * @param tenantId
   */
  public async checkEmailAndAuth0UserIdExists(
    email: string,
    supabaseAuth0UserId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CheckEmailAndAuth0UserIdExistsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user/email/{email}/auth0/{supabaseAuth0UserId}/exists'
        .replace('{' + 'email' + '}', encodeURIComponent(String(email)))
        .replace(
          '{' + 'supabaseAuth0UserId' + '}',
          encodeURIComponent(String(supabaseAuth0UserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'email' is not null or undefined
    if (email === null || email === undefined) {
      throw new Error(
        'Required parameter email was null or undefined when calling checkEmailAndAuth0UserIdExists.'
      );
    }

    // verify required parameter 'supabaseAuth0UserId' is not null or undefined
    if (supabaseAuth0UserId === null || supabaseAuth0UserId === undefined) {
      throw new Error(
        'Required parameter supabaseAuth0UserId was null or undefined when calling checkEmailAndAuth0UserIdExists.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling checkEmailAndAuth0UserIdExists.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling checkEmailAndAuth0UserIdExists.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CheckEmailAndAuth0UserIdExistsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CheckEmailAndAuth0UserIdExistsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Checks if an email exists in the system with comprehensive validation
   * @summary Validate email existence
   * @param email
   * @param profileType the profile type of the given user we hope to query   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async checkEmailExistsV2(
    email: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CheckEmailExistsV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/email/{email}/exists'.replace(
        '{' + 'email' + '}',
        encodeURIComponent(String(email))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'email' is not null or undefined
    if (email === null || email === undefined) {
      throw new Error(
        'Required parameter email was null or undefined when calling checkEmailExistsV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling checkEmailExistsV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling checkEmailExistsV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling checkEmailExistsV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CheckEmailExistsV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CheckEmailExistsV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Checks if a username exists in the system with comprehensive validation
   * @summary Validate username existence
   * @param username The username of the user of interest
   * @param profileType the profile type of the given user we hope to query   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async checkUsernameExistsV2(
    username: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CheckUsernameExistsV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/username/{username}/exists'.replace(
        '{' + 'username' + '}',
        encodeURIComponent(String(username))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'username' is not null or undefined
    if (username === null || username === undefined) {
      throw new Error(
        'Required parameter username was null or undefined when calling checkUsernameExistsV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling checkUsernameExistsV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling checkUsernameExistsV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling checkUsernameExistsV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CheckUsernameExistsV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CheckUsernameExistsV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a new organization to the system. It requires organization details such as name, description, and members.The creation process involves adding the organization to the database and initializing its members.
   * @summary Creates a new organization
   * @param createOrganizationRequest
   */
  public async createOrganization(
    createOrganizationRequest: CreateOrganizationRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateOrganizationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createOrganizationRequest' is not null or undefined
    if (
      createOrganizationRequest === null ||
      createOrganizationRequest === undefined
    ) {
      throw new Error(
        'Required parameter createOrganizationRequest was null or undefined when calling createOrganization.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createOrganizationRequest,
        'CreateOrganizationRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateOrganizationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateOrganizationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new API key for an organization. It requires details such as name, expiration, and permissions.
   * @summary Creates a new organization API key
   * @param createOrganizationApiKeyRequest
   */
  public async createOrganizationApiKey(
    createOrganizationApiKeyRequest: CreateOrganizationApiKeyRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateOrganizationApiKeyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization-api-key';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createOrganizationApiKeyRequest' is not null or undefined
    if (
      createOrganizationApiKeyRequest === null ||
      createOrganizationApiKeyRequest === undefined
    ) {
      throw new Error(
        'Required parameter createOrganizationApiKeyRequest was null or undefined when calling createOrganizationApiKey.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createOrganizationApiKeyRequest,
        'CreateOrganizationApiKeyRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateOrganizationApiKeyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateOrganizationApiKeyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a new role to the system. It requires role details such as name, type, and permissions.The creation process involves adding the role to the database and initializing its permissions.
   * @summary Creates a new role
   * @param organizationId
   * @param tenantId
   * @param role
   */
  public async createRole(
    organizationId: string,
    tenantId: string,
    role: Role,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateRoleResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/role';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling createRole.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling createRole.'
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        'Required parameter role was null or undefined when calling createRole.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(role, 'Role'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateRoleResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateRoleResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a new team to the system. It requires team details such as name, description, and members.The creation process involves adding the team to the database and initializing its members.
   * @summary Creates a new team
   * @param createTeamRequest
   */
  public async createTeam(
    createTeamRequest: CreateTeamRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateTeamResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/team';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createTeamRequest' is not null or undefined
    if (createTeamRequest === null || createTeamRequest === undefined) {
      throw new Error(
        'Required parameter createTeamRequest was null or undefined when calling createTeam.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createTeamRequest, 'CreateTeamRequest'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateTeamResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a new tenant to the system. It requires tenant details such as name, description, and members.The creation process involves adding the tenant to the database and initializing its members.
   * @summary Creates a new tenant
   * @param createTenantRequest
   */
  public async createTenant(
    createTenantRequest: CreateTenantRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateTenantResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/tenant';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createTenantRequest' is not null or undefined
    if (createTenantRequest === null || createTenantRequest === undefined) {
      throw new Error(
        'Required parameter createTenantRequest was null or undefined when calling createTenant.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createTenantRequest,
        'CreateTenantRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateTenantResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateTenantResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new API key for a tenant. It requires details such as name, expiration, and permissions.
   * @summary Creates a new tenant API key
   * @param createTenantApiKeyRequest
   */
  public async createTenantApiKey(
    createTenantApiKeyRequest: CreateTenantApiKeyRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateTenantApiKeyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant-api-key';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createTenantApiKeyRequest' is not null or undefined
    if (
      createTenantApiKeyRequest === null ||
      createTenantApiKeyRequest === undefined
    ) {
      throw new Error(
        'Required parameter createTenantApiKeyRequest was null or undefined when calling createTenantApiKey.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createTenantApiKeyRequest,
        'CreateTenantApiKeyRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateTenantApiKeyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateTenantApiKeyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint adds a new team to the system. It requires team details such as name, description, and members.The creation process involves adding the team to the database and initializing its members.
   * @summary Creates a new team
   * @param createTenantTeamRequest
   */
  public async createTenantTeam(
    createTenantTeamRequest: CreateTenantTeamRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateTenantTeamResponse;
  }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/tenant-team';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createTenantTeamRequest' is not null or undefined
    if (
      createTenantTeamRequest === null ||
      createTenantTeamRequest === undefined
    ) {
      throw new Error(
        'Required parameter createTenantTeamRequest was null or undefined when calling createTenantTeam.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createTenantTeamRequest,
        'CreateTenantTeamRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Creates a new user account with comprehensive setup across multiple services. Handles different account types and ensures proper initialization of all components. Includes security measures and validation.
   * @summary Create new user account
   * @param createUserV2Request CreateUserV2Request represents the request object for creating a user account in the user service (version 2). This message encapsulates all necessary information to create a user account, including authentication details, contact information, and profile preferences.
   */
  public async createUserV2(
    createUserV2Request: CreateUserV2Request,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateUserV2Response }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createUserV2Request' is not null or undefined
    if (createUserV2Request === null || createUserV2Request === undefined) {
      throw new Error(
        'Required parameter createUserV2Request was null or undefined when calling createUserV2.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUserV2Request,
        'CreateUserV2Request'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateUserV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateUserV2Response');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes an organization from the system based on the provided organization ID.The deletion process ensures that all related data and members are properly removed.
   * @summary Deletes an organization
   * @param organizationId
   * @param ownerSupabaseAuthUserId
   */
  public async deleteOrganization(
    organizationId: string,
    ownerSupabaseAuthUserId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteOrganizationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization/{organizationId}/admin/{ownerSupabaseAuthUserId}'
        .replace(
          '{' + 'organizationId' + '}',
          encodeURIComponent(String(organizationId))
        )
        .replace(
          '{' + 'ownerSupabaseAuthUserId' + '}',
          encodeURIComponent(String(ownerSupabaseAuthUserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteOrganization.'
      );
    }

    // verify required parameter 'ownerSupabaseAuthUserId' is not null or undefined
    if (
      ownerSupabaseAuthUserId === null ||
      ownerSupabaseAuthUserId === undefined
    ) {
      throw new Error(
        'Required parameter ownerSupabaseAuthUserId was null or undefined when calling deleteOrganization.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteOrganizationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteOrganizationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes an organization API key based on the provided key ID.
   * @summary Deletes an organization API key
   * @param organizationApiKeyId
   * @param organizationId
   * @param ownerSupabaseAuthUserId
   */
  public async deleteOrganizationApiKey(
    organizationApiKeyId: string,
    organizationId: string,
    ownerSupabaseAuthUserId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteOrganizationApiKeyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization-api-key/{organizationApiKeyId}'.replace(
        '{' + 'organizationApiKeyId' + '}',
        encodeURIComponent(String(organizationApiKeyId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationApiKeyId' is not null or undefined
    if (organizationApiKeyId === null || organizationApiKeyId === undefined) {
      throw new Error(
        'Required parameter organizationApiKeyId was null or undefined when calling deleteOrganizationApiKey.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteOrganizationApiKey.'
      );
    }

    // verify required parameter 'ownerSupabaseAuthUserId' is not null or undefined
    if (
      ownerSupabaseAuthUserId === null ||
      ownerSupabaseAuthUserId === undefined
    ) {
      throw new Error(
        'Required parameter ownerSupabaseAuthUserId was null or undefined when calling deleteOrganizationApiKey.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (ownerSupabaseAuthUserId !== undefined) {
      localVarQueryParameters['ownerSupabaseAuthUserId'] =
        ObjectSerializer.serialize(ownerSupabaseAuthUserId, 'string');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteOrganizationApiKeyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteOrganizationApiKeyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a role from the system based on the provided role ID.The deletion process ensures that all related data and permissions are properly removed.
   * @summary Deletes a role
   * @param id
   * @param organizationId
   * @param tenantId
   */
  public async deleteRole(
    id: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteRoleResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/role/{id}'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling deleteRole.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteRole.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteRole.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteRoleResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteRoleResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a role from a team based on the provided tenant ID, team ID, and role ID.The deletion process ensures that the role is properly disassociated from the team.
   * @summary Deletes a role from a team
   * @param tenantId
   * @param teamId
   * @param organizationId
   * @param roleId
   */
  public async deleteRoleFromTenantTeam(
    tenantId: string,
    teamId: string,
    organizationId: string,
    roleId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteRoleFromTenantTeamResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/team/{teamId}/delete-role'
        .replace('{' + 'tenantId' + '}', encodeURIComponent(String(tenantId)))
        .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteRoleFromTenantTeam.'
      );
    }

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling deleteRoleFromTenantTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteRoleFromTenantTeam.'
      );
    }

    // verify required parameter 'roleId' is not null or undefined
    if (roleId === null || roleId === undefined) {
      throw new Error(
        'Required parameter roleId was null or undefined when calling deleteRoleFromTenantTeam.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (roleId !== undefined) {
      localVarQueryParameters['roleId'] = ObjectSerializer.serialize(
        roleId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteRoleFromTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteRoleFromTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a team from the system based on the provided team ID.The deletion process ensures that all related data and members are properly removed.
   * @summary Deletes a team
   * @param teamId
   * @param adminSupabaseAuth0UserId
   * @param organizationId
   * @param tenantId
   */
  public async deleteTeam(
    teamId: string,
    adminSupabaseAuth0UserId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteTeamResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/team/{teamId}/admin/{adminSupabaseAuth0UserId}'
        .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
        .replace(
          '{' + 'adminSupabaseAuth0UserId' + '}',
          encodeURIComponent(String(adminSupabaseAuth0UserId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling deleteTeam.'
      );
    }

    // verify required parameter 'adminSupabaseAuth0UserId' is not null or undefined
    if (
      adminSupabaseAuth0UserId === null ||
      adminSupabaseAuth0UserId === undefined
    ) {
      throw new Error(
        'Required parameter adminSupabaseAuth0UserId was null or undefined when calling deleteTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteTeam.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteTeam.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteTeamResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a tenant from the system based on the provided tenant ID.The deletion process ensures that all related data and members are properly removed.
   * @summary Deletes a tenant
   * @param tenantId
   * @param organizationId
   */
  public async deleteTenant(
    tenantId: string,
    organizationId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteTenantResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/organization/{organizationId}'
        .replace('{' + 'tenantId' + '}', encodeURIComponent(String(tenantId)))
        .replace(
          '{' + 'organizationId' + '}',
          encodeURIComponent(String(organizationId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteTenant.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteTenant.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteTenantResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteTenantResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a tenant API key based on the provided key ID.
   * @summary Deletes a tenant API key
   * @param tenantApiKeyId
   * @param organizationId
   * @param tenantId
   */
  public async deleteTenantApiKey(
    tenantApiKeyId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteTenantApiKeyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant-api-key/{tenantApiKeyId}'.replace(
        '{' + 'tenantApiKeyId' + '}',
        encodeURIComponent(String(tenantApiKeyId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantApiKeyId' is not null or undefined
    if (tenantApiKeyId === null || tenantApiKeyId === undefined) {
      throw new Error(
        'Required parameter tenantApiKeyId was null or undefined when calling deleteTenantApiKey.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteTenantApiKey.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteTenantApiKey.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteTenantApiKeyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteTenantApiKeyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a team from the system based on the provided team ID.The deletion process ensures that all related data and members are properly removed.
   * @summary Deletes a team
   * @param teamId
   * @param organizationId
   * @param tenantId
   */
  public async deleteTenantTeam(
    teamId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteTenantTeamResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant-team/{teamId}'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling deleteTenantTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteTenantTeam.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteTenantTeam.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Performs a complete deletion of a user account and associated data across all services. This operation is atomic and ensures consistency across all affected services. Includes comprehensive cleanup and audit trail creation.
   * @summary Delete user account and associated data
   * @param userId The account ID associated with the user to delete Validations: - user_id must be greater than 0
   * @param profileType the profile type of the given user we hope to query   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async deleteUserV2(
    userId: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteUserV2Response }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteUserV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling deleteUserV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling deleteUserV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteUserV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteUserV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteUserV2Response');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches a user sso token for canny
   * @summary Retrieves user sso token for canny
   * @param userId The account ID associated with the user
   * @param profileType Indicates the profile type to be queried. For example: \&quot;username:testuser\&quot;   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async getCannyUserSSOToken(
    userId: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCannyUserSSOTokenResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/canny/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCannyUserSSOToken.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getCannyUserSSOToken.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getCannyUserSSOToken.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCannyUserSSOToken.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCannyUserSSOTokenResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCannyUserSSOTokenResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches the permissions associated with a specific API key using the key ID.
   * @summary Retrieves permissions for an API key
   * @param keyId The unique identifier of the API key whose permissions are being requested
   * @param organizationId
   * @param tenantId
   */
  public async getOrgAPIKeyPermissions(
    keyId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetOrgAPIKeyPermissionsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/api-keys/{keyId}/permissions'.replace(
        '{' + 'keyId' + '}',
        encodeURIComponent(String(keyId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'keyId' is not null or undefined
    if (keyId === null || keyId === undefined) {
      throw new Error(
        'Required parameter keyId was null or undefined when calling getOrgAPIKeyPermissions.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getOrgAPIKeyPermissions.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getOrgAPIKeyPermissions.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetOrgAPIKeyPermissionsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetOrgAPIKeyPermissionsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches details of a specific organization using the organization ID.It retrieves the organization\'s name, description, members, and audit history.
   * @summary Retrieves an organization
   * @param organizationId
   */
  public async getOrganization(
    organizationId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetOrganizationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization/{organizationId}'.replace(
        '{' + 'organizationId' + '}',
        encodeURIComponent(String(organizationId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getOrganization.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetOrganizationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetOrganizationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches details of a specific member in an organization using the organization ID and member ID.It retrieves the member\'s name, email, role, and audit history.
   * @summary Retrieves a member of an organization
   * @param organizationId
   * @param organizationMemberId
   */
  public async getOrganizationMember(
    organizationId: string,
    organizationMemberId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetOrganizationMemberResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization/{organizationId}/member/{organizationMemberId}'
        .replace(
          '{' + 'organizationId' + '}',
          encodeURIComponent(String(organizationId))
        )
        .replace(
          '{' + 'organizationMemberId' + '}',
          encodeURIComponent(String(organizationMemberId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getOrganizationMember.'
      );
    }

    // verify required parameter 'organizationMemberId' is not null or undefined
    if (organizationMemberId === null || organizationMemberId === undefined) {
      throw new Error(
        'Required parameter organizationMemberId was null or undefined when calling getOrganizationMember.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetOrganizationMemberResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetOrganizationMemberResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches details of a specific role using the role ID.It retrieves the role\'s name, type, permissions, and audit history.
   * @summary Retrieves a role
   * @param id
   * @param organizationId
   * @param tenantId
   */
  public async getRole(
    id: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetRoleResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/role/{id}'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getRole.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getRole.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getRole.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetRoleResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetRoleResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches details of a specific team using the team ID.It retrieves the team\'s name, description, members, and audit history.
   * @summary Retrieves a team
   * @param teamId
   * @param organizationId
   * @param tenantId
   */
  public async getTeam(
    teamId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetTeamResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/team/{teamId}'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling getTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getTeam.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTeam.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetTeamResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches details of a specific tenant using the tenant ID.It retrieves the tenant\'s name, description, members, and audit history.
   * @summary Retrieves a tenant
   * @param tenantId
   * @param organizationId
   */
  public async getTenant(
    tenantId: string,
    organizationId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetTenantResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTenant.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getTenant.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTenantResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetTenantResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint fetches details of a specific team using the team ID.It retrieves the team\'s name, description, members, and audit history.
   * @summary Retrieves a team
   * @param teamId
   * @param organizationId
   * @param tenantId
   */
  public async getTenantTeam(
    teamId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetTenantTeamResponse }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant-team/{teamId}'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling getTenantTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getTenantTeam.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getTenantTeam.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches detailed information about a user account based on the specified authn ID.
   * @summary Retrieve user account details by auth0 id and profile type
   * @param supabaseAuth0UserId The account ID associated with the user
   * @param profileType Indicates the profile type to be queried. For example: \&quot;username:testuser\&quot;   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async getUserByAuth0ID(
    supabaseAuth0UserId: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserByAuth0IDResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/auth-zero/{supabaseAuth0UserId}'.replace(
        '{' + 'supabaseAuth0UserId' + '}',
        encodeURIComponent(String(supabaseAuth0UserId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'supabaseAuth0UserId' is not null or undefined
    if (supabaseAuth0UserId === null || supabaseAuth0UserId === undefined) {
      throw new Error(
        'Required parameter supabaseAuth0UserId was null or undefined when calling getUserByAuth0ID.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserByAuth0ID.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserByAuth0ID.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserByAuth0ID.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserByAuth0IDResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserByAuth0IDResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches user information using authentication system identifiers. Includes security validation and data privacy controls.
   * @summary Retrieve user details by authentication ID
   * @param authnId Specifies the user\&#39;s authn account ID.  Validations: - Must be greater than 0.
   * @param profileType Indicates the profile type to be queried. For example: \&quot;username:testuser\&quot;   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async getUserByAuthnIDV2(
    authnId: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserByAuthnIDV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/authn/{authnId}'.replace(
        '{' + 'authnId' + '}',
        encodeURIComponent(String(authnId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'authnId' is not null or undefined
    if (authnId === null || authnId === undefined) {
      throw new Error(
        'Required parameter authnId was null or undefined when calling getUserByAuthnIDV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserByAuthnIDV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserByAuthnIDV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserByAuthnIDV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserByAuthnIDV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserByAuthnIDV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches a user account using the provided email or username. Performs validation and security checks.
   * @summary Retrieve user account by email or username
   * @param profileType The profile type of the user   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   * @param email The email of the user of interest
   * @param username The username of the user of interest
   */
  public async getUserByEmailOrUsernameV2(
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    email?: string,
    username?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserByEmailOrUsernameV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/account/query-by-email-or-username';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserByEmailOrUsernameV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserByEmailOrUsernameV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserByEmailOrUsernameV2.'
      );
    }

    if (email !== undefined) {
      localVarQueryParameters['email'] = ObjectSerializer.serialize(
        email,
        'string'
      );
    }

    if (username !== undefined) {
      localVarQueryParameters['username'] = ObjectSerializer.serialize(
        username,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserByEmailOrUsernameV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserByEmailOrUsernameV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Provides detailed information of a user based on the given email.
   * @summary Retrieve user details by email
   * @param email
   * @param profileType the profile type of the given user we hope to query   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async getUserByEmailV2(
    email: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserByEmailV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/email/{email}'.replace(
        '{' + 'email' + '}',
        encodeURIComponent(String(email))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'email' is not null or undefined
    if (email === null || email === undefined) {
      throw new Error(
        'Required parameter email was null or undefined when calling getUserByEmailV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserByEmailV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserByEmailV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserByEmailV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserByEmailV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserByEmailV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Provides detailed information of a user based on the given username.
   * @summary Retrieve user details by username
   * @param username The username of the user of interest
   * @param profileType The profile type of the user   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async getUserByUsernameV2(
    username: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetUserByUsernameV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/username/{username}'.replace(
        '{' + 'username' + '}',
        encodeURIComponent(String(username))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'username' is not null or undefined
    if (username === null || username === undefined) {
      throw new Error(
        'Required parameter username was null or undefined when calling getUserByUsernameV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserByUsernameV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserByUsernameV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserByUsernameV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserByUsernameV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetUserByUsernameV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Looks up user ID using flexible search criteria with comprehensive validation. Supports multiple search parameters and ensures accurate results.
   * @summary Retrieve user ID by search criteria
   * @param profileType  - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   * @param email The email of the user of interest
   * @param username The username of the user of interest
   */
  public async getUserIdV2(
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    email?: string,
    username?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetUserIdV2Response }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/query-id';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserIdV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserIdV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserIdV2.'
      );
    }

    if (email !== undefined) {
      localVarQueryParameters['email'] = ObjectSerializer.serialize(
        email,
        'string'
      );
    }

    if (username !== undefined) {
      localVarQueryParameters['username'] = ObjectSerializer.serialize(
        username,
        'string'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserIdV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetUserIdV2Response');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches detailed information about a user account based on the specified user ID.
   * @summary Retrieve user account details
   * @param userId Specifies the user\&#39;s account ID.  Validations: - Must be greater than 0.
   * @param profileType Indicates the profile type to be queried. For example: \&quot;username:testuser\&quot;   - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   * @param organizationId
   * @param tenantId
   */
  public async getUserV2(
    userId: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetUserV2Response }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getUserV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling getUserV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling getUserV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getUserV2.'
      );
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetUserV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetUserV2Response');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a healc check on the service
   * @summary health check
   */
  public async healthCheck(
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: HealthCheckResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/health';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: HealthCheckResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'HealthCheckResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint sends an invitation to a member to join a tenant based on the provided tenant ID and member email.The invitation process ensures that the member receives an email with the invitation details.
   * @summary Invites a member to a tenant
   * @param tenantId
   * @param inviteTeamMemberBody
   */
  public async inviteTeamMember(
    tenantId: string,
    inviteTeamMemberBody: InviteTeamMemberBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: InviteTeamMemberResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/invite-teammember'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling inviteTeamMember.'
      );
    }

    // verify required parameter 'inviteTeamMemberBody' is not null or undefined
    if (inviteTeamMemberBody === null || inviteTeamMemberBody === undefined) {
      throw new Error(
        'Required parameter inviteTeamMemberBody was null or undefined when calling inviteTeamMember.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        inviteTeamMemberBody,
        'InviteTeamMemberBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: InviteTeamMemberResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'InviteTeamMemberResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all API keys for an organization. It supports pagination to handle large sets of data.
   * @summary Lists all organization API keys
   * @param organizationId
   * @param ownerSupabaseAuthUserId
   * @param page
   * @param pageSize
   */
  public async listOrganizationApiKeys(
    organizationId: string,
    ownerSupabaseAuthUserId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListOrganizationApiKeysResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization-api-keys';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listOrganizationApiKeys.'
      );
    }

    // verify required parameter 'ownerSupabaseAuthUserId' is not null or undefined
    if (
      ownerSupabaseAuthUserId === null ||
      ownerSupabaseAuthUserId === undefined
    ) {
      throw new Error(
        'Required parameter ownerSupabaseAuthUserId was null or undefined when calling listOrganizationApiKeys.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (ownerSupabaseAuthUserId !== undefined) {
      localVarQueryParameters['ownerSupabaseAuthUserId'] =
        ObjectSerializer.serialize(ownerSupabaseAuthUserId, 'string');
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListOrganizationApiKeysResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListOrganizationApiKeysResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all audit logs for an organization. It supports pagination to handle large sets of data.
   * @summary Lists all organization audit logs
   * @param organizationId
   * @param ownerSupabaseAuthUserId
   * @param page
   * @param pageSize
   */
  public async listOrganizationAuditLogs(
    organizationId: string,
    ownerSupabaseAuthUserId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListOrganizationAuditLogsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization-audit-logs';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listOrganizationAuditLogs.'
      );
    }

    // verify required parameter 'ownerSupabaseAuthUserId' is not null or undefined
    if (
      ownerSupabaseAuthUserId === null ||
      ownerSupabaseAuthUserId === undefined
    ) {
      throw new Error(
        'Required parameter ownerSupabaseAuthUserId was null or undefined when calling listOrganizationAuditLogs.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (ownerSupabaseAuthUserId !== undefined) {
      localVarQueryParameters['ownerSupabaseAuthUserId'] =
        ObjectSerializer.serialize(ownerSupabaseAuthUserId, 'string');
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListOrganizationAuditLogsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListOrganizationAuditLogsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all members in an organization based on the provided organization ID.It supports pagination to handle large sets of data.
   * @summary Lists all members of an organization
   * @param organizationId
   * @param page
   * @param pageSize
   */
  public async listOrganizationMembers(
    organizationId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListOrganizationMembersResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization/{organizationId}/members'.replace(
        '{' + 'organizationId' + '}',
        encodeURIComponent(String(organizationId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listOrganizationMembers.'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListOrganizationMembersResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListOrganizationMembersResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all organizations in the system. It supports pagination to handle large sets of data.Each organization in the list includes details like name, description, and members.
   * @summary Lists all organizations
   * @param page
   * @param pageSize
   */
  public async listOrganizations(
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListOrganizationsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organizations';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListOrganizationsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListOrganizationsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all roles in the system. It supports pagination to handle large sets of data.Each role in the list includes details like name, type, and permissions.
   * @summary Lists all roles
   * @param page
   * @param pageSize
   * @param organizationId
   * @param tenantId
   */
  public async listRoles(
    page: number,
    pageSize: number,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListRolesResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/roles';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'page' is not null or undefined
    if (page === null || page === undefined) {
      throw new Error(
        'Required parameter page was null or undefined when calling listRoles.'
      );
    }

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling listRoles.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listRoles.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listRoles.'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListRolesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ListRolesResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all roles in a team based on the provided tenant ID and team ID.It supports pagination to handle large sets of data.
   * @summary Lists all roles from a team
   * @param tenantId
   * @param teamId
   * @param organizationId
   * @param page
   * @param pageSize
   */
  public async listRolesFromTenantTeam(
    tenantId: string,
    teamId: string,
    organizationId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListRolesFromTenantTeamResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/team/{teamId}/roles'
        .replace('{' + 'tenantId' + '}', encodeURIComponent(String(tenantId)))
        .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listRolesFromTenantTeam.'
      );
    }

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling listRolesFromTenantTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listRolesFromTenantTeam.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListRolesFromTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListRolesFromTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all team invites for a tenant based on the provided tenant ID.It supports pagination to handle large sets of data.
   * @summary Lists all team invites
   * @param tenantId Tenant identifier (required)
   * @param organizationId Organization identifier (required)
   * @param teamId Team identifier (required)
   * @param page Page number for pagination
   * @param pageSize Number of items per page
   */
  public async listTeamInvites(
    tenantId: string,
    organizationId: string,
    teamId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTeamInvitesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/team-invites'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTeamInvites.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listTeamInvites.'
      );
    }

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling listTeamInvites.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (teamId !== undefined) {
      localVarQueryParameters['teamId'] = ObjectSerializer.serialize(
        teamId,
        'string'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTeamInvitesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTeamInvitesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all API keys for a tenant. It supports pagination to handle large sets of data.
   * @summary Lists all tenant API keys
   * @param organizationId
   * @param tenantId
   * @param page
   * @param pageSize
   */
  public async listTenantApiKeys(
    organizationId: string,
    tenantId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTenantApiKeysResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant-api-keys';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listTenantApiKeys.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTenantApiKeys.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTenantApiKeysResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTenantApiKeysResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all audit logs for a tenant. It supports pagination to handle large sets of data.
   * @summary Lists all tenant audit logs
   * @param organizationId
   * @param tenantId
   * @param page
   * @param pageSize
   */
  public async listTenantAuditLogs(
    organizationId: string,
    tenantId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTenantAuditLogsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant-audit-logs';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listTenantAuditLogs.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTenantAuditLogs.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTenantAuditLogsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTenantAuditLogsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all members in a tenant based on the provided tenant ID.It supports pagination to handle large sets of data.
   * @summary Lists all members of a tenant
   * @param tenantId
   * @param organizationId
   * @param teamId
   * @param page
   * @param pageSize
   */
  public async listTenantTeamMembers(
    tenantId: string,
    organizationId: string,
    teamId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListTenantTeamMembersResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/team-members'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listTenantTeamMembers.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listTenantTeamMembers.'
      );
    }

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling listTenantTeamMembers.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (teamId !== undefined) {
      localVarQueryParameters['teamId'] = ObjectSerializer.serialize(
        teamId,
        'string'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTenantTeamMembersResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListTenantTeamMembersResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of all tenants in the system. It supports pagination to handle large sets of data.Each tenant in the list includes details like name, description, and members.
   * @summary Lists all tenants
   * @param organizationId
   * @param page
   * @param pageSize
   */
  public async listTenants(
    organizationId: string,
    page?: number,
    pageSize?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListTenantsResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/tenants';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling listTenants.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListTenantsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ListTenantsResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Handles secure password reset operations through webhook integration. Includes comprehensive security measures and validation.
   * @summary Process password reset via webhook
   * @param organizationId
   * @param tenantId
   * @param accountId
   * @param token
   */
  public async passwordResetWebhookV2(
    organizationId: string,
    tenantId: string,
    accountId?: string,
    token?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: PasswordResetWebhookV2Response;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/webhook/password-reset';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling passwordResetWebhookV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling passwordResetWebhookV2.'
      );
    }

    if (accountId !== undefined) {
      localVarQueryParameters['accountId'] = ObjectSerializer.serialize(
        accountId,
        'string'
      );
    }

    if (token !== undefined) {
      localVarQueryParameters['token'] = ObjectSerializer.serialize(
        token,
        'string'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PasswordResetWebhookV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'PasswordResetWebhookV2Response'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint performs a readiness check on the service
   * @summary readyness check
   */
  public async readynessCheck(
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ReadynessCheckResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/ready';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReadynessCheckResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ReadynessCheckResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint rejects an invitation for a member to join a tenant based on the provided tenant ID and member email.The rejection process ensures that the member is not associated with the tenant.
   * @summary Rejects a team member invitation
   * @param tenantId
   * @param rejectTeamMemberInvitationBody
   */
  public async rejectTeamMemberInvitation(
    tenantId: string,
    rejectTeamMemberInvitationBody: RejectTeamMemberInvitationBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RejectTeamMemberInvitationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/reject-teammember-invitation'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling rejectTeamMemberInvitation.'
      );
    }

    // verify required parameter 'rejectTeamMemberInvitationBody' is not null or undefined
    if (
      rejectTeamMemberInvitationBody === null ||
      rejectTeamMemberInvitationBody === undefined
    ) {
      throw new Error(
        'Required parameter rejectTeamMemberInvitationBody was null or undefined when calling rejectTeamMemberInvitation.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        rejectTeamMemberInvitationBody,
        'RejectTeamMemberInvitationBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RejectTeamMemberInvitationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RejectTeamMemberInvitationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint removes a member from an organization based on the provided organization ID and member ID.The removal process ensures that the member is properly disassociated from the organization.
   * @summary Removes a member from an organization
   * @param organizationId
   * @param ownerSupabaseAuthUserId
   * @param organizationMemberId
   */
  public async removeOrganizationMemberFromOrganization(
    organizationId: string,
    ownerSupabaseAuthUserId: string,
    organizationMemberId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RemoveOrganizationMemberFromOrganizationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization/{organizationId}/remove-member'.replace(
        '{' + 'organizationId' + '}',
        encodeURIComponent(String(organizationId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling removeOrganizationMemberFromOrganization.'
      );
    }

    // verify required parameter 'ownerSupabaseAuthUserId' is not null or undefined
    if (
      ownerSupabaseAuthUserId === null ||
      ownerSupabaseAuthUserId === undefined
    ) {
      throw new Error(
        'Required parameter ownerSupabaseAuthUserId was null or undefined when calling removeOrganizationMemberFromOrganization.'
      );
    }

    // verify required parameter 'organizationMemberId' is not null or undefined
    if (organizationMemberId === null || organizationMemberId === undefined) {
      throw new Error(
        'Required parameter organizationMemberId was null or undefined when calling removeOrganizationMemberFromOrganization.'
      );
    }

    if (ownerSupabaseAuthUserId !== undefined) {
      localVarQueryParameters['ownerSupabaseAuthUserId'] =
        ObjectSerializer.serialize(ownerSupabaseAuthUserId, 'string');
    }

    if (organizationMemberId !== undefined) {
      localVarQueryParameters['organizationMemberId'] =
        ObjectSerializer.serialize(organizationMemberId, 'string');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RemoveOrganizationMemberFromOrganizationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RemoveOrganizationMemberFromOrganizationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint removes a member from a tenant based on the provided tenant ID and member ID.The removal process ensures that the member is properly disassociated from the tenant.
   * @summary Removes a member from a tenant
   * @param tenantId
   * @param organizationId
   * @param tenantTeamId
   * @param tenantTeamMemberId
   */
  public async removeTenantTeamMember(
    tenantId: string,
    organizationId: string,
    tenantTeamId: string,
    tenantTeamMemberId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RemoveTenantTeamMemberResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/{tenantId}/remove-teammember'.replace(
        '{' + 'tenantId' + '}',
        encodeURIComponent(String(tenantId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling removeTenantTeamMember.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling removeTenantTeamMember.'
      );
    }

    // verify required parameter 'tenantTeamId' is not null or undefined
    if (tenantTeamId === null || tenantTeamId === undefined) {
      throw new Error(
        'Required parameter tenantTeamId was null or undefined when calling removeTenantTeamMember.'
      );
    }

    // verify required parameter 'tenantTeamMemberId' is not null or undefined
    if (tenantTeamMemberId === null || tenantTeamMemberId === undefined) {
      throw new Error(
        'Required parameter tenantTeamMemberId was null or undefined when calling removeTenantTeamMember.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantTeamId !== undefined) {
      localVarQueryParameters['tenantTeamId'] = ObjectSerializer.serialize(
        tenantTeamId,
        'string'
      );
    }

    if (tenantTeamMemberId !== undefined) {
      localVarQueryParameters['tenantTeamMemberId'] =
        ObjectSerializer.serialize(tenantTeamMemberId, 'string');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RemoveTenantTeamMemberResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RemoveTenantTeamMemberResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint removes a user from a team based on the provided team ID and user ID.The removal process ensures that the user is properly disassociated from the team.
   * @summary Removes a user from a team
   * @param teamId
   * @param adminSupabaseAuth0UserId
   * @param userSupabaseAuth0UserId
   * @param organizationId
   * @param tenantId
   * @param profileType  - PROFILE_TYPE_UNSPECIFIED: Default unspecified profile type.  - PROFILE_TYPE_USER: Individual user profile.  - PROFILE_TYPE_BUSINESS: Business profile.
   */
  public async removeUserFromTeam(
    teamId: string,
    adminSupabaseAuth0UserId: string,
    userSupabaseAuth0UserId: string,
    organizationId: string,
    tenantId: string,
    profileType?:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RemoveUserFromTeamResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/team/{teamId}/remove-user'.replace(
        '{' + 'teamId' + '}',
        encodeURIComponent(String(teamId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new Error(
        'Required parameter teamId was null or undefined when calling removeUserFromTeam.'
      );
    }

    // verify required parameter 'adminSupabaseAuth0UserId' is not null or undefined
    if (
      adminSupabaseAuth0UserId === null ||
      adminSupabaseAuth0UserId === undefined
    ) {
      throw new Error(
        'Required parameter adminSupabaseAuth0UserId was null or undefined when calling removeUserFromTeam.'
      );
    }

    // verify required parameter 'userSupabaseAuth0UserId' is not null or undefined
    if (
      userSupabaseAuth0UserId === null ||
      userSupabaseAuth0UserId === undefined
    ) {
      throw new Error(
        'Required parameter userSupabaseAuth0UserId was null or undefined when calling removeUserFromTeam.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling removeUserFromTeam.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling removeUserFromTeam.'
      );
    }

    if (adminSupabaseAuth0UserId !== undefined) {
      localVarQueryParameters['adminSupabaseAuth0UserId'] =
        ObjectSerializer.serialize(adminSupabaseAuth0UserId, 'string');
    }

    if (userSupabaseAuth0UserId !== undefined) {
      localVarQueryParameters['userSupabaseAuth0UserId'] =
        ObjectSerializer.serialize(userSupabaseAuth0UserId, 'string');
    }

    if (profileType !== undefined) {
      localVarQueryParameters['profileType'] = ObjectSerializer.serialize(
        profileType,
        "'PROFILE_TYPE_UNSPECIFIED' | 'PROFILE_TYPE_USER' | 'PROFILE_TYPE_BUSINESS'"
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RemoveUserFromTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RemoveUserFromTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Fetches business-specific account settings with authorization validation. Provides comprehensive configuration data for business accounts.
   * @summary Retrieve business account settings
   * @param userId The account ID associated with the user (business)
   * @param organizationId
   * @param tenantId
   */
  public async retrieveBusinessSettings(
    userId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetBusinessSettingsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/business/settings/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling retrieveBusinessSettings.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling retrieveBusinessSettings.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling retrieveBusinessSettings.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetBusinessSettingsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetBusinessSettingsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint rotates (replaces) an existing API key with a new one. The old key is invalidated, and a new key is generated with the same permissions and settings.
   * @summary Rotates an API key
   * @param keyId The unique identifier of the API key to rotate
   * @param organizationId
   * @param tenantId
   */
  public async rotateOrgAPIKey(
    keyId: string,
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: RotateOrgAPIKeyResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/api-keys/{keyId}/rotate'.replace(
        '{' + 'keyId' + '}',
        encodeURIComponent(String(keyId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'keyId' is not null or undefined
    if (keyId === null || keyId === undefined) {
      throw new Error(
        'Required parameter keyId was null or undefined when calling rotateOrgAPIKey.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling rotateOrgAPIKey.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling rotateOrgAPIKey.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: RotateOrgAPIKeyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'RotateOrgAPIKeyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates the details of an existing organization. The organization ID is used to identify the organization to be updated.The update operation can modify the organization\'s name, description, and members.
   * @summary Updates an existing organization
   * @param organization
   */
  public async updateOrganization(
    organization: Organization,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateOrganizationResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/organization';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'organization' is not null or undefined
    if (organization === null || organization === undefined) {
      throw new Error(
        'Required parameter organization was null or undefined when calling updateOrganization.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(organization, 'Organization'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateOrganizationResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateOrganizationResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates the details of an existing role. The role ID is used to identify the role to be updated.The update operation can modify the role\'s name, type, and permissions.
   * @summary Updates an existing role
   * @param role
   */
  public async updateRole(
    role: Role,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateRoleResponse }> {
    const localVarPath = this.basePath + '/user-microservice/api/v2/user/role';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        'Required parameter role was null or undefined when calling updateRole.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(role, 'Role'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateRoleResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateRoleResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates the details of an existing team. The team ID is used to identify the team to be updated.The update operation can modify the team\'s name, description, and members.
   * @summary Updates an existing team
   * @param team
   */
  public async updateTeam(
    team: Team,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateTeamResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/team';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'team' is not null or undefined
    if (team === null || team === undefined) {
      throw new Error(
        'Required parameter team was null or undefined when calling updateTeam.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(team, 'Team'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateTeamResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates the details of an existing tenant. The tenant ID is used to identify the tenant to be updated.The update operation can modify the tenant\'s name, description, and members.
   * @summary Updates an existing tenant
   * @param updateTenantRequest
   */
  public async updateTenant(
    updateTenantRequest: UpdateTenantRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateTenantResponse }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/tenant';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateTenantRequest' is not null or undefined
    if (updateTenantRequest === null || updateTenantRequest === undefined) {
      throw new Error(
        'Required parameter updateTenantRequest was null or undefined when calling updateTenant.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateTenantRequest,
        'UpdateTenantRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateTenantResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateTenantResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates the details of an existing team. The team ID is used to identify the team to be updated.The update operation can modify the team\'s name, description, and members.
   * @summary Updates an existing team
   * @param team
   */
  public async updateTenantTeam(
    team: Team,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateTenantTeamResponse;
  }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user/tenant-team';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'team' is not null or undefined
    if (team === null || team === undefined) {
      throw new Error(
        'Required parameter team was null or undefined when calling updateTenantTeam.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(team, 'Team'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateTenantTeamResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateTenantTeamResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates the details of an existing team member. The tenant ID and member ID are used to identify the member to be updated.The update operation can modify the member\'s role, permissions, and status.
   * @summary Updates a team member
   * @param updateTenantTeamMemberRequest
   */
  public async updateTenantTeamMember(
    updateTenantTeamMemberRequest: UpdateTenantTeamMemberRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateTenantTeamMemberResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/tenant/team-member';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateTenantTeamMemberRequest' is not null or undefined
    if (
      updateTenantTeamMemberRequest === null ||
      updateTenantTeamMemberRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateTenantTeamMemberRequest was null or undefined when calling updateTenantTeamMember.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateTenantTeamMemberRequest,
        'UpdateTenantTeamMemberRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateTenantTeamMemberResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateTenantTeamMemberResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Performs comprehensive updates to user account information with multi-service coordination. Ensures data consistency and atomic updates across all affected services. Includes validation, authorization, and audit logging.
   * @summary Update user account information
   * @param updateUserV2Request
   */
  public async updateUserV2(
    updateUserV2Request: UpdateUserV2Request,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateUserV2Response }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/user';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateUserV2Request' is not null or undefined
    if (updateUserV2Request === null || updateUserV2Request === undefined) {
      throw new Error(
        'Required parameter updateUserV2Request was null or undefined when calling updateUserV2.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateUserV2Request,
        'UpdateUserV2Request'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateUserV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateUserV2Response');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint verifies the validity of an API key. It checks if the key exists, is not expired, and has not been revoked.
   * @summary Verifies an API key
   * @param verifyOrgAPIKeyRequest
   */
  public async verifyOrgAPIKey(
    verifyOrgAPIKeyRequest: VerifyOrgAPIKeyRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: VerifyOrgAPIKeyResponse;
  }> {
    const localVarPath =
      this.basePath + '/user-microservice/api/v2/user-service/api-keys/verify';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'verifyOrgAPIKeyRequest' is not null or undefined
    if (
      verifyOrgAPIKeyRequest === null ||
      verifyOrgAPIKeyRequest === undefined
    ) {
      throw new Error(
        'Required parameter verifyOrgAPIKeyRequest was null or undefined when calling verifyOrgAPIKey.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        verifyOrgAPIKeyRequest,
        'VerifyOrgAPIKeyRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: VerifyOrgAPIKeyResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'VerifyOrgAPIKeyResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Handles email verification process with security token validation. Updates account status and manages verification state.
   * @summary Verify user email address
   * @param userId The account ID associated with the user
   * @param profileType The profile type of the user
   * @param organizationId
   * @param tenantId
   */
  public async verifyUserV2(
    userId: string,
    profileType:
      | 'PROFILE_TYPE_UNSPECIFIED'
      | 'PROFILE_TYPE_USER'
      | 'PROFILE_TYPE_BUSINESS',
    organizationId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: VerifyUserV2Response }> {
    const localVarPath =
      this.basePath +
      '/user-microservice/api/v2/user-service/user/verification/{userId}/profile-type/{profileType}'
        .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
        .replace(
          '{' + 'profileType' + '}',
          encodeURIComponent(String(profileType))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling verifyUserV2.'
      );
    }

    // verify required parameter 'profileType' is not null or undefined
    if (profileType === null || profileType === undefined) {
      throw new Error(
        'Required parameter profileType was null or undefined when calling verifyUserV2.'
      );
    }

    // verify required parameter 'organizationId' is not null or undefined
    if (organizationId === null || organizationId === undefined) {
      throw new Error(
        'Required parameter organizationId was null or undefined when calling verifyUserV2.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling verifyUserV2.'
      );
    }

    if (organizationId !== undefined) {
      localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(
        organizationId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: VerifyUserV2Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'VerifyUserV2Response');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
