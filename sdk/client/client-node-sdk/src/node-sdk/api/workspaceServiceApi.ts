/**
 * User Service API
 * Solomon AI User Service API - Manages user profiles and authentication
 *
 * The version of the OpenAPI document: 1.0
 * Contact: yoanyomba@solomon-ai.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AuthenticationErrorMessageResponse } from '../model/authenticationErrorMessageResponse';
import { BadGatewayErrorMessageResponse } from '../model/badGatewayErrorMessageResponse';
import { BulkUpdateCommentsRequest } from '../model/bulkUpdateCommentsRequest';
import { BulkUpdateCommentsResponse } from '../model/bulkUpdateCommentsResponse';
import { ConflictErrorMessageResponse } from '../model/conflictErrorMessageResponse';
import { CreateAccountRequest } from '../model/createAccountRequest';
import { CreateAccountResponse } from '../model/createAccountResponse';
import { CreateCommentEditBody } from '../model/createCommentEditBody';
import { CreateCommentEditResponse } from '../model/createCommentEditResponse';
import { CreateCommentRequest } from '../model/createCommentRequest';
import { CreateCommentResponse1 } from '../model/createCommentResponse1';
import { CreateCommentThreadRequest } from '../model/createCommentThreadRequest';
import { CreateCommentThreadResponse } from '../model/createCommentThreadResponse';
import { CreateDocumentSnapshotBody } from '../model/createDocumentSnapshotBody';
import { CreateDocumentSnapshotResponse } from '../model/createDocumentSnapshotResponse';
import { CreateFolderRequest } from '../model/createFolderRequest';
import { CreateFolderResponse } from '../model/createFolderResponse';
import { CreateMarkdownFileRequest } from '../model/createMarkdownFileRequest';
import { CreateMarkdownFileResponse } from '../model/createMarkdownFileResponse';
import { CreateWorkspaceComplianceBody } from '../model/createWorkspaceComplianceBody';
import { CreateWorkspaceComplianceResponse } from '../model/createWorkspaceComplianceResponse';
import { CreateWorkspaceRequest } from '../model/createWorkspaceRequest';
import { CreateWorkspaceResponse } from '../model/createWorkspaceResponse';
import { DeleteAccountResponse } from '../model/deleteAccountResponse';
import { DeleteCommentEditResponse } from '../model/deleteCommentEditResponse';
import { DeleteCommentResponse1 } from '../model/deleteCommentResponse1';
import { DeleteCommentThreadResponse } from '../model/deleteCommentThreadResponse';
import { DeleteDocumentSnapshotResponse } from '../model/deleteDocumentSnapshotResponse';
import { DeleteFileResponse } from '../model/deleteFileResponse';
import { DeleteFolderResponse } from '../model/deleteFolderResponse';
import { DeleteWorkspaceComplianceResponse } from '../model/deleteWorkspaceComplianceResponse';
import { DeleteWorkspaceResponse } from '../model/deleteWorkspaceResponse';
import { DeleteWorkspaceShareResponse } from '../model/deleteWorkspaceShareResponse';
import { ForbiddenErrorMessageResponse } from '../model/forbiddenErrorMessageResponse';
import { GatewayTimeoutErrorMessageResponse } from '../model/gatewayTimeoutErrorMessageResponse';
import { GenerateFileEmbeddingsBody } from '../model/generateFileEmbeddingsBody';
import { GenerateFileEmbeddingsResponse } from '../model/generateFileEmbeddingsResponse';
import { GetAccountResponse } from '../model/getAccountResponse';
import { GetBackgroundJobStatusResponse } from '../model/getBackgroundJobStatusResponse';
import { GetCommentEditResponse } from '../model/getCommentEditResponse';
import { GetCommentResponse } from '../model/getCommentResponse';
import { GetCommentThreadResponse } from '../model/getCommentThreadResponse';
import { GetDocumentSnapshotResponse } from '../model/getDocumentSnapshotResponse';
import { GetFileVersionResponse } from '../model/getFileVersionResponse';
import { GetSingleCommentThreadResponse } from '../model/getSingleCommentThreadResponse';
import { GetWorkspaceComplianceResponse } from '../model/getWorkspaceComplianceResponse';
import { GetWorkspaceShareResponse } from '../model/getWorkspaceShareResponse';
import { GoneErrorMessageResponse } from '../model/goneErrorMessageResponse';
import { InternalErrorMessageResponse } from '../model/internalErrorMessageResponse';
import { ListAccountsResponse } from '../model/listAccountsResponse';
import { ListCommentEditsResponse } from '../model/listCommentEditsResponse';
import { ListCommentsResponse } from '../model/listCommentsResponse';
import { ListDocumentSnapshotsResponse } from '../model/listDocumentSnapshotsResponse';
import { ListFileVersionsResponse } from '../model/listFileVersionsResponse';
import { ListFilesResponse } from '../model/listFilesResponse';
import { ListFolderResponse } from '../model/listFolderResponse';
import { ListWorkspaceActivityResponse } from '../model/listWorkspaceActivityResponse';
import { ListWorkspaceResponse } from '../model/listWorkspaceResponse';
import { ListWorkspaceSharesResponse } from '../model/listWorkspaceSharesResponse';
import { MethodNotAllowedErrorMessageResponse } from '../model/methodNotAllowedErrorMessageResponse';
import { NotFoundErrorMessageResponse } from '../model/notFoundErrorMessageResponse';
import { NotImplementedErrorMessageResponse } from '../model/notImplementedErrorMessageResponse';
import { PaymentRequiredErrorMessageResponse } from '../model/paymentRequiredErrorMessageResponse';
import { PreconditionFailedErrorMessageResponse } from '../model/preconditionFailedErrorMessageResponse';
import { RateLimitErrorMessageResponse } from '../model/rateLimitErrorMessageResponse';
import { ServiceUnavailableErrorMessageResponse } from '../model/serviceUnavailableErrorMessageResponse';
import { ShareFileBody } from '../model/shareFileBody';
import { ShareFileResponse } from '../model/shareFileResponse';
import { ShareWorkspaceBody } from '../model/shareWorkspaceBody';
import { ShareWorkspaceResponse } from '../model/shareWorkspaceResponse';
import { Status } from '../model/status';
import { TooEarlyErrorMessageResponse } from '../model/tooEarlyErrorMessageResponse';
import { UnprocessableEntityErrorMessageResponse } from '../model/unprocessableEntityErrorMessageResponse';
import { UnshareFileResponse } from '../model/unshareFileResponse';
import { UpdateCommentEditRequest } from '../model/updateCommentEditRequest';
import { UpdateCommentEditResponse } from '../model/updateCommentEditResponse';
import { UpdateCommentRequest } from '../model/updateCommentRequest';
import { UpdateCommentResponse } from '../model/updateCommentResponse';
import { UpdateCommentThreadRequest } from '../model/updateCommentThreadRequest';
import { UpdateCommentThreadResponse } from '../model/updateCommentThreadResponse';
import { UpdateFileRequest } from '../model/updateFileRequest';
import { UpdateFileResponse } from '../model/updateFileResponse';
import { UpdateFolderRequest } from '../model/updateFolderRequest';
import { UpdateFolderResponse } from '../model/updateFolderResponse';
import { UpdateWorkspaceComplianceRequest } from '../model/updateWorkspaceComplianceRequest';
import { UpdateWorkspaceComplianceResponse } from '../model/updateWorkspaceComplianceResponse';
import { UpdateWorkspaceRequest } from '../model/updateWorkspaceRequest';
import { UpdateWorkspaceResponse } from '../model/updateWorkspaceResponse';
import { UpdateWorkspaceShareRequest } from '../model/updateWorkspaceShareRequest';
import { UpdateWorkspaceShareResponse } from '../model/updateWorkspaceShareResponse';
import { ValidationErrorMessageResponse } from '../model/validationErrorMessageResponse';

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from '../model/models';
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://user-service.platform.svc.cluster.local:9896';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum WorkspaceServiceApiApiKeys {
  ApiKeyAuth,
  Bearer,
}

export class WorkspaceServiceApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    ApiKeyAuth: new ApiKeyAuth('header', 'X-API-Key'),
    Bearer: new ApiKeyAuth('header', 'Authorization'),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: WorkspaceServiceApiApiKeys, value: string) {
    (this.authentications as any)[WorkspaceServiceApiApiKeys[key]].apiKey =
      value;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * This endpoint updates multiple comments in bulk
   * @summary Bulk update comments
   * @param bulkUpdateCommentsRequest BulkUpdateCommentsRequest represents a request to update multiple comments.
   */
  public async bulkUpdateComments(
    bulkUpdateCommentsRequest: BulkUpdateCommentsRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BulkUpdateCommentsResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comments/bulk-update';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'bulkUpdateCommentsRequest' is not null or undefined
    if (
      bulkUpdateCommentsRequest === null ||
      bulkUpdateCommentsRequest === undefined
    ) {
      throw new Error(
        'Required parameter bulkUpdateCommentsRequest was null or undefined when calling bulkUpdateComments.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        bulkUpdateCommentsRequest,
        'BulkUpdateCommentsRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BulkUpdateCommentsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'BulkUpdateCommentsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new user account
   * @summary Create a new account
   * @param createAccountRequest CreateAccountRequest represents a request to create a new user account in the system. This message contains all necessary information to establish a new user account within a specific organization and tenant context.
   */
  public async createAccount(
    createAccountRequest: CreateAccountRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateAccountResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/accounts';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createAccountRequest' is not null or undefined
    if (createAccountRequest === null || createAccountRequest === undefined) {
      throw new Error(
        'Required parameter createAccountRequest was null or undefined when calling createAccount.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createAccountRequest,
        'CreateAccountRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new comment in a thread
   * @summary Create a comment
   * @param createCommentRequest
   */
  public async createComment1(
    createCommentRequest: CreateCommentRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateCommentResponse1 }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comments';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createCommentRequest' is not null or undefined
    if (createCommentRequest === null || createCommentRequest === undefined) {
      throw new Error(
        'Required parameter createCommentRequest was null or undefined when calling createComment1.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createCommentRequest,
        'CreateCommentRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommentResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommentResponse1'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new edit for a comment
   * @summary Create a comment edit
   * @param commentId comment_id identifies the comment being edited
   * @param createCommentEditBody
   */
  public async createCommentEdit(
    commentId: string,
    createCommentEditBody: CreateCommentEditBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateCommentEditResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comments/{commentId}/edits'.replace(
        '{' + 'commentId' + '}',
        encodeURIComponent(String(commentId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling createCommentEdit.'
      );
    }

    // verify required parameter 'createCommentEditBody' is not null or undefined
    if (createCommentEditBody === null || createCommentEditBody === undefined) {
      throw new Error(
        'Required parameter createCommentEditBody was null or undefined when calling createCommentEdit.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createCommentEditBody,
        'CreateCommentEditBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommentEditResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommentEditResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new comment thread on a file
   * @summary Create a comment thread
   * @param createCommentThreadRequest CreateCommentThreadRequest represents a request to create a new comment thread.
   */
  public async createCommentThread(
    createCommentThreadRequest: CreateCommentThreadRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateCommentThreadResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comment-threads';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createCommentThreadRequest' is not null or undefined
    if (
      createCommentThreadRequest === null ||
      createCommentThreadRequest === undefined
    ) {
      throw new Error(
        'Required parameter createCommentThreadRequest was null or undefined when calling createCommentThread.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createCommentThreadRequest,
        'CreateCommentThreadRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateCommentThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateCommentThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new snapshot of a document\'s content
   * @summary Create a document snapshot
   * @param fileId file_id identifies the file to snapshot
   * @param createDocumentSnapshotBody
   */
  public async createDocumentSnapshot(
    fileId: string,
    createDocumentSnapshotBody: CreateDocumentSnapshotBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateDocumentSnapshotResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/snapshots'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling createDocumentSnapshot.'
      );
    }

    // verify required parameter 'createDocumentSnapshotBody' is not null or undefined
    if (
      createDocumentSnapshotBody === null ||
      createDocumentSnapshotBody === undefined
    ) {
      throw new Error(
        'Required parameter createDocumentSnapshotBody was null or undefined when calling createDocumentSnapshot.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createDocumentSnapshotBody,
        'CreateDocumentSnapshotBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateDocumentSnapshotResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateDocumentSnapshotResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new folder
   * @summary Create a folder
   * @param createFolderRequest CreateFolderRequest represents a request to create a new folder within a workspace. This message contains all necessary information to establish a new folder structure while maintaining proper access controls and organizational hierarchy.  Key features: - User authentication and authorization - Workspace organization - Folder naming and validation - Multi-tenant support - Organization context
   */
  public async createFolder(
    createFolderRequest: CreateFolderRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CreateFolderResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/folders';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createFolderRequest' is not null or undefined
    if (createFolderRequest === null || createFolderRequest === undefined) {
      throw new Error(
        'Required parameter createFolderRequest was null or undefined when calling createFolder.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createFolderRequest,
        'CreateFolderRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateFolderResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CreateFolderResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new file
   * @summary Create a markdown file
   * @param createMarkdownFileRequest CreateMarkdownFileRequest represents a request to create a new Markdown file in the workspace. This message contains all necessary information to create and store a Markdown file, including content, location details, and organizational context.
   */
  public async createMarkdownFile(
    createMarkdownFileRequest: CreateMarkdownFileRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateMarkdownFileResponse;
  }> {
    const localVarPath = this.basePath + '/workspace-microservice/api/v1/files';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createMarkdownFileRequest' is not null or undefined
    if (
      createMarkdownFileRequest === null ||
      createMarkdownFileRequest === undefined
    ) {
      throw new Error(
        'Required parameter createMarkdownFileRequest was null or undefined when calling createMarkdownFile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createMarkdownFileRequest,
        'CreateMarkdownFileRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateMarkdownFileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateMarkdownFileResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates a new workspace
   * @summary Create a workspace
   * @param createWorkspaceRequest CreateWorkspaceRequest represents a request to create a new workspace in the system. This message contains all necessary information to establish a new workspace within a specific organization and tenant context.  Key features: - User identification and authorization - Workspace naming and configuration - Multi-tenant support - Organization scoping
   */
  public async createWorkspace(
    createWorkspaceRequest: CreateWorkspaceRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateWorkspaceResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/workspaces';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createWorkspaceRequest' is not null or undefined
    if (
      createWorkspaceRequest === null ||
      createWorkspaceRequest === undefined
    ) {
      throw new Error(
        'Required parameter createWorkspaceRequest was null or undefined when calling createWorkspace.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createWorkspaceRequest,
        'CreateWorkspaceRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateWorkspaceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateWorkspaceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint creates compliance settings for a workspace
   * @summary Create workspace compliance settings
   * @param workspaceId workspace_id identifies the workspace
   * @param createWorkspaceComplianceBody
   */
  public async createWorkspaceCompliance(
    workspaceId: string,
    createWorkspaceComplianceBody: CreateWorkspaceComplianceBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateWorkspaceComplianceResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/compliance'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling createWorkspaceCompliance.'
      );
    }

    // verify required parameter 'createWorkspaceComplianceBody' is not null or undefined
    if (
      createWorkspaceComplianceBody === null ||
      createWorkspaceComplianceBody === undefined
    ) {
      throw new Error(
        'Required parameter createWorkspaceComplianceBody was null or undefined when calling createWorkspaceCompliance.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createWorkspaceComplianceBody,
        'CreateWorkspaceComplianceBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateWorkspaceComplianceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CreateWorkspaceComplianceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes an account by ID
   * @summary Delete an account
   * @param userId user_id uniquely identifies the account to be deleted Must be a non-empty string matching the authentication system\&#39;s user ID
   * @param orgId org_id identifies the organization context for the account deletion Must be a valid organization identifier to ensure deletion occurs in correct scope
   * @param tenantId tenant_id identifies the tenant context for multi-tenant deployments Must be a valid tenant identifier to ensure deletion occurs in correct tenant
   */
  public async deleteAccount(
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteAccountResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/accounts/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteAccount.'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteAccountResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a specific comment
   * @summary Delete a comment
   * @param commentId
   * @param userId
   * @param workspaceId
   * @param folderId
   * @param fileId
   * @param threadId
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async deleteComment1(
    commentId: string,
    userId: string,
    workspaceId: string,
    folderId: string,
    fileId: string,
    threadId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteCommentResponse1 }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comments/{commentId}'.replace(
        '{' + 'commentId' + '}',
        encodeURIComponent(String(commentId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'threadId' is not null or undefined
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteComment1.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteComment1.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (folderId !== undefined) {
      localVarQueryParameters['folderId'] = ObjectSerializer.serialize(
        folderId,
        'string'
      );
    }

    if (fileId !== undefined) {
      localVarQueryParameters['fileId'] = ObjectSerializer.serialize(
        fileId,
        'string'
      );
    }

    if (threadId !== undefined) {
      localVarQueryParameters['threadId'] = ObjectSerializer.serialize(
        threadId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteCommentResponse1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteCommentResponse1'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a specific comment edit
   * @summary Delete a comment edit
   * @param commentId
   * @param editId
   * @param userId
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async deleteCommentEdit(
    commentId: string,
    editId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteCommentEditResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comments/{commentId}/edits/{editId}'
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace('{' + 'editId' + '}', encodeURIComponent(String(editId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling deleteCommentEdit.'
      );
    }

    // verify required parameter 'editId' is not null or undefined
    if (editId === null || editId === undefined) {
      throw new Error(
        'Required parameter editId was null or undefined when calling deleteCommentEdit.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteCommentEdit.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteCommentEdit.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteCommentEdit.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteCommentEditResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteCommentEditResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a comment thread and all its associated comments
   * @summary Delete a comment thread
   * @param threadId thread_id identifies the comment thread to delete
   * @param userId user_id identifies the user deleting the thread Must be authenticated and authorized to delete the thread
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param hardDelete Optional: Force delete even if thread has replies
   */
  public async deleteCommentThread(
    threadId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    hardDelete?: boolean,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteCommentThreadResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comment-threads/{threadId}'.replace(
        '{' + 'threadId' + '}',
        encodeURIComponent(String(threadId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'threadId' is not null or undefined
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling deleteCommentThread.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteCommentThread.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteCommentThread.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteCommentThread.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (hardDelete !== undefined) {
      localVarQueryParameters['hardDelete'] = ObjectSerializer.serialize(
        hardDelete,
        'boolean'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteCommentThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteCommentThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a specific document snapshot
   * @summary Delete a document snapshot
   * @param fileId file_id identifies the file
   * @param snapshotId snapshot_id identifies the specific snapshot to delete
   * @param userId user_id identifies the user deleting the snapshot
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async deleteDocumentSnapshot(
    fileId: string,
    snapshotId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteDocumentSnapshotResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/snapshots/{snapshotId}'
        .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)))
        .replace(
          '{' + 'snapshotId' + '}',
          encodeURIComponent(String(snapshotId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling deleteDocumentSnapshot.'
      );
    }

    // verify required parameter 'snapshotId' is not null or undefined
    if (snapshotId === null || snapshotId === undefined) {
      throw new Error(
        'Required parameter snapshotId was null or undefined when calling deleteDocumentSnapshot.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteDocumentSnapshot.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteDocumentSnapshot.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteDocumentSnapshot.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteDocumentSnapshotResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteDocumentSnapshotResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a file by ID
   * @summary Delete a file
   * @param fileId file_id uniquely identifies the file to be deleted Must reference an existing file in the system
   * @param userId user_id identifies the user requesting the file deletion Must be authenticated and authorized to delete the file
   * @param folderId folder_id identifies the folder containing the file Used for hierarchical organization and access control
   * @param workspaceId workspace_id identifies the workspace context for the file deletion Must be a valid workspace identifier where the file is located
   * @param orgId org_id identifies the organization context for the file deletion Must be a valid organization identifier to ensure proper scoping
   * @param tenantId tenant_id identifies the tenant context for multi-tenant deployments Required to ensure proper isolation between different tenants
   */
  public async deleteFile(
    fileId: string,
    userId: string,
    folderId: string,
    workspaceId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteFileResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling deleteFile.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteFile.'
      );
    }

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling deleteFile.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling deleteFile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteFile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteFile.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (folderId !== undefined) {
      localVarQueryParameters['folderId'] = ObjectSerializer.serialize(
        folderId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteFileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteFileResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a folder by ID
   * @summary Delete a folder
   * @param folderId folder_id uniquely identifies the folder to be deleted Must reference an existing folder in the system
   * @param userId user_id identifies the user requesting the folder deletion Must be authenticated and authorized to delete the folder
   * @param workspaceId workspace_id identifies the workspace context for the folder deletion Must be a valid workspace identifier where the folder is located
   * @param orgId org_id identifies the organization context for the folder deletion Must be a valid organization identifier to ensure proper scoping
   * @param tenantId tenant_id identifies the tenant context for multi-tenant deployments Required to ensure proper isolation between different tenants
   */
  public async deleteFolder(
    folderId: string,
    userId: string,
    workspaceId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: DeleteFolderResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/folders/{folderId}'.replace(
        '{' + 'folderId' + '}',
        encodeURIComponent(String(folderId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling deleteFolder.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteFolder.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling deleteFolder.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteFolder.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteFolder.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteFolderResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'DeleteFolderResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes a workspace by ID
   * @summary Delete a workspace
   * @param workspaceId workspace_id uniquely identifies the workspace to be deleted Must reference an existing workspace in the system
   * @param userId user_id identifies the user requesting the workspace deletion Must be authenticated and authorized to delete the workspace
   * @param orgId org_id identifies the organization context for the workspace deletion Must be a valid organization identifier to ensure proper scoping
   * @param tenantId tenant_id identifies the tenant context for multi-tenant deployments Required to ensure proper isolation between different tenants
   */
  public async deleteWorkspace(
    workspaceId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteWorkspaceResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling deleteWorkspace.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteWorkspace.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteWorkspace.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteWorkspace.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteWorkspaceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteWorkspaceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint deletes compliance settings for a workspace
   * @summary Delete workspace compliance settings
   * @param workspaceId workspace_id identifies the workspace
   * @param userId user_id identifies the user deleting the compliance settings
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async deleteWorkspaceCompliance(
    workspaceId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteWorkspaceComplianceResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/compliance'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling deleteWorkspaceCompliance.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteWorkspaceCompliance.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteWorkspaceCompliance.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteWorkspaceCompliance.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteWorkspaceComplianceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteWorkspaceComplianceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint removes a share from a workspace
   * @summary Delete a workspace share
   * @param workspaceId workspace_id identifies the workspace
   * @param shareId share_id identifies the specific share to delete
   * @param userId user_id identifies the user deleting the share
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async deleteWorkspaceShare(
    workspaceId: string,
    shareId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteWorkspaceShareResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/shares/{shareId}'
        .replace(
          '{' + 'workspaceId' + '}',
          encodeURIComponent(String(workspaceId))
        )
        .replace('{' + 'shareId' + '}', encodeURIComponent(String(shareId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling deleteWorkspaceShare.'
      );
    }

    // verify required parameter 'shareId' is not null or undefined
    if (shareId === null || shareId === undefined) {
      throw new Error(
        'Required parameter shareId was null or undefined when calling deleteWorkspaceShare.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteWorkspaceShare.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling deleteWorkspaceShare.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling deleteWorkspaceShare.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteWorkspaceShareResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'DeleteWorkspaceShareResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint triggers the generation of embeddings for the current state of a file
   * @summary Generate file embeddings
   * @param fileId file_id identifies the file to generate embeddings for
   * @param generateFileEmbeddingsBody
   */
  public async generateFileEmbeddings(
    fileId: string,
    generateFileEmbeddingsBody: GenerateFileEmbeddingsBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GenerateFileEmbeddingsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/embeddings'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling generateFileEmbeddings.'
      );
    }

    // verify required parameter 'generateFileEmbeddingsBody' is not null or undefined
    if (
      generateFileEmbeddingsBody === null ||
      generateFileEmbeddingsBody === undefined
    ) {
      throw new Error(
        'Required parameter generateFileEmbeddingsBody was null or undefined when calling generateFileEmbeddings.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        generateFileEmbeddingsBody,
        'GenerateFileEmbeddingsBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GenerateFileEmbeddingsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GenerateFileEmbeddingsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves account details by ID
   * @summary Get account by ID
   * @param userId user_id uniquely identifies the user whose account information is being requested Must be a non-empty string, typically matching the authentication system\&#39;s user ID
   * @param orgId org_id identifies the organization context for the account lookup Must be a valid organization identifier
   * @param tenantId tenant_id identifies the tenant context for multi-tenant deployments Must be a valid tenant identifier
   * @param createIfNotExists create_if_not_exists determines whether to create a new account if one doesn\&#39;t exist If true, a new account will be created with default settings when no matching account is found
   * @param email email is the user\&#39;s email address, used as an alternative lookup method Must be a valid email format if provided
   * @param includeMetadata include_metadata determines whether to include the account\&#39;s metadata in the response When true, all custom fields and extended properties will be returned
   * @param includePermissions include_permissions determines whether to include the user\&#39;s permissions in the response When true, returns the complete permission set associated with the account
   */
  public async getAccount(
    userId: string,
    orgId: string,
    tenantId: string,
    createIfNotExists?: boolean,
    email?: string,
    includeMetadata?: boolean,
    includePermissions?: boolean,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetAccountResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/accounts/{userId}'.replace(
        '{' + 'userId' + '}',
        encodeURIComponent(String(userId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getAccount.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getAccount.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getAccount.'
      );
    }

    if (createIfNotExists !== undefined) {
      localVarQueryParameters['createIfNotExists'] = ObjectSerializer.serialize(
        createIfNotExists,
        'boolean'
      );
    }

    if (email !== undefined) {
      localVarQueryParameters['email'] = ObjectSerializer.serialize(
        email,
        'string'
      );
    }

    if (includeMetadata !== undefined) {
      localVarQueryParameters['includeMetadata'] = ObjectSerializer.serialize(
        includeMetadata,
        'boolean'
      );
    }

    if (includePermissions !== undefined) {
      localVarQueryParameters['includePermissions'] =
        ObjectSerializer.serialize(includePermissions, 'boolean');
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAccountResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetAccountResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves the status of a background job like embedding generation
   * @summary Get background job status
   * @param jobId job_id identifies the specific background job
   * @param userId user_id identifies the user requesting the job status
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getBackgroundJobStatus(
    jobId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetBackgroundJobStatusResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/jobs/{jobId}/status'.replace(
        '{' + 'jobId' + '}',
        encodeURIComponent(String(jobId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'jobId' is not null or undefined
    if (jobId === null || jobId === undefined) {
      throw new Error(
        'Required parameter jobId was null or undefined when calling getBackgroundJobStatus.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getBackgroundJobStatus.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getBackgroundJobStatus.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getBackgroundJobStatus.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetBackgroundJobStatusResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetBackgroundJobStatusResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a specific comment by its ID
   * @summary Get a comment
   * @param commentId comment_id identifies the comment to retrieve
   * @param userId user_id identifies the user requesting the comment Must be authenticated and authorized to view the comment
   * @param workspaceId
   * @param folderId
   * @param fileId
   * @param threadId
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getComment(
    commentId: string,
    userId: string,
    workspaceId: string,
    folderId: string,
    fileId: string,
    threadId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetCommentResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comments/{commentId}'.replace(
        '{' + 'commentId' + '}',
        encodeURIComponent(String(commentId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'threadId' is not null or undefined
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getComment.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getComment.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (folderId !== undefined) {
      localVarQueryParameters['folderId'] = ObjectSerializer.serialize(
        folderId,
        'string'
      );
    }

    if (fileId !== undefined) {
      localVarQueryParameters['fileId'] = ObjectSerializer.serialize(
        fileId,
        'string'
      );
    }

    if (threadId !== undefined) {
      localVarQueryParameters['threadId'] = ObjectSerializer.serialize(
        threadId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommentResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'GetCommentResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a specific comment edit
   * @summary Get a comment edit
   * @param commentId
   * @param editId
   * @param userId
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getCommentEdit(
    commentId: string,
    editId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetCommentEditResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comments/{commentId}/edits/{editId}'
        .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)))
        .replace('{' + 'editId' + '}', encodeURIComponent(String(editId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling getCommentEdit.'
      );
    }

    // verify required parameter 'editId' is not null or undefined
    if (editId === null || editId === undefined) {
      throw new Error(
        'Required parameter editId was null or undefined when calling getCommentEdit.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommentEdit.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommentEdit.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommentEdit.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommentEditResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommentEditResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a specific comment thread and its comments
   * @summary Get a comment thread
   * @param fileId thread_id identifies the comment thread to retrieve
   * @param userId user_id identifies the user requesting the thread Must be authenticated and authorized to view the thread
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param pageSize
   * @param pageNumber
   */
  public async getCommentThread(
    fileId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    pageSize: string,
    pageNumber: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCommentThreadResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comment-threads/file/{fileId}'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling getCommentThread.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getCommentThread.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getCommentThread.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getCommentThread.'
      );
    }

    // verify required parameter 'pageSize' is not null or undefined
    if (pageSize === null || pageSize === undefined) {
      throw new Error(
        'Required parameter pageSize was null or undefined when calling getCommentThread.'
      );
    }

    // verify required parameter 'pageNumber' is not null or undefined
    if (pageNumber === null || pageNumber === undefined) {
      throw new Error(
        'Required parameter pageNumber was null or undefined when calling getCommentThread.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'string'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCommentThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCommentThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a specific document snapshot
   * @summary Get a document snapshot
   * @param fileId file_id identifies the file
   * @param snapshotId snapshot_id identifies the specific snapshot
   * @param userId user_id identifies the user requesting the snapshot
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getDocumentSnapshot(
    fileId: string,
    snapshotId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetDocumentSnapshotResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/snapshots/{snapshotId}'
        .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)))
        .replace(
          '{' + 'snapshotId' + '}',
          encodeURIComponent(String(snapshotId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling getDocumentSnapshot.'
      );
    }

    // verify required parameter 'snapshotId' is not null or undefined
    if (snapshotId === null || snapshotId === undefined) {
      throw new Error(
        'Required parameter snapshotId was null or undefined when calling getDocumentSnapshot.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getDocumentSnapshot.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getDocumentSnapshot.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getDocumentSnapshot.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetDocumentSnapshotResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetDocumentSnapshotResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a specific version of a file
   * @summary Get file version
   * @param fileId file_id identifies the file
   * @param versionId version_id identifies the specific version to retrieve
   * @param userId user_id identifies the user requesting the file version
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getFileVersion(
    fileId: string,
    versionId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetFileVersionResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/versions/{versionId}'
        .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)))
        .replace(
          '{' + 'versionId' + '}',
          encodeURIComponent(String(versionId))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling getFileVersion.'
      );
    }

    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling getFileVersion.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getFileVersion.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getFileVersion.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getFileVersion.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetFileVersionResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetFileVersionResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a single comment thread by its ID
   * @summary Get a single comment thread
   * @param threadId thread_id identifies the specific comment thread to retrieve
   * @param userId user_id identifies the user requesting the thread Must be authenticated and authorized to view the thread
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getSingleCommentThread(
    threadId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetSingleCommentThreadResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comment-threads/{threadId}/single'.replace(
        '{' + 'threadId' + '}',
        encodeURIComponent(String(threadId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'threadId' is not null or undefined
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling getSingleCommentThread.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getSingleCommentThread.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getSingleCommentThread.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getSingleCommentThread.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetSingleCommentThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetSingleCommentThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves compliance settings for a workspace
   * @summary Get workspace compliance settings
   * @param workspaceId workspace_id identifies the workspace
   * @param userId user_id identifies the user requesting the compliance settings
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getWorkspaceCompliance(
    workspaceId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetWorkspaceComplianceResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/compliance'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling getWorkspaceCompliance.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getWorkspaceCompliance.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getWorkspaceCompliance.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getWorkspaceCompliance.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetWorkspaceComplianceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetWorkspaceComplianceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a specific workspace share
   * @summary Get a workspace share
   * @param workspaceId workspace_id identifies the workspace
   * @param shareId share_id identifies the specific share to retrieve
   * @param userId user_id identifies the user requesting the share
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async getWorkspaceShare(
    workspaceId: string,
    shareId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetWorkspaceShareResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/shares/{shareId}'
        .replace(
          '{' + 'workspaceId' + '}',
          encodeURIComponent(String(workspaceId))
        )
        .replace('{' + 'shareId' + '}', encodeURIComponent(String(shareId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling getWorkspaceShare.'
      );
    }

    // verify required parameter 'shareId' is not null or undefined
    if (shareId === null || shareId === undefined) {
      throw new Error(
        'Required parameter shareId was null or undefined when calling getWorkspaceShare.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling getWorkspaceShare.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling getWorkspaceShare.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling getWorkspaceShare.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetWorkspaceShareResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetWorkspaceShareResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a paginated list of accounts with optional filtering
   * @summary List accounts
   * @param userId user_id identifies the user requesting the account list Must be authenticated and authorized to view accounts
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param emailFilter Filter by email pattern
   * @param createdAfter Filter by creation date range
   * @param createdBefore
   * @param includeDeleted Include deleted accounts in results
   * @param pageSize Pagination parameters
   * @param pageNumber
   */
  public async listAccounts(
    userId: string,
    orgId: string,
    tenantId: string,
    emailFilter?: string,
    createdAfter?: Date,
    createdBefore?: Date,
    includeDeleted?: boolean,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListAccountsResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/accounts';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listAccounts.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listAccounts.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listAccounts.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (emailFilter !== undefined) {
      localVarQueryParameters['emailFilter'] = ObjectSerializer.serialize(
        emailFilter,
        'string'
      );
    }

    if (createdAfter !== undefined) {
      localVarQueryParameters['createdAfter'] = ObjectSerializer.serialize(
        createdAfter,
        'Date'
      );
    }

    if (createdBefore !== undefined) {
      localVarQueryParameters['createdBefore'] = ObjectSerializer.serialize(
        createdBefore,
        'Date'
      );
    }

    if (includeDeleted !== undefined) {
      localVarQueryParameters['includeDeleted'] = ObjectSerializer.serialize(
        includeDeleted,
        'boolean'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListAccountsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ListAccountsResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of edits for a comment
   * @summary List comment edits
   * @param commentId
   * @param userId
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param pageSize
   * @param pageNumber
   */
  public async listCommentEdits(
    commentId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListCommentEditsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/comments/{commentId}/edits'.replace(
        '{' + 'commentId' + '}',
        encodeURIComponent(String(commentId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new Error(
        'Required parameter commentId was null or undefined when calling listCommentEdits.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listCommentEdits.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listCommentEdits.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listCommentEdits.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListCommentEditsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListCommentEditsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a paginated list of comments with optional filtering
   * @summary List comments
   * @param userId
   * @param workspaceId
   * @param folderId
   * @param fileId
   * @param threadId
   * @param orgId
   * @param tenantId
   */
  public async listComments(
    userId: string,
    workspaceId: string,
    folderId: string,
    fileId: string,
    threadId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListCommentsResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comments';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listComments.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling listComments.'
      );
    }

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling listComments.'
      );
    }

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling listComments.'
      );
    }

    // verify required parameter 'threadId' is not null or undefined
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling listComments.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listComments.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listComments.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (folderId !== undefined) {
      localVarQueryParameters['folderId'] = ObjectSerializer.serialize(
        folderId,
        'string'
      );
    }

    if (fileId !== undefined) {
      localVarQueryParameters['fileId'] = ObjectSerializer.serialize(
        fileId,
        'string'
      );
    }

    if (threadId !== undefined) {
      localVarQueryParameters['threadId'] = ObjectSerializer.serialize(
        threadId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListCommentsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ListCommentsResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a list of document snapshots for a file
   * @summary List document snapshots
   * @param fileId file_id identifies the file
   * @param userId user_id identifies the user requesting the snapshots
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param createdAfter Filter options
   * @param createdBefore
   * @param pageSize Pagination
   * @param pageNumber
   */
  public async listDocumentSnapshots(
    fileId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    createdAfter?: Date,
    createdBefore?: Date,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListDocumentSnapshotsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/snapshots'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling listDocumentSnapshots.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listDocumentSnapshots.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listDocumentSnapshots.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listDocumentSnapshots.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (createdAfter !== undefined) {
      localVarQueryParameters['createdAfter'] = ObjectSerializer.serialize(
        createdAfter,
        'Date'
      );
    }

    if (createdBefore !== undefined) {
      localVarQueryParameters['createdBefore'] = ObjectSerializer.serialize(
        createdBefore,
        'Date'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListDocumentSnapshotsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListDocumentSnapshotsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves all versions of a specific file
   * @summary List file versions
   * @param fileId file_id identifies the file
   * @param userId user_id identifies the user requesting the file versions
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param createdAfter Filter options
   * @param createdBefore
   * @param modifiedBy
   * @param pageSize Pagination
   * @param pageNumber
   */
  public async listFileVersions(
    fileId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    createdAfter?: Date,
    createdBefore?: Date,
    modifiedBy?: string,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListFileVersionsResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/versions'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling listFileVersions.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listFileVersions.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listFileVersions.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listFileVersions.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (createdAfter !== undefined) {
      localVarQueryParameters['createdAfter'] = ObjectSerializer.serialize(
        createdAfter,
        'Date'
      );
    }

    if (createdBefore !== undefined) {
      localVarQueryParameters['createdBefore'] = ObjectSerializer.serialize(
        createdBefore,
        'Date'
      );
    }

    if (modifiedBy !== undefined) {
      localVarQueryParameters['modifiedBy'] = ObjectSerializer.serialize(
        modifiedBy,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListFileVersionsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListFileVersionsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves a paginated list of files with optional filtering
   * @summary List files
   * @param userId user_id identifies the user requesting the file list
   * @param workspaceId Required workspace_id to filter files by workspace
   * @param folderId Required folder_id to filter files by folder
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param fileTypes Filter options  Filter by file type
   * @param namePattern Filter by name pattern
   * @param tags Filter by tags
   * @param includeDeleted Include soft-deleted files
   * @param createdAfter Date range filters
   * @param createdBefore
   * @param modifiedAfter
   * @param modifiedBefore
   * @param minSize Size range filters (in bytes)
   * @param maxSize
   * @param sortBy  - SORT_FIELD_UNSPECIFIED: Default value, no sort specified  - SORT_FIELD_NAME: Sort by item name (alphabetical)  - SORT_FIELD_CREATED_AT: Sort by creation timestamp  - SORT_FIELD_UPDATED_AT: Sort by last modification time  - SORT_FIELD_SIZE: Sort by file size (bytes)
   * @param sortDescending
   * @param pageSize Pagination
   * @param pageNumber
   */
  public async listFiles(
    userId: string,
    workspaceId: string,
    folderId: string,
    orgId: string,
    tenantId: string,
    fileTypes?: Array<string>,
    namePattern?: string,
    tags?: Array<string>,
    includeDeleted?: boolean,
    createdAfter?: Date,
    createdBefore?: Date,
    modifiedAfter?: Date,
    modifiedBefore?: Date,
    minSize?: string,
    maxSize?: string,
    sortBy?:
      | 'SORT_FIELD_UNSPECIFIED'
      | 'SORT_FIELD_NAME'
      | 'SORT_FIELD_CREATED_AT'
      | 'SORT_FIELD_UPDATED_AT'
      | 'SORT_FIELD_SIZE',
    sortDescending?: boolean,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListFilesResponse }> {
    const localVarPath = this.basePath + '/workspace-microservice/api/v1/files';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listFiles.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling listFiles.'
      );
    }

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling listFiles.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listFiles.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listFiles.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (folderId !== undefined) {
      localVarQueryParameters['folderId'] = ObjectSerializer.serialize(
        folderId,
        'string'
      );
    }

    if (fileTypes !== undefined) {
      localVarQueryParameters['fileTypes'] = ObjectSerializer.serialize(
        fileTypes,
        'Array<string>'
      );
    }

    if (namePattern !== undefined) {
      localVarQueryParameters['namePattern'] = ObjectSerializer.serialize(
        namePattern,
        'string'
      );
    }

    if (tags !== undefined) {
      localVarQueryParameters['tags'] = ObjectSerializer.serialize(
        tags,
        'Array<string>'
      );
    }

    if (includeDeleted !== undefined) {
      localVarQueryParameters['includeDeleted'] = ObjectSerializer.serialize(
        includeDeleted,
        'boolean'
      );
    }

    if (createdAfter !== undefined) {
      localVarQueryParameters['createdAfter'] = ObjectSerializer.serialize(
        createdAfter,
        'Date'
      );
    }

    if (createdBefore !== undefined) {
      localVarQueryParameters['createdBefore'] = ObjectSerializer.serialize(
        createdBefore,
        'Date'
      );
    }

    if (modifiedAfter !== undefined) {
      localVarQueryParameters['modifiedAfter'] = ObjectSerializer.serialize(
        modifiedAfter,
        'Date'
      );
    }

    if (modifiedBefore !== undefined) {
      localVarQueryParameters['modifiedBefore'] = ObjectSerializer.serialize(
        modifiedBefore,
        'Date'
      );
    }

    if (minSize !== undefined) {
      localVarQueryParameters['minSize'] = ObjectSerializer.serialize(
        minSize,
        'string'
      );
    }

    if (maxSize !== undefined) {
      localVarQueryParameters['maxSize'] = ObjectSerializer.serialize(
        maxSize,
        'string'
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(
        sortBy,
        "'SORT_FIELD_UNSPECIFIED' | 'SORT_FIELD_NAME' | 'SORT_FIELD_CREATED_AT' | 'SORT_FIELD_UPDATED_AT' | 'SORT_FIELD_SIZE'"
      );
    }

    if (sortDescending !== undefined) {
      localVarQueryParameters['sortDescending'] = ObjectSerializer.serialize(
        sortDescending,
        'boolean'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListFilesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ListFilesResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint lists all folders
   * @summary List folders
   * @param userId user_id identifies the user making the folder listing request Must be authenticated and authorized to access the workspace
   * @param folderId folder_id optionally specifies a parent folder to list contents from If not provided, lists from the workspace root
   * @param workspaceId workspace_id identifies the specific workspace context Required to scope the folder listing to the correct workspace
   * @param orgId org_id identifies the organization context for the folder listing Must be a valid organization identifier that the user belongs to
   * @param tenantId tenant_id identifies the tenant context for the folder listing Required for multi-tenant deployments to maintain proper data isolation
   */
  public async listFolder(
    userId: string,
    folderId: string,
    workspaceId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListFolderResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/folders';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listFolder.'
      );
    }

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling listFolder.'
      );
    }

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling listFolder.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listFolder.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listFolder.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (folderId !== undefined) {
      localVarQueryParameters['folderId'] = ObjectSerializer.serialize(
        folderId,
        'string'
      );
    }

    if (workspaceId !== undefined) {
      localVarQueryParameters['workspaceId'] = ObjectSerializer.serialize(
        workspaceId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListFolderResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ListFolderResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint lists all workspaces
   * @summary List workspaces
   * @param userId user_id uniquely identifies the user requesting the workspace list Must be a valid, authenticated user ID from the authentication system
   * @param orgId org_id identifies the organization context for listing workspaces Must be a valid organization identifier to ensure proper scoping of results
   * @param tenantId tenant_id identifies the tenant context for multi-tenant deployments Required to ensure proper isolation between different tenants
   * @param pageSize page_size specifies the maximum number of workspaces to return in a single response Server may return fewer workspaces than specified If unspecified, server will decide the default page size
   * @param pageNumber page_number specifies which page of results to return Pages are 1-based (first page is 1) If unspecified, defaults to page 1
   */
  public async listWorkspace(
    userId: string,
    orgId: string,
    tenantId: string,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ListWorkspaceResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/workspaces';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listWorkspace.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listWorkspace.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listWorkspace.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListWorkspaceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListWorkspaceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint retrieves activity history for a workspace
   * @summary List workspace activity
   * @param workspaceId workspace_id identifies the workspace
   * @param userId user_id identifies the user requesting the activity list
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param startTime Filter options
   * @param endTime
   * @param pageSize Pagination
   * @param pageNumber
   */
  public async listWorkspaceActivity(
    workspaceId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    startTime?: Date,
    endTime?: Date,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListWorkspaceActivityResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/activity'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling listWorkspaceActivity.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listWorkspaceActivity.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listWorkspaceActivity.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listWorkspaceActivity.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (startTime !== undefined) {
      localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
        startTime,
        'Date'
      );
    }

    if (endTime !== undefined) {
      localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
        endTime,
        'Date'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListWorkspaceActivityResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListWorkspaceActivityResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint lists all shares for a workspace
   * @summary List workspace shares
   * @param workspaceId workspace_id identifies the workspace
   * @param userId user_id identifies the user requesting the shares
   * @param orgId Organization and tenant context
   * @param tenantId
   * @param pageSize Pagination
   * @param pageNumber
   */
  public async listWorkspaceShares(
    workspaceId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    pageSize?: number,
    pageNumber?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: ListWorkspaceSharesResponse;
  }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/shares'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling listWorkspaceShares.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling listWorkspaceShares.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling listWorkspaceShares.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling listWorkspaceShares.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(
        pageSize,
        'number'
      );
    }

    if (pageNumber !== undefined) {
      localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(
        pageNumber,
        'number'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListWorkspaceSharesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ListWorkspaceSharesResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint shares a file with specified users or generates a sharing link
   * @summary Share a file
   * @param fileId file_id identifies the file to be shared
   * @param shareFileBody
   */
  public async shareFile(
    fileId: string,
    shareFileBody: ShareFileBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ShareFileResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/share'.replace(
        '{' + 'fileId' + '}',
        encodeURIComponent(String(fileId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling shareFile.'
      );
    }

    // verify required parameter 'shareFileBody' is not null or undefined
    if (shareFileBody === null || shareFileBody === undefined) {
      throw new Error(
        'Required parameter shareFileBody was null or undefined when calling shareFile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(shareFileBody, 'ShareFileBody'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ShareFileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ShareFileResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint shares a workspace with a specified user
   * @summary Share a workspace
   * @param workspaceId workspace_id identifies the workspace to share
   * @param shareWorkspaceBody
   */
  public async shareWorkspace(
    workspaceId: string,
    shareWorkspaceBody: ShareWorkspaceBody,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ShareWorkspaceResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/workspaces/{workspaceId}/shares'.replace(
        '{' + 'workspaceId' + '}',
        encodeURIComponent(String(workspaceId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        'Required parameter workspaceId was null or undefined when calling shareWorkspace.'
      );
    }

    // verify required parameter 'shareWorkspaceBody' is not null or undefined
    if (shareWorkspaceBody === null || shareWorkspaceBody === undefined) {
      throw new Error(
        'Required parameter shareWorkspaceBody was null or undefined when calling shareWorkspace.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        shareWorkspaceBody,
        'ShareWorkspaceBody'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ShareWorkspaceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'ShareWorkspaceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint revokes file sharing for specified users or disables sharing links
   * @summary Unshare a file
   * @param fileId file_id identifies the file to unshare
   * @param shareId
   * @param userId user_id identifies the user unsharing the file
   * @param orgId Organization and tenant context
   * @param tenantId
   */
  public async unshareFile(
    fileId: string,
    shareId: string,
    userId: string,
    orgId: string,
    tenantId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UnshareFileResponse }> {
    const localVarPath =
      this.basePath +
      '/workspace-microservice/api/v1/files/{fileId}/share/{shareId}'
        .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)))
        .replace('{' + 'shareId' + '}', encodeURIComponent(String(shareId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'fileId' is not null or undefined
    if (fileId === null || fileId === undefined) {
      throw new Error(
        'Required parameter fileId was null or undefined when calling unshareFile.'
      );
    }

    // verify required parameter 'shareId' is not null or undefined
    if (shareId === null || shareId === undefined) {
      throw new Error(
        'Required parameter shareId was null or undefined when calling unshareFile.'
      );
    }

    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling unshareFile.'
      );
    }

    // verify required parameter 'orgId' is not null or undefined
    if (orgId === null || orgId === undefined) {
      throw new Error(
        'Required parameter orgId was null or undefined when calling unshareFile.'
      );
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error(
        'Required parameter tenantId was null or undefined when calling unshareFile.'
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters['userId'] = ObjectSerializer.serialize(
        userId,
        'string'
      );
    }

    if (orgId !== undefined) {
      localVarQueryParameters['orgId'] = ObjectSerializer.serialize(
        orgId,
        'string'
      );
    }

    if (tenantId !== undefined) {
      localVarQueryParameters['tenantId'] = ObjectSerializer.serialize(
        tenantId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UnshareFileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UnshareFileResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a comment\'s content or metadata
   * @summary Update a comment
   * @param updateCommentRequest Comment Update Operations UpdateCommentRequest represents a request to update various aspects of a comment including content, metadata, visibility, and status.
   */
  public async updateComment(
    updateCommentRequest: UpdateCommentRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateCommentResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comments';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateCommentRequest' is not null or undefined
    if (updateCommentRequest === null || updateCommentRequest === undefined) {
      throw new Error(
        'Required parameter updateCommentRequest was null or undefined when calling updateComment.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateCommentRequest,
        'UpdateCommentRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateCommentResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateCommentResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a specific comment edit
   * @summary Update a comment edit
   * @param updateCommentEditRequest
   */
  public async updateCommentEdit(
    updateCommentEditRequest: UpdateCommentEditRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateCommentEditResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comments/edits';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateCommentEditRequest' is not null or undefined
    if (
      updateCommentEditRequest === null ||
      updateCommentEditRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateCommentEditRequest was null or undefined when calling updateCommentEdit.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateCommentEditRequest,
        'UpdateCommentEditRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateCommentEditResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateCommentEditResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a comment thread\'s properties
   * @summary Update a comment thread
   * @param updateCommentThreadRequest
   */
  public async updateCommentThread(
    updateCommentThreadRequest: UpdateCommentThreadRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateCommentThreadResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/comment-threads';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateCommentThreadRequest' is not null or undefined
    if (
      updateCommentThreadRequest === null ||
      updateCommentThreadRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateCommentThreadRequest was null or undefined when calling updateCommentThread.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateCommentThreadRequest,
        'UpdateCommentThreadRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateCommentThreadResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateCommentThreadResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a file by ID
   * @summary Update a file
   * @param updateFileRequest UpdateFileRequest represents a request to update an existing file\&#39;s metadata in the system. This message contains the updated metadata for the file, allowing modification of file attributes while maintaining version history and access controls.
   */
  public async updateFile(
    updateFileRequest: UpdateFileRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateFileResponse }> {
    const localVarPath = this.basePath + '/workspace-microservice/api/v1/files';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateFileRequest' is not null or undefined
    if (updateFileRequest === null || updateFileRequest === undefined) {
      throw new Error(
        'Required parameter updateFileRequest was null or undefined when calling updateFile.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateFileRequest, 'UpdateFileRequest'),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateFileResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateFileResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a folder by ID
   * @summary Update a folder
   * @param updateFolderRequest UpdateFolderRequest represents a request to update an existing folder\&#39;s metadata. This message contains the updated folder metadata, allowing modification of folder attributes while maintaining proper access controls and organizational hierarchy.  Key features: - Complete folder metadata updates - Maintains folder relationships - Preserves access controls - Supports audit trail
   */
  public async updateFolder(
    updateFolderRequest: UpdateFolderRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpdateFolderResponse }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/folders';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateFolderRequest' is not null or undefined
    if (updateFolderRequest === null || updateFolderRequest === undefined) {
      throw new Error(
        'Required parameter updateFolderRequest was null or undefined when calling updateFolder.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateFolderRequest,
        'UpdateFolderRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateFolderResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'UpdateFolderResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a workspace by ID
   * @summary Update a workspace
   * @param updateWorkspaceRequest UpdateWorkspaceRequest represents a request to update an existing workspace\&#39;s properties. This message contains the complete workspace object with updated fields, allowing modification of workspace attributes while maintaining data consistency and access controls.  Key features: - Full workspace object updates - Validation of required fields - Version tracking support - Access control preservation
   */
  public async updateWorkspace(
    updateWorkspaceRequest: UpdateWorkspaceRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateWorkspaceResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/workspaces';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateWorkspaceRequest' is not null or undefined
    if (
      updateWorkspaceRequest === null ||
      updateWorkspaceRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateWorkspaceRequest was null or undefined when calling updateWorkspace.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateWorkspaceRequest,
        'UpdateWorkspaceRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateWorkspaceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateWorkspaceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates compliance settings for a workspace
   * @summary Update workspace compliance settings
   * @param updateWorkspaceComplianceRequest UpdateWorkspaceComplianceRequest represents a request to update compliance settings for a workspace. This operation modifies the existing compliance configuration with new settings.  Required Fields: - compliance: The new compliance settings to apply to the workspace  The compliance settings include: - Data retention policies - Access control requirements - Audit logging configurations - Security controls - Regulatory compliance flags  Example: &#x60;&#x60;&#x60;protobuf message request {   compliance: {     data_retention_days: 90     require_2fa: true     audit_logging_enabled: true   } } &#x60;&#x60;&#x60;
   */
  public async updateWorkspaceCompliance(
    updateWorkspaceComplianceRequest: UpdateWorkspaceComplianceRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateWorkspaceComplianceResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/workspaces/compliance';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateWorkspaceComplianceRequest' is not null or undefined
    if (
      updateWorkspaceComplianceRequest === null ||
      updateWorkspaceComplianceRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateWorkspaceComplianceRequest was null or undefined when calling updateWorkspaceCompliance.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateWorkspaceComplianceRequest,
        'UpdateWorkspaceComplianceRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateWorkspaceComplianceResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateWorkspaceComplianceResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This endpoint updates a workspace share\'s properties
   * @summary Update a workspace share
   * @param updateWorkspaceShareRequest UpdateWorkspaceShareRequest represents a request to update an existing workspace share. Contains the modified share object with updated permissions or settings.  Required Fields: - share: The WorkspaceSharing object containing the updated share configuration
   */
  public async updateWorkspaceShare(
    updateWorkspaceShareRequest: UpdateWorkspaceShareRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateWorkspaceShareResponse;
  }> {
    const localVarPath =
      this.basePath + '/workspace-microservice/api/v1/workspaces/shares';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json', ''];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateWorkspaceShareRequest' is not null or undefined
    if (
      updateWorkspaceShareRequest === null ||
      updateWorkspaceShareRequest === undefined
    ) {
      throw new Error(
        'Required parameter updateWorkspaceShareRequest was null or undefined when calling updateWorkspaceShare.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateWorkspaceShareRequest,
        'UpdateWorkspaceShareRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateWorkspaceShareResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'UpdateWorkspaceShareResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
