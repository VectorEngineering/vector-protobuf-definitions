#![allow(unused_qualifications)]

use validator::Validate;

use crate::models;
#[cfg(any(feature = "client", feature = "server"))]
use crate::header;

/// Account represents a user account within the workspace service. It serves as the top-level container for all user-specific workspaces and settings.  Key features: - Unique identification via Auth0 - Organization and tenant context - Audit timestamps - Associated scraping jobs  Database considerations: - Uses GORM for ORM mapping - Includes indexes for efficient querying - Supports soft deletes via deleted_at  Usage example: ```go account := &Account{     AuthPlatformUserId: \"auth0|123\",     OrgId: \"org_123\",     TenantId: \"tenant_456\", } ```
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Account {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "authPlatformUserId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth_platform_user_id: Option<String>,

    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "accountStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_status: Option<models::AccountStatus>,

    #[serde(rename = "roles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub roles: Option<Vec<models::Role>>,

    #[serde(rename = "permissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<Vec<models::Permission>>,

    #[serde(rename = "mfaEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mfa_enabled: Option<bool>,

    #[serde(rename = "lastLoginAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_login_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "timezone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timezone: Option<models::Timezone>,

    #[serde(rename = "totalJobsRun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_jobs_run: Option<i32>,

    #[serde(rename = "monthlyJobLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_job_limit: Option<i32>,

    #[serde(rename = "concurrentJobLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub concurrent_job_limit: Option<i32>,

    #[serde(rename = "workspaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspaces: Option<Vec<models::Workspace>>,

    #[serde(rename = "settings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub settings: Option<models::AccountSettings>,

}


impl Account {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Account {
        Account {
            id: None,
            auth_platform_user_id: None,
            email: None,
            deleted_at: None,
            created_at: None,
            account_status: None,
            roles: None,
            permissions: None,
            mfa_enabled: None,
            last_login_at: None,
            timezone: None,
            total_jobs_run: None,
            monthly_job_limit: None,
            concurrent_job_limit: None,
            workspaces: None,
            settings: None,
        }
    }
}

/// Converts the Account value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Account {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.auth_platform_user_id.as_ref().map(|auth_platform_user_id| {
                [
                    "authPlatformUserId".to_string(),
                    auth_platform_user_id.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),

            // Skipping deletedAt in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping accountStatus in query parameter serialization

            // Skipping roles in query parameter serialization

            // Skipping permissions in query parameter serialization


            self.mfa_enabled.as_ref().map(|mfa_enabled| {
                [
                    "mfaEnabled".to_string(),
                    mfa_enabled.to_string(),
                ].join(",")
            }),

            // Skipping lastLoginAt in query parameter serialization

            // Skipping timezone in query parameter serialization


            self.total_jobs_run.as_ref().map(|total_jobs_run| {
                [
                    "totalJobsRun".to_string(),
                    total_jobs_run.to_string(),
                ].join(",")
            }),


            self.monthly_job_limit.as_ref().map(|monthly_job_limit| {
                [
                    "monthlyJobLimit".to_string(),
                    monthly_job_limit.to_string(),
                ].join(",")
            }),


            self.concurrent_job_limit.as_ref().map(|concurrent_job_limit| {
                [
                    "concurrentJobLimit".to_string(),
                    concurrent_job_limit.to_string(),
                ].join(",")
            }),

            // Skipping workspaces in query parameter serialization

            // Skipping settings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Account value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Account {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub auth_platform_user_id: Vec<String>,
            pub email: Vec<String>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub account_status: Vec<models::AccountStatus>,
            pub roles: Vec<Vec<models::Role>>,
            pub permissions: Vec<Vec<models::Permission>>,
            pub mfa_enabled: Vec<bool>,
            pub last_login_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub timezone: Vec<models::Timezone>,
            pub total_jobs_run: Vec<i32>,
            pub monthly_job_limit: Vec<i32>,
            pub concurrent_job_limit: Vec<i32>,
            pub workspaces: Vec<Vec<models::Workspace>>,
            pub settings: Vec<models::AccountSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Account".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authPlatformUserId" => intermediate_rep.auth_platform_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accountStatus" => intermediate_rep.account_status.push(<models::AccountStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "roles" => return std::result::Result::Err("Parsing a container in this style is not supported in Account".to_string()),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in Account".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mfaEnabled" => intermediate_rep.mfa_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastLoginAt" => intermediate_rep.last_login_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timezone" => intermediate_rep.timezone.push(<models::Timezone as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalJobsRun" => intermediate_rep.total_jobs_run.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "monthlyJobLimit" => intermediate_rep.monthly_job_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "concurrentJobLimit" => intermediate_rep.concurrent_job_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "workspaces" => return std::result::Result::Err("Parsing a container in this style is not supported in Account".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "settings" => intermediate_rep.settings.push(<models::AccountSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Account".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Account {
            id: intermediate_rep.id.into_iter().next(),
            auth_platform_user_id: intermediate_rep.auth_platform_user_id.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            account_status: intermediate_rep.account_status.into_iter().next(),
            roles: intermediate_rep.roles.into_iter().next(),
            permissions: intermediate_rep.permissions.into_iter().next(),
            mfa_enabled: intermediate_rep.mfa_enabled.into_iter().next(),
            last_login_at: intermediate_rep.last_login_at.into_iter().next(),
            timezone: intermediate_rep.timezone.into_iter().next(),
            total_jobs_run: intermediate_rep.total_jobs_run.into_iter().next(),
            monthly_job_limit: intermediate_rep.monthly_job_limit.into_iter().next(),
            concurrent_job_limit: intermediate_rep.concurrent_job_limit.into_iter().next(),
            workspaces: intermediate_rep.workspaces.into_iter().next(),
            settings: intermediate_rep.settings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Account> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Account>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Account>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Account - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Account> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Account as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Account - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Account1 {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "auth0UserId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth0_user_id: Option<String>,

    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

    #[serde(rename = "baseDirectory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_directory: Option<String>,

    #[serde(rename = "bucketName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bucket_name: Option<String>,

    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<String>,

    #[serde(rename = "orgId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "roles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub roles: Option<Vec<String>>,

    #[serde(rename = "permissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<Vec<String>>,

    #[serde(rename = "mfaEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mfa_enabled: Option<bool>,

    #[serde(rename = "complianceLevel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_level: Option<models::ComplianceLevel>,

    #[serde(rename = "preferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferences: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "apiKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_keys: Option<Vec<String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "workspaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspaces: Option<Vec<models::Workspace1>>,

    #[serde(rename = "dataProfiles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_profiles: Option<Vec<models::DataProfile>>,

}


impl Account1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Account1 {
        Account1 {
            id: None,
            auth0_user_id: None,
            email: None,
            base_directory: None,
            bucket_name: None,
            region: None,
            org_id: None,
            tenant_id: None,
            roles: None,
            permissions: None,
            mfa_enabled: None,
            compliance_level: None,
            preferences: None,
            api_keys: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            workspaces: None,
            data_profiles: None,
        }
    }
}

/// Converts the Account1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Account1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.auth0_user_id.as_ref().map(|auth0_user_id| {
                [
                    "auth0UserId".to_string(),
                    auth0_user_id.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.base_directory.as_ref().map(|base_directory| {
                [
                    "baseDirectory".to_string(),
                    base_directory.to_string(),
                ].join(",")
            }),


            self.bucket_name.as_ref().map(|bucket_name| {
                [
                    "bucketName".to_string(),
                    bucket_name.to_string(),
                ].join(",")
            }),


            self.region.as_ref().map(|region| {
                [
                    "region".to_string(),
                    region.to_string(),
                ].join(",")
            }),


            self.org_id.as_ref().map(|org_id| {
                [
                    "orgId".to_string(),
                    org_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.roles.as_ref().map(|roles| {
                [
                    "roles".to_string(),
                    roles.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.permissions.as_ref().map(|permissions| {
                [
                    "permissions".to_string(),
                    permissions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mfa_enabled.as_ref().map(|mfa_enabled| {
                [
                    "mfaEnabled".to_string(),
                    mfa_enabled.to_string(),
                ].join(",")
            }),

            // Skipping complianceLevel in query parameter serialization

            // Skipping preferences in query parameter serialization


            self.api_keys.as_ref().map(|api_keys| {
                [
                    "apiKeys".to_string(),
                    api_keys.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping workspaces in query parameter serialization

            // Skipping dataProfiles in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Account1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Account1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub auth0_user_id: Vec<String>,
            pub email: Vec<String>,
            pub base_directory: Vec<String>,
            pub bucket_name: Vec<String>,
            pub region: Vec<String>,
            pub org_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub roles: Vec<Vec<String>>,
            pub permissions: Vec<Vec<String>>,
            pub mfa_enabled: Vec<bool>,
            pub compliance_level: Vec<models::ComplianceLevel>,
            pub preferences: Vec<std::collections::HashMap<String, String>>,
            pub api_keys: Vec<Vec<String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub workspaces: Vec<Vec<models::Workspace1>>,
            pub data_profiles: Vec<Vec<models::DataProfile>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Account1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "auth0UserId" => intermediate_rep.auth0_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baseDirectory" => intermediate_rep.base_directory.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bucketName" => intermediate_rep.bucket_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orgId" => intermediate_rep.org_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "roles" => return std::result::Result::Err("Parsing a container in this style is not supported in Account1".to_string()),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in Account1".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mfaEnabled" => intermediate_rep.mfa_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complianceLevel" => intermediate_rep.compliance_level.push(<models::ComplianceLevel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferences" => return std::result::Result::Err("Parsing a container in this style is not supported in Account1".to_string()),
                    "apiKeys" => return std::result::Result::Err("Parsing a container in this style is not supported in Account1".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "workspaces" => return std::result::Result::Err("Parsing a container in this style is not supported in Account1".to_string()),
                    "dataProfiles" => return std::result::Result::Err("Parsing a container in this style is not supported in Account1".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Account1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Account1 {
            id: intermediate_rep.id.into_iter().next(),
            auth0_user_id: intermediate_rep.auth0_user_id.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            base_directory: intermediate_rep.base_directory.into_iter().next(),
            bucket_name: intermediate_rep.bucket_name.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
            org_id: intermediate_rep.org_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            roles: intermediate_rep.roles.into_iter().next(),
            permissions: intermediate_rep.permissions.into_iter().next(),
            mfa_enabled: intermediate_rep.mfa_enabled.into_iter().next(),
            compliance_level: intermediate_rep.compliance_level.into_iter().next(),
            preferences: intermediate_rep.preferences.into_iter().next(),
            api_keys: intermediate_rep.api_keys.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            workspaces: intermediate_rep.workspaces.into_iter().next(),
            data_profiles: intermediate_rep.data_profiles.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Account1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Account1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Account1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Account1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Account1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Account1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Account1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccountSettings {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "emailNotifications")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email_notifications: Option<bool>,

    #[serde(rename = "slackNotifications")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub slack_notifications: Option<bool>,

    #[serde(rename = "defaultDataRetention")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_data_retention: Option<String>,

    #[serde(rename = "autoPurgeEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_purge_enabled: Option<bool>,

    #[serde(rename = "require2fa")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub require2fa: Option<bool>,

    #[serde(rename = "sessionTimeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub session_timeout: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AccountSettings {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AccountSettings {
        AccountSettings {
            id: None,
            email_notifications: None,
            slack_notifications: None,
            default_data_retention: None,
            auto_purge_enabled: None,
            require2fa: None,
            session_timeout: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
        }
    }
}

/// Converts the AccountSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccountSettings {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.email_notifications.as_ref().map(|email_notifications| {
                [
                    "emailNotifications".to_string(),
                    email_notifications.to_string(),
                ].join(",")
            }),


            self.slack_notifications.as_ref().map(|slack_notifications| {
                [
                    "slackNotifications".to_string(),
                    slack_notifications.to_string(),
                ].join(",")
            }),


            self.default_data_retention.as_ref().map(|default_data_retention| {
                [
                    "defaultDataRetention".to_string(),
                    default_data_retention.to_string(),
                ].join(",")
            }),


            self.auto_purge_enabled.as_ref().map(|auto_purge_enabled| {
                [
                    "autoPurgeEnabled".to_string(),
                    auto_purge_enabled.to_string(),
                ].join(",")
            }),


            self.require2fa.as_ref().map(|require2fa| {
                [
                    "require2fa".to_string(),
                    require2fa.to_string(),
                ].join(",")
            }),


            self.session_timeout.as_ref().map(|session_timeout| {
                [
                    "sessionTimeout".to_string(),
                    session_timeout.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccountSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccountSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub email_notifications: Vec<bool>,
            pub slack_notifications: Vec<bool>,
            pub default_data_retention: Vec<String>,
            pub auto_purge_enabled: Vec<bool>,
            pub require2fa: Vec<bool>,
            pub session_timeout: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccountSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "emailNotifications" => intermediate_rep.email_notifications.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "slackNotifications" => intermediate_rep.slack_notifications.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "defaultDataRetention" => intermediate_rep.default_data_retention.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "autoPurgeEnabled" => intermediate_rep.auto_purge_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "require2fa" => intermediate_rep.require2fa.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sessionTimeout" => intermediate_rep.session_timeout.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccountSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccountSettings {
            id: intermediate_rep.id.into_iter().next(),
            email_notifications: intermediate_rep.email_notifications.into_iter().next(),
            slack_notifications: intermediate_rep.slack_notifications.into_iter().next(),
            default_data_retention: intermediate_rep.default_data_retention.into_iter().next(),
            auto_purge_enabled: intermediate_rep.auto_purge_enabled.into_iter().next(),
            require2fa: intermediate_rep.require2fa.into_iter().next(),
            session_timeout: intermediate_rep.session_timeout.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccountSettings> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccountSettings>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccountSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccountSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccountSettings> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccountSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccountSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AccountStatus {
    #[serde(rename = "ACCOUNT_STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "ACCOUNT_STATUS_ACTIVE")]
    Active,
    #[serde(rename = "ACCOUNT_STATUS_SUSPENDED")]
    Suspended,
    #[serde(rename = "ACCOUNT_STATUS_PENDING_VERIFICATION")]
    PendingVerification,
}

impl std::fmt::Display for AccountStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AccountStatus::Unspecified => write!(f, "ACCOUNT_STATUS_UNSPECIFIED"),
            AccountStatus::Active => write!(f, "ACCOUNT_STATUS_ACTIVE"),
            AccountStatus::Suspended => write!(f, "ACCOUNT_STATUS_SUSPENDED"),
            AccountStatus::PendingVerification => write!(f, "ACCOUNT_STATUS_PENDING_VERIFICATION"),
        }
    }
}

impl std::str::FromStr for AccountStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACCOUNT_STATUS_UNSPECIFIED" => std::result::Result::Ok(AccountStatus::Unspecified),
            "ACCOUNT_STATUS_ACTIVE" => std::result::Result::Ok(AccountStatus::Active),
            "ACCOUNT_STATUS_SUSPENDED" => std::result::Result::Ok(AccountStatus::Suspended),
            "ACCOUNT_STATUS_PENDING_VERIFICATION" => std::result::Result::Ok(AccountStatus::PendingVerification),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ActivityMetrics {
    #[serde(rename = "totalFiles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_files: Option<i32>,

    #[serde(rename = "totalFolders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_folders: Option<i32>,

    #[serde(rename = "activeUsers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_users: Option<i32>,

    #[serde(rename = "storageUsed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_used: Option<String>,

    #[serde(rename = "storageUsagePercentage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_usage_percentage: Option<f32>,

}


impl ActivityMetrics {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ActivityMetrics {
        ActivityMetrics {
            total_files: None,
            total_folders: None,
            active_users: None,
            storage_used: None,
            storage_usage_percentage: None,
        }
    }
}

/// Converts the ActivityMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ActivityMetrics {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.total_files.as_ref().map(|total_files| {
                [
                    "totalFiles".to_string(),
                    total_files.to_string(),
                ].join(",")
            }),


            self.total_folders.as_ref().map(|total_folders| {
                [
                    "totalFolders".to_string(),
                    total_folders.to_string(),
                ].join(",")
            }),


            self.active_users.as_ref().map(|active_users| {
                [
                    "activeUsers".to_string(),
                    active_users.to_string(),
                ].join(",")
            }),


            self.storage_used.as_ref().map(|storage_used| {
                [
                    "storageUsed".to_string(),
                    storage_used.to_string(),
                ].join(",")
            }),


            self.storage_usage_percentage.as_ref().map(|storage_usage_percentage| {
                [
                    "storageUsagePercentage".to_string(),
                    storage_usage_percentage.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ActivityMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ActivityMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total_files: Vec<i32>,
            pub total_folders: Vec<i32>,
            pub active_users: Vec<i32>,
            pub storage_used: Vec<String>,
            pub storage_usage_percentage: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ActivityMetrics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "totalFiles" => intermediate_rep.total_files.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalFolders" => intermediate_rep.total_folders.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "activeUsers" => intermediate_rep.active_users.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageUsed" => intermediate_rep.storage_used.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageUsagePercentage" => intermediate_rep.storage_usage_percentage.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ActivityMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ActivityMetrics {
            total_files: intermediate_rep.total_files.into_iter().next(),
            total_folders: intermediate_rep.total_folders.into_iter().next(),
            active_users: intermediate_rep.active_users.into_iter().next(),
            storage_used: intermediate_rep.storage_used.into_iter().next(),
            storage_usage_percentage: intermediate_rep.storage_usage_percentage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ActivityMetrics> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ActivityMetrics>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ActivityMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ActivityMetrics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ActivityMetrics> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ActivityMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ActivityMetrics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AiAssistanceLog {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "documentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub document_id: Option<String>,

    #[serde(rename = "interactionType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interaction_type: Option<String>,

    #[serde(rename = "userQuery")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_query: Option<String>,

    #[serde(rename = "aiResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ai_response: Option<String>,

    #[serde(rename = "context")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AiAssistanceLog {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AiAssistanceLog {
        AiAssistanceLog {
            id: None,
            document_id: None,
            interaction_type: None,
            user_query: None,
            ai_response: None,
            context: None,
            created_at: None,
        }
    }
}

/// Converts the AiAssistanceLog value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AiAssistanceLog {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.document_id.as_ref().map(|document_id| {
                [
                    "documentId".to_string(),
                    document_id.to_string(),
                ].join(",")
            }),


            self.interaction_type.as_ref().map(|interaction_type| {
                [
                    "interactionType".to_string(),
                    interaction_type.to_string(),
                ].join(",")
            }),


            self.user_query.as_ref().map(|user_query| {
                [
                    "userQuery".to_string(),
                    user_query.to_string(),
                ].join(",")
            }),


            self.ai_response.as_ref().map(|ai_response| {
                [
                    "aiResponse".to_string(),
                    ai_response.to_string(),
                ].join(",")
            }),

            // Skipping context in query parameter serialization

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AiAssistanceLog value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AiAssistanceLog {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub document_id: Vec<String>,
            pub interaction_type: Vec<String>,
            pub user_query: Vec<String>,
            pub ai_response: Vec<String>,
            pub context: Vec<std::collections::HashMap<String, String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AiAssistanceLog".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "documentId" => intermediate_rep.document_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interactionType" => intermediate_rep.interaction_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userQuery" => intermediate_rep.user_query.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "aiResponse" => intermediate_rep.ai_response.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "context" => return std::result::Result::Err("Parsing a container in this style is not supported in AiAssistanceLog".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AiAssistanceLog".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AiAssistanceLog {
            id: intermediate_rep.id.into_iter().next(),
            document_id: intermediate_rep.document_id.into_iter().next(),
            interaction_type: intermediate_rep.interaction_type.into_iter().next(),
            user_query: intermediate_rep.user_query.into_iter().next(),
            ai_response: intermediate_rep.ai_response.into_iter().next(),
            context: intermediate_rep.context.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AiAssistanceLog> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AiAssistanceLog>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AiAssistanceLog>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AiAssistanceLog - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AiAssistanceLog> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AiAssistanceLog as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AiAssistanceLog - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Any {
    /// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
    #[serde(rename = "@type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub at_type: Option<String>,

}


impl Any {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Any {
        Any {
            at_type: None,
        }
    }
}

/// Converts the Any value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Any {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.at_type.as_ref().map(|at_type| {
                [
                    "@type".to_string(),
                    at_type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Any value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Any {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub at_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Any".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "@type" => intermediate_rep.at_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Any".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Any {
            at_type: intermediate_rep.at_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Any> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Any>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Any>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Any - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Any> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Any as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Any - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiInfo {
    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

    #[serde(rename = "supportedVersions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_versions: Option<Vec<String>>,

    #[serde(rename = "isDeprecated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_deprecated: Option<bool>,

    #[serde(rename = "sunsetDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sunset_date: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ApiInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiInfo {
        ApiInfo {
            version: None,
            supported_versions: None,
            is_deprecated: None,
            sunset_date: None,
        }
    }
}

/// Converts the ApiInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),


            self.supported_versions.as_ref().map(|supported_versions| {
                [
                    "supportedVersions".to_string(),
                    supported_versions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.is_deprecated.as_ref().map(|is_deprecated| {
                [
                    "isDeprecated".to_string(),
                    is_deprecated.to_string(),
                ].join(",")
            }),

            // Skipping sunsetDate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub supported_versions: Vec<Vec<String>>,
            pub is_deprecated: Vec<bool>,
            pub sunset_date: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supportedVersions" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isDeprecated" => intermediate_rep.is_deprecated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sunsetDate" => intermediate_rep.sunset_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiInfo {
            version: intermediate_rep.version.into_iter().next(),
            supported_versions: intermediate_rep.supported_versions.into_iter().next(),
            is_deprecated: intermediate_rep.is_deprecated.into_iter().next(),
            sunset_date: intermediate_rep.sunset_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// APIKey represents an authentication token for accessing the API. It includes features for rate limiting, permissions, and usage tracking.  Key features: - Unique key identification - Scope-based access control - Rate limiting - Usage tracking - Expiration management - Multi-tenant support  Database considerations: - Uses GORM for ORM mapping - Includes indexes for efficient querying - Supports soft deletes  Usage example: ```go apiKey := &APIKey{     Name: \"Production API Key\",     Scopes: []string{\"leads:read\", \"leads:write\"},     ExpiresAt: timestamppb.New(time.Now().AddDate(1, 0, 0)), } ```
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiKey {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "keyHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_hash: Option<String>,

    #[serde(rename = "keyPrefix")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_prefix: Option<String>,

    #[serde(rename = "orgId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<String>>,

    #[serde(rename = "allowedIps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_ips: Option<Vec<String>>,

    #[serde(rename = "allowedDomains")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_domains: Option<Vec<String>>,

    #[serde(rename = "allowedEnvironments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_environments: Option<Vec<String>>,

    #[serde(rename = "isTestKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_test_key: Option<bool>,

    #[serde(rename = "requestsPerSecond")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requests_per_second: Option<i32>,

    #[serde(rename = "requestsPerDay")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requests_per_day: Option<i32>,

    #[serde(rename = "concurrentRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub concurrent_requests: Option<i32>,

    #[serde(rename = "monthlyRequestQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_request_quota: Option<String>,

    #[serde(rename = "costPerRequest")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cost_per_request: Option<f32>,

    #[serde(rename = "billingTier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_tier: Option<String>,

    #[serde(rename = "totalRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_requests: Option<String>,

    #[serde(rename = "totalErrors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_errors: Option<String>,

    #[serde(rename = "lastUsedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_used_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "averageResponseTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average_response_time: Option<f32>,

    /// Tracks usage per endpoint
    #[serde(rename = "endpointUsageJson")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_usage_json: Option<swagger::ByteArray>,

    #[serde(rename = "errorRatesJson")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_rates_json: Option<swagger::ByteArray>,

    #[serde(rename = "recentErrors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recent_errors: Option<swagger::ByteArray>,

    #[serde(rename = "successfulRequestsCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub successful_requests_count: Option<i32>,

    #[serde(rename = "successRate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success_rate: Option<f32>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::V1PeriodStatus>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastRotatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_rotated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastSecurityReviewAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_security_review_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "requiresClientSecret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requires_client_secret: Option<bool>,

    #[serde(rename = "clientSecretHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret_hash: Option<String>,

    #[serde(rename = "enforceHttps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_https: Option<bool>,

    #[serde(rename = "enforceSigning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_signing: Option<bool>,

    #[serde(rename = "allowedSignatureAlgorithms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_signature_algorithms: Option<Vec<String>>,

    #[serde(rename = "enforceMutualTls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_mutual_tls: Option<bool>,

    #[serde(rename = "clientCertificateHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_certificate_hash: Option<String>,

    #[serde(rename = "requireRequestSigning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_request_signing: Option<bool>,

    /// Detailed description of key usage
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "metadataJson")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata_json: Option<swagger::ByteArray>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,

    #[serde(rename = "apiVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_version: Option<String>,

    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_features: Option<Vec<String>>,

    #[serde(rename = "documentationUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,

    #[serde(rename = "supportContact")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub support_contact: Option<String>,

    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account>,

    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace>,

    #[serde(rename = "logAllRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_all_requests: Option<bool>,

    #[serde(rename = "lastRotationReason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_rotation_reason: Option<String>,

    #[serde(rename = "lastRotationDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_rotation_date: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "rotationFrequencyDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rotation_frequency_days: Option<i32>,

    #[serde(rename = "complianceStandards")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_standards: Option<Vec<String>>,

    #[serde(rename = "requiresAuditLogging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requires_audit_logging: Option<bool>,

    #[serde(rename = "dataResidency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_residency: Option<String>,

    #[serde(rename = "approvedIntegrations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub approved_integrations: Option<Vec<String>>,

    #[serde(rename = "alertEmails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_emails: Option<Vec<String>>,

    #[serde(rename = "webhookUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_url: Option<String>,

    #[serde(rename = "alertOnQuotaThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_on_quota_threshold: Option<bool>,

    #[serde(rename = "quotaAlertThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quota_alert_threshold: Option<f32>,

    #[serde(rename = "alertOnErrorSpike")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_on_error_spike: Option<bool>,

    #[serde(rename = "errorAlertThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_alert_threshold: Option<f32>,

    #[serde(rename = "monitoringIntegrations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monitoring_integrations: Option<Vec<String>>,

    #[serde(rename = "encrypted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted: Option<bool>,

    #[serde(rename = "dataClassification")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_classification: Option<String>,

}


impl ApiKey {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiKey {
        ApiKey {
            id: None,
            name: None,
            key_hash: None,
            key_prefix: None,
            org_id: None,
            tenant_id: None,
            scopes: None,
            allowed_ips: None,
            allowed_domains: None,
            allowed_environments: None,
            is_test_key: None,
            requests_per_second: None,
            requests_per_day: None,
            concurrent_requests: None,
            monthly_request_quota: None,
            cost_per_request: None,
            billing_tier: None,
            total_requests: None,
            total_errors: None,
            last_used_at: None,
            average_response_time: None,
            endpoint_usage_json: None,
            error_rates_json: None,
            recent_errors: None,
            successful_requests_count: None,
            success_rate: None,
            status: None,
            created_at: None,
            updated_at: None,
            expires_at: None,
            deleted_at: None,
            last_rotated_at: None,
            last_security_review_at: None,
            requires_client_secret: None,
            client_secret_hash: None,
            enforce_https: None,
            enforce_signing: None,
            allowed_signature_algorithms: None,
            enforce_mutual_tls: None,
            client_certificate_hash: None,
            require_request_signing: None,
            description: None,
            metadata_json: None,
            tags: None,
            api_version: None,
            supported_features: None,
            documentation_url: None,
            support_contact: None,
            account: None,
            workspace: None,
            log_all_requests: None,
            last_rotation_reason: None,
            last_rotation_date: None,
            rotation_frequency_days: None,
            compliance_standards: None,
            requires_audit_logging: None,
            data_residency: None,
            approved_integrations: None,
            alert_emails: None,
            webhook_url: None,
            alert_on_quota_threshold: None,
            quota_alert_threshold: None,
            alert_on_error_spike: None,
            error_alert_threshold: None,
            monitoring_integrations: None,
            encrypted: None,
            data_classification: None,
        }
    }
}

/// Converts the ApiKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiKey {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.key_hash.as_ref().map(|key_hash| {
                [
                    "keyHash".to_string(),
                    key_hash.to_string(),
                ].join(",")
            }),


            self.key_prefix.as_ref().map(|key_prefix| {
                [
                    "keyPrefix".to_string(),
                    key_prefix.to_string(),
                ].join(",")
            }),


            self.org_id.as_ref().map(|org_id| {
                [
                    "orgId".to_string(),
                    org_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.allowed_ips.as_ref().map(|allowed_ips| {
                [
                    "allowedIps".to_string(),
                    allowed_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.allowed_domains.as_ref().map(|allowed_domains| {
                [
                    "allowedDomains".to_string(),
                    allowed_domains.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.allowed_environments.as_ref().map(|allowed_environments| {
                [
                    "allowedEnvironments".to_string(),
                    allowed_environments.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.is_test_key.as_ref().map(|is_test_key| {
                [
                    "isTestKey".to_string(),
                    is_test_key.to_string(),
                ].join(",")
            }),


            self.requests_per_second.as_ref().map(|requests_per_second| {
                [
                    "requestsPerSecond".to_string(),
                    requests_per_second.to_string(),
                ].join(",")
            }),


            self.requests_per_day.as_ref().map(|requests_per_day| {
                [
                    "requestsPerDay".to_string(),
                    requests_per_day.to_string(),
                ].join(",")
            }),


            self.concurrent_requests.as_ref().map(|concurrent_requests| {
                [
                    "concurrentRequests".to_string(),
                    concurrent_requests.to_string(),
                ].join(",")
            }),


            self.monthly_request_quota.as_ref().map(|monthly_request_quota| {
                [
                    "monthlyRequestQuota".to_string(),
                    monthly_request_quota.to_string(),
                ].join(",")
            }),


            self.cost_per_request.as_ref().map(|cost_per_request| {
                [
                    "costPerRequest".to_string(),
                    cost_per_request.to_string(),
                ].join(",")
            }),


            self.billing_tier.as_ref().map(|billing_tier| {
                [
                    "billingTier".to_string(),
                    billing_tier.to_string(),
                ].join(",")
            }),


            self.total_requests.as_ref().map(|total_requests| {
                [
                    "totalRequests".to_string(),
                    total_requests.to_string(),
                ].join(",")
            }),


            self.total_errors.as_ref().map(|total_errors| {
                [
                    "totalErrors".to_string(),
                    total_errors.to_string(),
                ].join(",")
            }),

            // Skipping lastUsedAt in query parameter serialization


            self.average_response_time.as_ref().map(|average_response_time| {
                [
                    "averageResponseTime".to_string(),
                    average_response_time.to_string(),
                ].join(",")
            }),

            // Skipping endpointUsageJson in query parameter serialization
            // Skipping endpointUsageJson in query parameter serialization

            // Skipping errorRatesJson in query parameter serialization
            // Skipping errorRatesJson in query parameter serialization

            // Skipping recentErrors in query parameter serialization
            // Skipping recentErrors in query parameter serialization


            self.successful_requests_count.as_ref().map(|successful_requests_count| {
                [
                    "successfulRequestsCount".to_string(),
                    successful_requests_count.to_string(),
                ].join(",")
            }),


            self.success_rate.as_ref().map(|success_rate| {
                [
                    "successRate".to_string(),
                    success_rate.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping expiresAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping lastRotatedAt in query parameter serialization

            // Skipping lastSecurityReviewAt in query parameter serialization


            self.requires_client_secret.as_ref().map(|requires_client_secret| {
                [
                    "requiresClientSecret".to_string(),
                    requires_client_secret.to_string(),
                ].join(",")
            }),


            self.client_secret_hash.as_ref().map(|client_secret_hash| {
                [
                    "clientSecretHash".to_string(),
                    client_secret_hash.to_string(),
                ].join(",")
            }),


            self.enforce_https.as_ref().map(|enforce_https| {
                [
                    "enforceHttps".to_string(),
                    enforce_https.to_string(),
                ].join(",")
            }),


            self.enforce_signing.as_ref().map(|enforce_signing| {
                [
                    "enforceSigning".to_string(),
                    enforce_signing.to_string(),
                ].join(",")
            }),


            self.allowed_signature_algorithms.as_ref().map(|allowed_signature_algorithms| {
                [
                    "allowedSignatureAlgorithms".to_string(),
                    allowed_signature_algorithms.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.enforce_mutual_tls.as_ref().map(|enforce_mutual_tls| {
                [
                    "enforceMutualTls".to_string(),
                    enforce_mutual_tls.to_string(),
                ].join(",")
            }),


            self.client_certificate_hash.as_ref().map(|client_certificate_hash| {
                [
                    "clientCertificateHash".to_string(),
                    client_certificate_hash.to_string(),
                ].join(",")
            }),


            self.require_request_signing.as_ref().map(|require_request_signing| {
                [
                    "requireRequestSigning".to_string(),
                    require_request_signing.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping metadataJson in query parameter serialization
            // Skipping metadataJson in query parameter serialization


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.api_version.as_ref().map(|api_version| {
                [
                    "apiVersion".to_string(),
                    api_version.to_string(),
                ].join(",")
            }),


            self.supported_features.as_ref().map(|supported_features| {
                [
                    "supportedFeatures".to_string(),
                    supported_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.documentation_url.as_ref().map(|documentation_url| {
                [
                    "documentationUrl".to_string(),
                    documentation_url.to_string(),
                ].join(",")
            }),


            self.support_contact.as_ref().map(|support_contact| {
                [
                    "supportContact".to_string(),
                    support_contact.to_string(),
                ].join(",")
            }),

            // Skipping account in query parameter serialization

            // Skipping workspace in query parameter serialization


            self.log_all_requests.as_ref().map(|log_all_requests| {
                [
                    "logAllRequests".to_string(),
                    log_all_requests.to_string(),
                ].join(",")
            }),


            self.last_rotation_reason.as_ref().map(|last_rotation_reason| {
                [
                    "lastRotationReason".to_string(),
                    last_rotation_reason.to_string(),
                ].join(",")
            }),

            // Skipping lastRotationDate in query parameter serialization


            self.rotation_frequency_days.as_ref().map(|rotation_frequency_days| {
                [
                    "rotationFrequencyDays".to_string(),
                    rotation_frequency_days.to_string(),
                ].join(",")
            }),


            self.compliance_standards.as_ref().map(|compliance_standards| {
                [
                    "complianceStandards".to_string(),
                    compliance_standards.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.requires_audit_logging.as_ref().map(|requires_audit_logging| {
                [
                    "requiresAuditLogging".to_string(),
                    requires_audit_logging.to_string(),
                ].join(",")
            }),


            self.data_residency.as_ref().map(|data_residency| {
                [
                    "dataResidency".to_string(),
                    data_residency.to_string(),
                ].join(",")
            }),


            self.approved_integrations.as_ref().map(|approved_integrations| {
                [
                    "approvedIntegrations".to_string(),
                    approved_integrations.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.alert_emails.as_ref().map(|alert_emails| {
                [
                    "alertEmails".to_string(),
                    alert_emails.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.webhook_url.as_ref().map(|webhook_url| {
                [
                    "webhookUrl".to_string(),
                    webhook_url.to_string(),
                ].join(",")
            }),


            self.alert_on_quota_threshold.as_ref().map(|alert_on_quota_threshold| {
                [
                    "alertOnQuotaThreshold".to_string(),
                    alert_on_quota_threshold.to_string(),
                ].join(",")
            }),


            self.quota_alert_threshold.as_ref().map(|quota_alert_threshold| {
                [
                    "quotaAlertThreshold".to_string(),
                    quota_alert_threshold.to_string(),
                ].join(",")
            }),


            self.alert_on_error_spike.as_ref().map(|alert_on_error_spike| {
                [
                    "alertOnErrorSpike".to_string(),
                    alert_on_error_spike.to_string(),
                ].join(",")
            }),


            self.error_alert_threshold.as_ref().map(|error_alert_threshold| {
                [
                    "errorAlertThreshold".to_string(),
                    error_alert_threshold.to_string(),
                ].join(",")
            }),


            self.monitoring_integrations.as_ref().map(|monitoring_integrations| {
                [
                    "monitoringIntegrations".to_string(),
                    monitoring_integrations.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.encrypted.as_ref().map(|encrypted| {
                [
                    "encrypted".to_string(),
                    encrypted.to_string(),
                ].join(",")
            }),


            self.data_classification.as_ref().map(|data_classification| {
                [
                    "dataClassification".to_string(),
                    data_classification.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub key_hash: Vec<String>,
            pub key_prefix: Vec<String>,
            pub org_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub scopes: Vec<Vec<String>>,
            pub allowed_ips: Vec<Vec<String>>,
            pub allowed_domains: Vec<Vec<String>>,
            pub allowed_environments: Vec<Vec<String>>,
            pub is_test_key: Vec<bool>,
            pub requests_per_second: Vec<i32>,
            pub requests_per_day: Vec<i32>,
            pub concurrent_requests: Vec<i32>,
            pub monthly_request_quota: Vec<String>,
            pub cost_per_request: Vec<f32>,
            pub billing_tier: Vec<String>,
            pub total_requests: Vec<String>,
            pub total_errors: Vec<String>,
            pub last_used_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub average_response_time: Vec<f32>,
            pub endpoint_usage_json: Vec<swagger::ByteArray>,
            pub error_rates_json: Vec<swagger::ByteArray>,
            pub recent_errors: Vec<swagger::ByteArray>,
            pub successful_requests_count: Vec<i32>,
            pub success_rate: Vec<f32>,
            pub status: Vec<models::V1PeriodStatus>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_rotated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_security_review_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub requires_client_secret: Vec<bool>,
            pub client_secret_hash: Vec<String>,
            pub enforce_https: Vec<bool>,
            pub enforce_signing: Vec<bool>,
            pub allowed_signature_algorithms: Vec<Vec<String>>,
            pub enforce_mutual_tls: Vec<bool>,
            pub client_certificate_hash: Vec<String>,
            pub require_request_signing: Vec<bool>,
            pub description: Vec<String>,
            pub metadata_json: Vec<swagger::ByteArray>,
            pub tags: Vec<Vec<String>>,
            pub api_version: Vec<String>,
            pub supported_features: Vec<Vec<String>>,
            pub documentation_url: Vec<String>,
            pub support_contact: Vec<String>,
            pub account: Vec<models::Account>,
            pub workspace: Vec<models::Workspace>,
            pub log_all_requests: Vec<bool>,
            pub last_rotation_reason: Vec<String>,
            pub last_rotation_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub rotation_frequency_days: Vec<i32>,
            pub compliance_standards: Vec<Vec<String>>,
            pub requires_audit_logging: Vec<bool>,
            pub data_residency: Vec<String>,
            pub approved_integrations: Vec<Vec<String>>,
            pub alert_emails: Vec<Vec<String>>,
            pub webhook_url: Vec<String>,
            pub alert_on_quota_threshold: Vec<bool>,
            pub quota_alert_threshold: Vec<f32>,
            pub alert_on_error_spike: Vec<bool>,
            pub error_alert_threshold: Vec<f32>,
            pub monitoring_integrations: Vec<Vec<String>>,
            pub encrypted: Vec<bool>,
            pub data_classification: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyHash" => intermediate_rep.key_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyPrefix" => intermediate_rep.key_prefix.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orgId" => intermediate_rep.org_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "scopes" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    "allowedIps" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    "allowedDomains" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    "allowedEnvironments" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isTestKey" => intermediate_rep.is_test_key.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requestsPerSecond" => intermediate_rep.requests_per_second.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requestsPerDay" => intermediate_rep.requests_per_day.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "concurrentRequests" => intermediate_rep.concurrent_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "monthlyRequestQuota" => intermediate_rep.monthly_request_quota.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "costPerRequest" => intermediate_rep.cost_per_request.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billingTier" => intermediate_rep.billing_tier.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalRequests" => intermediate_rep.total_requests.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalErrors" => intermediate_rep.total_errors.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUsedAt" => intermediate_rep.last_used_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageResponseTime" => intermediate_rep.average_response_time.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "endpointUsageJson" => return std::result::Result::Err("Parsing binary data in this style is not supported in ApiKey".to_string()),
                    "errorRatesJson" => return std::result::Result::Err("Parsing binary data in this style is not supported in ApiKey".to_string()),
                    "recentErrors" => return std::result::Result::Err("Parsing binary data in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "successfulRequestsCount" => intermediate_rep.successful_requests_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "successRate" => intermediate_rep.success_rate.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::V1PeriodStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastRotatedAt" => intermediate_rep.last_rotated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastSecurityReviewAt" => intermediate_rep.last_security_review_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requiresClientSecret" => intermediate_rep.requires_client_secret.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientSecretHash" => intermediate_rep.client_secret_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enforceHttps" => intermediate_rep.enforce_https.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enforceSigning" => intermediate_rep.enforce_signing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedSignatureAlgorithms" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "enforceMutualTls" => intermediate_rep.enforce_mutual_tls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientCertificateHash" => intermediate_rep.client_certificate_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requireRequestSigning" => intermediate_rep.require_request_signing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadataJson" => return std::result::Result::Err("Parsing binary data in this style is not supported in ApiKey".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "apiVersion" => intermediate_rep.api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supportedFeatures" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "documentationUrl" => intermediate_rep.documentation_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportContact" => intermediate_rep.support_contact.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logAllRequests" => intermediate_rep.log_all_requests.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastRotationReason" => intermediate_rep.last_rotation_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastRotationDate" => intermediate_rep.last_rotation_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rotationFrequencyDays" => intermediate_rep.rotation_frequency_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "complianceStandards" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "requiresAuditLogging" => intermediate_rep.requires_audit_logging.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataResidency" => intermediate_rep.data_residency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "approvedIntegrations" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    "alertEmails" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "webhookUrl" => intermediate_rep.webhook_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "alertOnQuotaThreshold" => intermediate_rep.alert_on_quota_threshold.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quotaAlertThreshold" => intermediate_rep.quota_alert_threshold.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "alertOnErrorSpike" => intermediate_rep.alert_on_error_spike.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorAlertThreshold" => intermediate_rep.error_alert_threshold.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "monitoringIntegrations" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "encrypted" => intermediate_rep.encrypted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataClassification" => intermediate_rep.data_classification.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiKey {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            key_hash: intermediate_rep.key_hash.into_iter().next(),
            key_prefix: intermediate_rep.key_prefix.into_iter().next(),
            org_id: intermediate_rep.org_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
            allowed_ips: intermediate_rep.allowed_ips.into_iter().next(),
            allowed_domains: intermediate_rep.allowed_domains.into_iter().next(),
            allowed_environments: intermediate_rep.allowed_environments.into_iter().next(),
            is_test_key: intermediate_rep.is_test_key.into_iter().next(),
            requests_per_second: intermediate_rep.requests_per_second.into_iter().next(),
            requests_per_day: intermediate_rep.requests_per_day.into_iter().next(),
            concurrent_requests: intermediate_rep.concurrent_requests.into_iter().next(),
            monthly_request_quota: intermediate_rep.monthly_request_quota.into_iter().next(),
            cost_per_request: intermediate_rep.cost_per_request.into_iter().next(),
            billing_tier: intermediate_rep.billing_tier.into_iter().next(),
            total_requests: intermediate_rep.total_requests.into_iter().next(),
            total_errors: intermediate_rep.total_errors.into_iter().next(),
            last_used_at: intermediate_rep.last_used_at.into_iter().next(),
            average_response_time: intermediate_rep.average_response_time.into_iter().next(),
            endpoint_usage_json: intermediate_rep.endpoint_usage_json.into_iter().next(),
            error_rates_json: intermediate_rep.error_rates_json.into_iter().next(),
            recent_errors: intermediate_rep.recent_errors.into_iter().next(),
            successful_requests_count: intermediate_rep.successful_requests_count.into_iter().next(),
            success_rate: intermediate_rep.success_rate.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            last_rotated_at: intermediate_rep.last_rotated_at.into_iter().next(),
            last_security_review_at: intermediate_rep.last_security_review_at.into_iter().next(),
            requires_client_secret: intermediate_rep.requires_client_secret.into_iter().next(),
            client_secret_hash: intermediate_rep.client_secret_hash.into_iter().next(),
            enforce_https: intermediate_rep.enforce_https.into_iter().next(),
            enforce_signing: intermediate_rep.enforce_signing.into_iter().next(),
            allowed_signature_algorithms: intermediate_rep.allowed_signature_algorithms.into_iter().next(),
            enforce_mutual_tls: intermediate_rep.enforce_mutual_tls.into_iter().next(),
            client_certificate_hash: intermediate_rep.client_certificate_hash.into_iter().next(),
            require_request_signing: intermediate_rep.require_request_signing.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            metadata_json: intermediate_rep.metadata_json.into_iter().next(),
            tags: intermediate_rep.tags.into_iter().next(),
            api_version: intermediate_rep.api_version.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            documentation_url: intermediate_rep.documentation_url.into_iter().next(),
            support_contact: intermediate_rep.support_contact.into_iter().next(),
            account: intermediate_rep.account.into_iter().next(),
            workspace: intermediate_rep.workspace.into_iter().next(),
            log_all_requests: intermediate_rep.log_all_requests.into_iter().next(),
            last_rotation_reason: intermediate_rep.last_rotation_reason.into_iter().next(),
            last_rotation_date: intermediate_rep.last_rotation_date.into_iter().next(),
            rotation_frequency_days: intermediate_rep.rotation_frequency_days.into_iter().next(),
            compliance_standards: intermediate_rep.compliance_standards.into_iter().next(),
            requires_audit_logging: intermediate_rep.requires_audit_logging.into_iter().next(),
            data_residency: intermediate_rep.data_residency.into_iter().next(),
            approved_integrations: intermediate_rep.approved_integrations.into_iter().next(),
            alert_emails: intermediate_rep.alert_emails.into_iter().next(),
            webhook_url: intermediate_rep.webhook_url.into_iter().next(),
            alert_on_quota_threshold: intermediate_rep.alert_on_quota_threshold.into_iter().next(),
            quota_alert_threshold: intermediate_rep.quota_alert_threshold.into_iter().next(),
            alert_on_error_spike: intermediate_rep.alert_on_error_spike.into_iter().next(),
            error_alert_threshold: intermediate_rep.error_alert_threshold.into_iter().next(),
            monitoring_integrations: intermediate_rep.monitoring_integrations.into_iter().next(),
            encrypted: intermediate_rep.encrypted.into_iter().next(),
            data_classification: intermediate_rep.data_classification.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiKey> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiKey>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiKey - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiKey> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiKey - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppAnalytics {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "metricName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metric_name: Option<String>,

    #[serde(rename = "metricValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metric_value: Option<f32>,

    #[serde(rename = "dimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dimensions: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "recordedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recorded_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppAnalytics {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppAnalytics {
        AppAnalytics {
            id: None,
            app_id: None,
            metric_name: None,
            metric_value: None,
            dimensions: None,
            recorded_at: None,
        }
    }
}

/// Converts the AppAnalytics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppAnalytics {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.metric_name.as_ref().map(|metric_name| {
                [
                    "metricName".to_string(),
                    metric_name.to_string(),
                ].join(",")
            }),


            self.metric_value.as_ref().map(|metric_value| {
                [
                    "metricValue".to_string(),
                    metric_value.to_string(),
                ].join(",")
            }),

            // Skipping dimensions in query parameter serialization

            // Skipping recordedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppAnalytics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppAnalytics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub metric_name: Vec<String>,
            pub metric_value: Vec<f32>,
            pub dimensions: Vec<std::collections::HashMap<String, String>>,
            pub recorded_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppAnalytics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metricName" => intermediate_rep.metric_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metricValue" => intermediate_rep.metric_value.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dimensions" => return std::result::Result::Err("Parsing a container in this style is not supported in AppAnalytics".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "recordedAt" => intermediate_rep.recorded_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppAnalytics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppAnalytics {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            metric_name: intermediate_rep.metric_name.into_iter().next(),
            metric_value: intermediate_rep.metric_value.into_iter().next(),
            dimensions: intermediate_rep.dimensions.into_iter().next(),
            recorded_at: intermediate_rep.recorded_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppAnalytics> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppAnalytics>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppAnalytics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppAnalytics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppAnalytics> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppAnalytics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppAnalytics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AppCategory {
    #[serde(rename = "APP_CATEGORY_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "APP_CATEGORY_CONTRACT_AUTOMATION")]
    ContractAutomation,
    #[serde(rename = "APP_CATEGORY_CONTRACT_ANALYSIS")]
    ContractAnalysis,
    #[serde(rename = "APP_CATEGORY_INTEGRATION")]
    Integration,
    #[serde(rename = "APP_CATEGORY_AI_POWERED")]
    AiPowered,
    #[serde(rename = "APP_CATEGORY_WORKFLOW")]
    Workflow,
    #[serde(rename = "APP_CATEGORY_COMPLIANCE")]
    Compliance,
}

impl std::fmt::Display for AppCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AppCategory::Unspecified => write!(f, "APP_CATEGORY_UNSPECIFIED"),
            AppCategory::ContractAutomation => write!(f, "APP_CATEGORY_CONTRACT_AUTOMATION"),
            AppCategory::ContractAnalysis => write!(f, "APP_CATEGORY_CONTRACT_ANALYSIS"),
            AppCategory::Integration => write!(f, "APP_CATEGORY_INTEGRATION"),
            AppCategory::AiPowered => write!(f, "APP_CATEGORY_AI_POWERED"),
            AppCategory::Workflow => write!(f, "APP_CATEGORY_WORKFLOW"),
            AppCategory::Compliance => write!(f, "APP_CATEGORY_COMPLIANCE"),
        }
    }
}

impl std::str::FromStr for AppCategory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "APP_CATEGORY_UNSPECIFIED" => std::result::Result::Ok(AppCategory::Unspecified),
            "APP_CATEGORY_CONTRACT_AUTOMATION" => std::result::Result::Ok(AppCategory::ContractAutomation),
            "APP_CATEGORY_CONTRACT_ANALYSIS" => std::result::Result::Ok(AppCategory::ContractAnalysis),
            "APP_CATEGORY_INTEGRATION" => std::result::Result::Ok(AppCategory::Integration),
            "APP_CATEGORY_AI_POWERED" => std::result::Result::Ok(AppCategory::AiPowered),
            "APP_CATEGORY_WORKFLOW" => std::result::Result::Ok(AppCategory::Workflow),
            "APP_CATEGORY_COMPLIANCE" => std::result::Result::Ok(AppCategory::Compliance),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppDevelopmentInfo {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "supportedLanguages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_languages: Option<Vec<String>>,

    #[serde(rename = "sdkFeatures")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sdk_features: Option<Vec<String>>,

    #[serde(rename = "testCoverage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub test_coverage: Option<std::collections::HashMap<String, f32>>,

    #[serde(rename = "securityScans")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_scans: Option<Vec<String>>,

    #[serde(rename = "performanceMetrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub performance_metrics: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "developmentStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub development_status: Option<String>,

    #[serde(rename = "knownIssues")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub known_issues: Option<Vec<String>>,

    #[serde(rename = "roadmapUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub roadmap_url: Option<String>,

    #[serde(rename = "lastSecurityAudit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_security_audit: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppDevelopmentInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppDevelopmentInfo {
        AppDevelopmentInfo {
            id: None,
            app_id: None,
            supported_languages: None,
            sdk_features: None,
            test_coverage: None,
            security_scans: None,
            performance_metrics: None,
            development_status: None,
            known_issues: None,
            roadmap_url: None,
            last_security_audit: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the AppDevelopmentInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppDevelopmentInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.supported_languages.as_ref().map(|supported_languages| {
                [
                    "supportedLanguages".to_string(),
                    supported_languages.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.sdk_features.as_ref().map(|sdk_features| {
                [
                    "sdkFeatures".to_string(),
                    sdk_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping testCoverage in query parameter serialization


            self.security_scans.as_ref().map(|security_scans| {
                [
                    "securityScans".to_string(),
                    security_scans.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping performanceMetrics in query parameter serialization


            self.development_status.as_ref().map(|development_status| {
                [
                    "developmentStatus".to_string(),
                    development_status.to_string(),
                ].join(",")
            }),


            self.known_issues.as_ref().map(|known_issues| {
                [
                    "knownIssues".to_string(),
                    known_issues.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.roadmap_url.as_ref().map(|roadmap_url| {
                [
                    "roadmapUrl".to_string(),
                    roadmap_url.to_string(),
                ].join(",")
            }),

            // Skipping lastSecurityAudit in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppDevelopmentInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppDevelopmentInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub supported_languages: Vec<Vec<String>>,
            pub sdk_features: Vec<Vec<String>>,
            pub test_coverage: Vec<std::collections::HashMap<String, f32>>,
            pub security_scans: Vec<Vec<String>>,
            pub performance_metrics: Vec<std::collections::HashMap<String, String>>,
            pub development_status: Vec<String>,
            pub known_issues: Vec<Vec<String>>,
            pub roadmap_url: Vec<String>,
            pub last_security_audit: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppDevelopmentInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supportedLanguages" => return std::result::Result::Err("Parsing a container in this style is not supported in AppDevelopmentInfo".to_string()),
                    "sdkFeatures" => return std::result::Result::Err("Parsing a container in this style is not supported in AppDevelopmentInfo".to_string()),
                    "testCoverage" => return std::result::Result::Err("Parsing a container in this style is not supported in AppDevelopmentInfo".to_string()),
                    "securityScans" => return std::result::Result::Err("Parsing a container in this style is not supported in AppDevelopmentInfo".to_string()),
                    "performanceMetrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AppDevelopmentInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "developmentStatus" => intermediate_rep.development_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "knownIssues" => return std::result::Result::Err("Parsing a container in this style is not supported in AppDevelopmentInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "roadmapUrl" => intermediate_rep.roadmap_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastSecurityAudit" => intermediate_rep.last_security_audit.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppDevelopmentInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppDevelopmentInfo {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            supported_languages: intermediate_rep.supported_languages.into_iter().next(),
            sdk_features: intermediate_rep.sdk_features.into_iter().next(),
            test_coverage: intermediate_rep.test_coverage.into_iter().next(),
            security_scans: intermediate_rep.security_scans.into_iter().next(),
            performance_metrics: intermediate_rep.performance_metrics.into_iter().next(),
            development_status: intermediate_rep.development_status.into_iter().next(),
            known_issues: intermediate_rep.known_issues.into_iter().next(),
            roadmap_url: intermediate_rep.roadmap_url.into_iter().next(),
            last_security_audit: intermediate_rep.last_security_audit.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppDevelopmentInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppDevelopmentInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppDevelopmentInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppDevelopmentInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppDevelopmentInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppDevelopmentInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppDevelopmentInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppInstallation {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "workspaceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace_id: Option<String>,

    #[serde(rename = "versionInstalled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_installed: Option<String>,

    #[serde(rename = "configuration")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub configuration: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "installationStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_status: Option<String>,

    #[serde(rename = "installedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub installed_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastUsed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_used: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppInstallation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppInstallation {
        AppInstallation {
            id: None,
            app_id: None,
            workspace_id: None,
            version_installed: None,
            configuration: None,
            installation_status: None,
            installed_at: None,
            last_used: None,
        }
    }
}

/// Converts the AppInstallation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppInstallation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.workspace_id.as_ref().map(|workspace_id| {
                [
                    "workspaceId".to_string(),
                    workspace_id.to_string(),
                ].join(",")
            }),


            self.version_installed.as_ref().map(|version_installed| {
                [
                    "versionInstalled".to_string(),
                    version_installed.to_string(),
                ].join(",")
            }),

            // Skipping configuration in query parameter serialization


            self.installation_status.as_ref().map(|installation_status| {
                [
                    "installationStatus".to_string(),
                    installation_status.to_string(),
                ].join(",")
            }),

            // Skipping installedAt in query parameter serialization

            // Skipping lastUsed in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppInstallation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppInstallation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub workspace_id: Vec<String>,
            pub version_installed: Vec<String>,
            pub configuration: Vec<std::collections::HashMap<String, String>>,
            pub installation_status: Vec<String>,
            pub installed_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_used: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppInstallation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspaceId" => intermediate_rep.workspace_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "versionInstalled" => intermediate_rep.version_installed.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "configuration" => return std::result::Result::Err("Parsing a container in this style is not supported in AppInstallation".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "installationStatus" => intermediate_rep.installation_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "installedAt" => intermediate_rep.installed_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUsed" => intermediate_rep.last_used.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppInstallation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppInstallation {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            workspace_id: intermediate_rep.workspace_id.into_iter().next(),
            version_installed: intermediate_rep.version_installed.into_iter().next(),
            configuration: intermediate_rep.configuration.into_iter().next(),
            installation_status: intermediate_rep.installation_status.into_iter().next(),
            installed_at: intermediate_rep.installed_at.into_iter().next(),
            last_used: intermediate_rep.last_used.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppInstallation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppInstallation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppInstallation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppInstallation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppInstallation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppInstallation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppInstallation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppPermission {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "isRequired")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_required: Option<bool>,

    #[serde(rename = "accessLevels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_levels: Option<Vec<String>>,

    #[serde(rename = "constraints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub constraints: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "requiresApproval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requires_approval: Option<bool>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppPermission {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppPermission {
        AppPermission {
            id: None,
            app_id: None,
            scope: None,
            description: None,
            is_required: None,
            access_levels: None,
            constraints: None,
            requires_approval: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the AppPermission value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppPermission {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.scope.as_ref().map(|scope| {
                [
                    "scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.is_required.as_ref().map(|is_required| {
                [
                    "isRequired".to_string(),
                    is_required.to_string(),
                ].join(",")
            }),


            self.access_levels.as_ref().map(|access_levels| {
                [
                    "accessLevels".to_string(),
                    access_levels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping constraints in query parameter serialization


            self.requires_approval.as_ref().map(|requires_approval| {
                [
                    "requiresApproval".to_string(),
                    requires_approval.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppPermission value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppPermission {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub scope: Vec<String>,
            pub description: Vec<String>,
            pub is_required: Vec<bool>,
            pub access_levels: Vec<Vec<String>>,
            pub constraints: Vec<std::collections::HashMap<String, String>>,
            pub requires_approval: Vec<bool>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppPermission".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isRequired" => intermediate_rep.is_required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "accessLevels" => return std::result::Result::Err("Parsing a container in this style is not supported in AppPermission".to_string()),
                    "constraints" => return std::result::Result::Err("Parsing a container in this style is not supported in AppPermission".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "requiresApproval" => intermediate_rep.requires_approval.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppPermission".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppPermission {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            scope: intermediate_rep.scope.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            is_required: intermediate_rep.is_required.into_iter().next(),
            access_levels: intermediate_rep.access_levels.into_iter().next(),
            constraints: intermediate_rep.constraints.into_iter().next(),
            requires_approval: intermediate_rep.requires_approval.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppPermission> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppPermission>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppPermission>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppPermission - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppPermission> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppPermission as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppPermission - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppReview {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "reviewerId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer_id: Option<String>,

    #[serde(rename = "rating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating: Option<f32>,

    #[serde(rename = "reviewText")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_text: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppReview {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppReview {
        AppReview {
            id: None,
            app_id: None,
            reviewer_id: None,
            rating: None,
            review_text: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the AppReview value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppReview {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.reviewer_id.as_ref().map(|reviewer_id| {
                [
                    "reviewerId".to_string(),
                    reviewer_id.to_string(),
                ].join(",")
            }),


            self.rating.as_ref().map(|rating| {
                [
                    "rating".to_string(),
                    rating.to_string(),
                ].join(",")
            }),


            self.review_text.as_ref().map(|review_text| {
                [
                    "reviewText".to_string(),
                    review_text.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppReview value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppReview {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub reviewer_id: Vec<String>,
            pub rating: Vec<f32>,
            pub review_text: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppReview".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reviewerId" => intermediate_rep.reviewer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep.rating.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reviewText" => intermediate_rep.review_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppReview".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppReview {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            reviewer_id: intermediate_rep.reviewer_id.into_iter().next(),
            rating: intermediate_rep.rating.into_iter().next(),
            review_text: intermediate_rep.review_text.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppReview> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppReview>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppReview>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppReview - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppReview> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppReview as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppReview - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppVersion {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "versionNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_number: Option<String>,

    #[serde(rename = "changelog")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changelog: Option<String>,

    #[serde(rename = "requirements")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requirements: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "isPublic")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_public: Option<bool>,

    #[serde(rename = "releaseDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub release_date: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppVersion {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppVersion {
        AppVersion {
            id: None,
            app_id: None,
            version_number: None,
            changelog: None,
            requirements: None,
            is_public: None,
            release_date: None,
        }
    }
}

/// Converts the AppVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppVersion {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.version_number.as_ref().map(|version_number| {
                [
                    "versionNumber".to_string(),
                    version_number.to_string(),
                ].join(",")
            }),


            self.changelog.as_ref().map(|changelog| {
                [
                    "changelog".to_string(),
                    changelog.to_string(),
                ].join(",")
            }),

            // Skipping requirements in query parameter serialization


            self.is_public.as_ref().map(|is_public| {
                [
                    "isPublic".to_string(),
                    is_public.to_string(),
                ].join(",")
            }),

            // Skipping releaseDate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub version_number: Vec<String>,
            pub changelog: Vec<String>,
            pub requirements: Vec<std::collections::HashMap<String, String>>,
            pub is_public: Vec<bool>,
            pub release_date: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "versionNumber" => intermediate_rep.version_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changelog" => intermediate_rep.changelog.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "requirements" => return std::result::Result::Err("Parsing a container in this style is not supported in AppVersion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isPublic" => intermediate_rep.is_public.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "releaseDate" => intermediate_rep.release_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppVersion {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            version_number: intermediate_rep.version_number.into_iter().next(),
            changelog: intermediate_rep.changelog.into_iter().next(),
            requirements: intermediate_rep.requirements.into_iter().next(),
            is_public: intermediate_rep.is_public.into_iter().next(),
            release_date: intermediate_rep.release_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppVersion> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppVersion>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppVersion> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppWebhook {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<String>,

    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

    #[serde(rename = "subscribedEvents")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribed_events: Option<Vec<String>>,

    #[serde(rename = "secretKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_key: Option<String>,

    #[serde(rename = "retryCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retry_count: Option<i32>,

    #[serde(rename = "timeoutSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout_seconds: Option<i32>,

    #[serde(rename = "isActive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_active: Option<bool>,

    #[serde(rename = "headers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub headers: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "lastTriggered")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_triggered: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl AppWebhook {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppWebhook {
        AppWebhook {
            id: None,
            app_id: None,
            url: None,
            subscribed_events: None,
            secret_key: None,
            retry_count: None,
            timeout_seconds: None,
            is_active: None,
            headers: None,
            last_triggered: None,
            created_at: None,
        }
    }
}

/// Converts the AppWebhook value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppWebhook {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.app_id.as_ref().map(|app_id| {
                [
                    "appId".to_string(),
                    app_id.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),


            self.subscribed_events.as_ref().map(|subscribed_events| {
                [
                    "subscribedEvents".to_string(),
                    subscribed_events.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.secret_key.as_ref().map(|secret_key| {
                [
                    "secretKey".to_string(),
                    secret_key.to_string(),
                ].join(",")
            }),


            self.retry_count.as_ref().map(|retry_count| {
                [
                    "retryCount".to_string(),
                    retry_count.to_string(),
                ].join(",")
            }),


            self.timeout_seconds.as_ref().map(|timeout_seconds| {
                [
                    "timeoutSeconds".to_string(),
                    timeout_seconds.to_string(),
                ].join(",")
            }),


            self.is_active.as_ref().map(|is_active| {
                [
                    "isActive".to_string(),
                    is_active.to_string(),
                ].join(",")
            }),

            // Skipping headers in query parameter serialization

            // Skipping lastTriggered in query parameter serialization

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppWebhook value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppWebhook {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub app_id: Vec<String>,
            pub url: Vec<String>,
            pub subscribed_events: Vec<Vec<String>>,
            pub secret_key: Vec<String>,
            pub retry_count: Vec<i32>,
            pub timeout_seconds: Vec<i32>,
            pub is_active: Vec<bool>,
            pub headers: Vec<std::collections::HashMap<String, String>>,
            pub last_triggered: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppWebhook".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subscribedEvents" => return std::result::Result::Err("Parsing a container in this style is not supported in AppWebhook".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "secretKey" => intermediate_rep.secret_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retryCount" => intermediate_rep.retry_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeoutSeconds" => intermediate_rep.timeout_seconds.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isActive" => intermediate_rep.is_active.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "headers" => return std::result::Result::Err("Parsing a container in this style is not supported in AppWebhook".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "lastTriggered" => intermediate_rep.last_triggered.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppWebhook".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppWebhook {
            id: intermediate_rep.id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            subscribed_events: intermediate_rep.subscribed_events.into_iter().next(),
            secret_key: intermediate_rep.secret_key.into_iter().next(),
            retry_count: intermediate_rep.retry_count.into_iter().next(),
            timeout_seconds: intermediate_rep.timeout_seconds.into_iter().next(),
            is_active: intermediate_rep.is_active.into_iter().next(),
            headers: intermediate_rep.headers.into_iter().next(),
            last_triggered: intermediate_rep.last_triggered.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppWebhook> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppWebhook>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppWebhook>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppWebhook - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppWebhook> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppWebhook as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppWebhook - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthContext {
    #[serde(rename = "requiredScopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_scopes: Option<Vec<String>>,

    #[serde(rename = "providedScopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub provided_scopes: Option<Vec<String>>,

    #[serde(rename = "missingPermissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub missing_permissions: Option<Vec<String>>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

}


impl AuthContext {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AuthContext {
        AuthContext {
            required_scopes: None,
            provided_scopes: None,
            missing_permissions: None,
            tenant_id: None,
        }
    }
}

/// Converts the AuthContext value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthContext {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.required_scopes.as_ref().map(|required_scopes| {
                [
                    "requiredScopes".to_string(),
                    required_scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.provided_scopes.as_ref().map(|provided_scopes| {
                [
                    "providedScopes".to_string(),
                    provided_scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.missing_permissions.as_ref().map(|missing_permissions| {
                [
                    "missingPermissions".to_string(),
                    missing_permissions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthContext value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthContext {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub required_scopes: Vec<Vec<String>>,
            pub provided_scopes: Vec<Vec<String>>,
            pub missing_permissions: Vec<Vec<String>>,
            pub tenant_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthContext".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "requiredScopes" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthContext".to_string()),
                    "providedScopes" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthContext".to_string()),
                    "missingPermissions" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthContext".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthContext".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthContext {
            required_scopes: intermediate_rep.required_scopes.into_iter().next(),
            provided_scopes: intermediate_rep.provided_scopes.into_iter().next(),
            missing_permissions: intermediate_rep.missing_permissions.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthContext> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthContext>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthContext>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthContext - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AuthContext> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthContext as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthContext - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// - AUTH_FAILED_INVALID_BEARER_TOKEN: Authentication errors  - SESSION_EXPIRED: Session errors  - UNAUTHENTICATED: Other authentication errors  - ACCOUNT_LOCKED: New authentication error codes  Account is locked due to too many failed login attempts  - ACCOUNT_DISABLED: Account has been disabled by admin  - PASSWORD_EXPIRED: Password has expired and must be changed  - PASSWORD_RESET_REQUIRED: Password reset is required  - UNRECOGNIZED_DEVICE: Login attempt from an unrecognized device
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AuthErrorCode {
    #[serde(rename = "NO_AUTH_ERROR")]
    NoAuthError,
    #[serde(rename = "AUTH_FAILED_INVALID_BEARER_TOKEN")]
    AuthFailedInvalidBearerToken,
    #[serde(rename = "AUTH_FAILED_INVALID_SUBJECT")]
    AuthFailedInvalidSubject,
    #[serde(rename = "AUTH_FAILED_INVALID_AUDIENCE")]
    AuthFailedInvalidAudience,
    #[serde(rename = "AUTH_FAILED_INVALID_ISSUER")]
    AuthFailedInvalidIssuer,
    #[serde(rename = "BEARER_TOKEN_MISSING")]
    BearerTokenMissing,
    #[serde(rename = "TOKEN_EXPIRED")]
    TokenExpired,
    #[serde(rename = "TOKEN_NOT_ACTIVE")]
    TokenNotActive,
    #[serde(rename = "TOKEN_REVOKED")]
    TokenRevoked,
    #[serde(rename = "INVALID_CLAIMS")]
    InvalidClaims,
    #[serde(rename = "MISSING_REQUIRED_CLAIMS")]
    MissingRequiredClaims,
    #[serde(rename = "INVALID_SCOPE")]
    InvalidScope,
    #[serde(rename = "INVALID_PERMISSIONS")]
    InvalidPermissions,
    #[serde(rename = "SESSION_EXPIRED")]
    SessionExpired,
    #[serde(rename = "SESSION_INVALID")]
    SessionInvalid,
    #[serde(rename = "SESSION_REVOKED")]
    SessionRevoked,
    #[serde(rename = "UNAUTHENTICATED")]
    Unauthenticated,
    #[serde(rename = "MULTI_FACTOR_REQUIRED")]
    MultiFactorRequired,
    #[serde(rename = "MULTI_FACTOR_FAILED")]
    MultiFactorFailed,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_DISABLED")]
    AccountDisabled,
    #[serde(rename = "PASSWORD_EXPIRED")]
    PasswordExpired,
    #[serde(rename = "PASSWORD_RESET_REQUIRED")]
    PasswordResetRequired,
    #[serde(rename = "UNRECOGNIZED_DEVICE")]
    UnrecognizedDevice,
}

impl std::fmt::Display for AuthErrorCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AuthErrorCode::NoAuthError => write!(f, "NO_AUTH_ERROR"),
            AuthErrorCode::AuthFailedInvalidBearerToken => write!(f, "AUTH_FAILED_INVALID_BEARER_TOKEN"),
            AuthErrorCode::AuthFailedInvalidSubject => write!(f, "AUTH_FAILED_INVALID_SUBJECT"),
            AuthErrorCode::AuthFailedInvalidAudience => write!(f, "AUTH_FAILED_INVALID_AUDIENCE"),
            AuthErrorCode::AuthFailedInvalidIssuer => write!(f, "AUTH_FAILED_INVALID_ISSUER"),
            AuthErrorCode::BearerTokenMissing => write!(f, "BEARER_TOKEN_MISSING"),
            AuthErrorCode::TokenExpired => write!(f, "TOKEN_EXPIRED"),
            AuthErrorCode::TokenNotActive => write!(f, "TOKEN_NOT_ACTIVE"),
            AuthErrorCode::TokenRevoked => write!(f, "TOKEN_REVOKED"),
            AuthErrorCode::InvalidClaims => write!(f, "INVALID_CLAIMS"),
            AuthErrorCode::MissingRequiredClaims => write!(f, "MISSING_REQUIRED_CLAIMS"),
            AuthErrorCode::InvalidScope => write!(f, "INVALID_SCOPE"),
            AuthErrorCode::InvalidPermissions => write!(f, "INVALID_PERMISSIONS"),
            AuthErrorCode::SessionExpired => write!(f, "SESSION_EXPIRED"),
            AuthErrorCode::SessionInvalid => write!(f, "SESSION_INVALID"),
            AuthErrorCode::SessionRevoked => write!(f, "SESSION_REVOKED"),
            AuthErrorCode::Unauthenticated => write!(f, "UNAUTHENTICATED"),
            AuthErrorCode::MultiFactorRequired => write!(f, "MULTI_FACTOR_REQUIRED"),
            AuthErrorCode::MultiFactorFailed => write!(f, "MULTI_FACTOR_FAILED"),
            AuthErrorCode::AccountLocked => write!(f, "ACCOUNT_LOCKED"),
            AuthErrorCode::AccountDisabled => write!(f, "ACCOUNT_DISABLED"),
            AuthErrorCode::PasswordExpired => write!(f, "PASSWORD_EXPIRED"),
            AuthErrorCode::PasswordResetRequired => write!(f, "PASSWORD_RESET_REQUIRED"),
            AuthErrorCode::UnrecognizedDevice => write!(f, "UNRECOGNIZED_DEVICE"),
        }
    }
}

impl std::str::FromStr for AuthErrorCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NO_AUTH_ERROR" => std::result::Result::Ok(AuthErrorCode::NoAuthError),
            "AUTH_FAILED_INVALID_BEARER_TOKEN" => std::result::Result::Ok(AuthErrorCode::AuthFailedInvalidBearerToken),
            "AUTH_FAILED_INVALID_SUBJECT" => std::result::Result::Ok(AuthErrorCode::AuthFailedInvalidSubject),
            "AUTH_FAILED_INVALID_AUDIENCE" => std::result::Result::Ok(AuthErrorCode::AuthFailedInvalidAudience),
            "AUTH_FAILED_INVALID_ISSUER" => std::result::Result::Ok(AuthErrorCode::AuthFailedInvalidIssuer),
            "BEARER_TOKEN_MISSING" => std::result::Result::Ok(AuthErrorCode::BearerTokenMissing),
            "TOKEN_EXPIRED" => std::result::Result::Ok(AuthErrorCode::TokenExpired),
            "TOKEN_NOT_ACTIVE" => std::result::Result::Ok(AuthErrorCode::TokenNotActive),
            "TOKEN_REVOKED" => std::result::Result::Ok(AuthErrorCode::TokenRevoked),
            "INVALID_CLAIMS" => std::result::Result::Ok(AuthErrorCode::InvalidClaims),
            "MISSING_REQUIRED_CLAIMS" => std::result::Result::Ok(AuthErrorCode::MissingRequiredClaims),
            "INVALID_SCOPE" => std::result::Result::Ok(AuthErrorCode::InvalidScope),
            "INVALID_PERMISSIONS" => std::result::Result::Ok(AuthErrorCode::InvalidPermissions),
            "SESSION_EXPIRED" => std::result::Result::Ok(AuthErrorCode::SessionExpired),
            "SESSION_INVALID" => std::result::Result::Ok(AuthErrorCode::SessionInvalid),
            "SESSION_REVOKED" => std::result::Result::Ok(AuthErrorCode::SessionRevoked),
            "UNAUTHENTICATED" => std::result::Result::Ok(AuthErrorCode::Unauthenticated),
            "MULTI_FACTOR_REQUIRED" => std::result::Result::Ok(AuthErrorCode::MultiFactorRequired),
            "MULTI_FACTOR_FAILED" => std::result::Result::Ok(AuthErrorCode::MultiFactorFailed),
            "ACCOUNT_LOCKED" => std::result::Result::Ok(AuthErrorCode::AccountLocked),
            "ACCOUNT_DISABLED" => std::result::Result::Ok(AuthErrorCode::AccountDisabled),
            "PASSWORD_EXPIRED" => std::result::Result::Ok(AuthErrorCode::PasswordExpired),
            "PASSWORD_RESET_REQUIRED" => std::result::Result::Ok(AuthErrorCode::PasswordResetRequired),
            "UNRECOGNIZED_DEVICE" => std::result::Result::Ok(AuthErrorCode::UnrecognizedDevice),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents authentication and authorization failures
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthenticationErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::AuthErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "tokenInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_info: Option<models::TokenInfo>,

    #[serde(rename = "authContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth_context: Option<models::AuthContext>,

    #[serde(rename = "sessionInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub session_info: Option<models::SessionInfo>,

    #[serde(rename = "mfaInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mfa_info: Option<models::MfaInfo>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl AuthenticationErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AuthenticationErrorMessageResponse {
        AuthenticationErrorMessageResponse {
            code: None,
            message: None,
            token_info: None,
            auth_context: None,
            session_info: None,
            mfa_info: None,
            error_response: None,
        }
    }
}

/// Converts the AuthenticationErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthenticationErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping tokenInfo in query parameter serialization

            // Skipping authContext in query parameter serialization

            // Skipping sessionInfo in query parameter serialization

            // Skipping mfaInfo in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthenticationErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthenticationErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::AuthErrorCode>,
            pub message: Vec<String>,
            pub token_info: Vec<models::TokenInfo>,
            pub auth_context: Vec<models::AuthContext>,
            pub session_info: Vec<models::SessionInfo>,
            pub mfa_info: Vec<models::MfaInfo>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthenticationErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::AuthErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tokenInfo" => intermediate_rep.token_info.push(<models::TokenInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authContext" => intermediate_rep.auth_context.push(<models::AuthContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sessionInfo" => intermediate_rep.session_info.push(<models::SessionInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mfaInfo" => intermediate_rep.mfa_info.push(<models::MfaInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthenticationErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthenticationErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            token_info: intermediate_rep.token_info.into_iter().next(),
            auth_context: intermediate_rep.auth_context.into_iter().next(),
            session_info: intermediate_rep.session_info.into_iter().next(),
            mfa_info: intermediate_rep.mfa_info.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthenticationErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthenticationErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthenticationErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthenticationErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AuthenticationErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthenticationErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthenticationErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents authentication and authorization failures
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthenticationErrorMessageResponse1 {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::AuthErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "tokenInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_info: Option<models::TokenInfo>,

    #[serde(rename = "authContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth_context: Option<models::AuthContext>,

    #[serde(rename = "sessionInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub session_info: Option<models::SessionInfo>,

    #[serde(rename = "mfaInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mfa_info: Option<models::MfaInfo>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl AuthenticationErrorMessageResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AuthenticationErrorMessageResponse1 {
        AuthenticationErrorMessageResponse1 {
            code: None,
            message: None,
            token_info: None,
            auth_context: None,
            session_info: None,
            mfa_info: None,
            error_response: None,
        }
    }
}

/// Converts the AuthenticationErrorMessageResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthenticationErrorMessageResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping tokenInfo in query parameter serialization

            // Skipping authContext in query parameter serialization

            // Skipping sessionInfo in query parameter serialization

            // Skipping mfaInfo in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthenticationErrorMessageResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthenticationErrorMessageResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::AuthErrorCode>,
            pub message: Vec<String>,
            pub token_info: Vec<models::TokenInfo>,
            pub auth_context: Vec<models::AuthContext>,
            pub session_info: Vec<models::SessionInfo>,
            pub mfa_info: Vec<models::MfaInfo>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthenticationErrorMessageResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::AuthErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tokenInfo" => intermediate_rep.token_info.push(<models::TokenInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authContext" => intermediate_rep.auth_context.push(<models::AuthContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sessionInfo" => intermediate_rep.session_info.push(<models::SessionInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mfaInfo" => intermediate_rep.mfa_info.push(<models::MfaInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthenticationErrorMessageResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthenticationErrorMessageResponse1 {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            token_info: intermediate_rep.token_info.into_iter().next(),
            auth_context: intermediate_rep.auth_context.into_iter().next(),
            session_info: intermediate_rep.session_info.into_iter().next(),
            mfa_info: intermediate_rep.mfa_info.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthenticationErrorMessageResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthenticationErrorMessageResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthenticationErrorMessageResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthenticationErrorMessageResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AuthenticationErrorMessageResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthenticationErrorMessageResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthenticationErrorMessageResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AvailabilityInfo {
    #[serde(rename = "retryAfter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retry_after: Option<i32>,

    #[serde(rename = "maintenanceWindow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintenance_window: Option<String>,

    #[serde(rename = "affectedServices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_services: Option<Vec<String>>,

    #[serde(rename = "statusPageUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_page_url: Option<String>,

}


impl AvailabilityInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AvailabilityInfo {
        AvailabilityInfo {
            retry_after: None,
            maintenance_window: None,
            affected_services: None,
            status_page_url: None,
        }
    }
}

/// Converts the AvailabilityInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AvailabilityInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.retry_after.as_ref().map(|retry_after| {
                [
                    "retryAfter".to_string(),
                    retry_after.to_string(),
                ].join(",")
            }),


            self.maintenance_window.as_ref().map(|maintenance_window| {
                [
                    "maintenanceWindow".to_string(),
                    maintenance_window.to_string(),
                ].join(",")
            }),


            self.affected_services.as_ref().map(|affected_services| {
                [
                    "affectedServices".to_string(),
                    affected_services.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.status_page_url.as_ref().map(|status_page_url| {
                [
                    "statusPageUrl".to_string(),
                    status_page_url.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AvailabilityInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AvailabilityInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub retry_after: Vec<i32>,
            pub maintenance_window: Vec<String>,
            pub affected_services: Vec<Vec<String>>,
            pub status_page_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AvailabilityInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "retryAfter" => intermediate_rep.retry_after.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maintenanceWindow" => intermediate_rep.maintenance_window.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "affectedServices" => return std::result::Result::Err("Parsing a container in this style is not supported in AvailabilityInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "statusPageUrl" => intermediate_rep.status_page_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AvailabilityInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AvailabilityInfo {
            retry_after: intermediate_rep.retry_after.into_iter().next(),
            maintenance_window: intermediate_rep.maintenance_window.into_iter().next(),
            affected_services: intermediate_rep.affected_services.into_iter().next(),
            status_page_url: intermediate_rep.status_page_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AvailabilityInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AvailabilityInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AvailabilityInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AvailabilityInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AvailabilityInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AvailabilityInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AvailabilityInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// BackgroundJobStatus represents the possible states of a background job. This enum is used to track the lifecycle of asynchronous tasks like scraping jobs.  State transitions: 1. QUEUED -> IN_PROGRESS 2. IN_PROGRESS -> COMPLETED/FAILED/CANCELLED/TIMED_OUT  Usage example: ```go job := &ScrapingJob{     Status: BackgroundJobStatus_BACKGROUND_JOB_STATUS_IN_PROGRESS, } ```   - BACKGROUND_JOB_STATUS_UNSPECIFIED: Default state, should not be used explicitly  - BACKGROUND_JOB_STATUS_QUEUED: Job is queued and waiting to be processed  - BACKGROUND_JOB_STATUS_IN_PROGRESS: Job is currently being processed  - BACKGROUND_JOB_STATUS_COMPLETED: Job has completed successfully  - BACKGROUND_JOB_STATUS_FAILED: Job encountered an error and failed  - BACKGROUND_JOB_STATUS_CANCELLED: Job was manually cancelled by user  - BACKGROUND_JOB_STATUS_TIMED_OUT: Job exceeded its maximum execution time
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BackgroundJobStatus {
    #[serde(rename = "BACKGROUND_JOB_STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "BACKGROUND_JOB_STATUS_QUEUED")]
    Queued,
    #[serde(rename = "BACKGROUND_JOB_STATUS_IN_PROGRESS")]
    InProgress,
    #[serde(rename = "BACKGROUND_JOB_STATUS_COMPLETED")]
    Completed,
    #[serde(rename = "BACKGROUND_JOB_STATUS_FAILED")]
    Failed,
    #[serde(rename = "BACKGROUND_JOB_STATUS_CANCELLED")]
    Cancelled,
    #[serde(rename = "BACKGROUND_JOB_STATUS_TIMED_OUT")]
    TimedOut,
}

impl std::fmt::Display for BackgroundJobStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BackgroundJobStatus::Unspecified => write!(f, "BACKGROUND_JOB_STATUS_UNSPECIFIED"),
            BackgroundJobStatus::Queued => write!(f, "BACKGROUND_JOB_STATUS_QUEUED"),
            BackgroundJobStatus::InProgress => write!(f, "BACKGROUND_JOB_STATUS_IN_PROGRESS"),
            BackgroundJobStatus::Completed => write!(f, "BACKGROUND_JOB_STATUS_COMPLETED"),
            BackgroundJobStatus::Failed => write!(f, "BACKGROUND_JOB_STATUS_FAILED"),
            BackgroundJobStatus::Cancelled => write!(f, "BACKGROUND_JOB_STATUS_CANCELLED"),
            BackgroundJobStatus::TimedOut => write!(f, "BACKGROUND_JOB_STATUS_TIMED_OUT"),
        }
    }
}

impl std::str::FromStr for BackgroundJobStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BACKGROUND_JOB_STATUS_UNSPECIFIED" => std::result::Result::Ok(BackgroundJobStatus::Unspecified),
            "BACKGROUND_JOB_STATUS_QUEUED" => std::result::Result::Ok(BackgroundJobStatus::Queued),
            "BACKGROUND_JOB_STATUS_IN_PROGRESS" => std::result::Result::Ok(BackgroundJobStatus::InProgress),
            "BACKGROUND_JOB_STATUS_COMPLETED" => std::result::Result::Ok(BackgroundJobStatus::Completed),
            "BACKGROUND_JOB_STATUS_FAILED" => std::result::Result::Ok(BackgroundJobStatus::Failed),
            "BACKGROUND_JOB_STATUS_CANCELLED" => std::result::Result::Ok(BackgroundJobStatus::Cancelled),
            "BACKGROUND_JOB_STATUS_TIMED_OUT" => std::result::Result::Ok(BackgroundJobStatus::TimedOut),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents errors when the server received an invalid response from an upstream server
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BadGatewayErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "upstreamService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upstream_service: Option<String>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl BadGatewayErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BadGatewayErrorMessageResponse {
        BadGatewayErrorMessageResponse {
            code: None,
            message: None,
            upstream_service: None,
            error_response: None,
        }
    }
}

/// Converts the BadGatewayErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BadGatewayErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.upstream_service.as_ref().map(|upstream_service| {
                [
                    "upstreamService".to_string(),
                    upstream_service.to_string(),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BadGatewayErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BadGatewayErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub upstream_service: Vec<String>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BadGatewayErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upstreamService" => intermediate_rep.upstream_service.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BadGatewayErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BadGatewayErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            upstream_service: intermediate_rep.upstream_service.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BadGatewayErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BadGatewayErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BadGatewayErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BadGatewayErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BadGatewayErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BadGatewayErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BadGatewayErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// - BILLING_MODE_LICENSED: Fixed price per seat  - BILLING_MODE_METERED: Usage-based  - BILLING_MODE_HYBRID: Base price + usage
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BillingMode {
    #[serde(rename = "BILLING_MODE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "BILLING_MODE_LICENSED")]
    Licensed,
    #[serde(rename = "BILLING_MODE_METERED")]
    Metered,
    #[serde(rename = "BILLING_MODE_HYBRID")]
    Hybrid,
}

impl std::fmt::Display for BillingMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BillingMode::Unspecified => write!(f, "BILLING_MODE_UNSPECIFIED"),
            BillingMode::Licensed => write!(f, "BILLING_MODE_LICENSED"),
            BillingMode::Metered => write!(f, "BILLING_MODE_METERED"),
            BillingMode::Hybrid => write!(f, "BILLING_MODE_HYBRID"),
        }
    }
}

impl std::str::FromStr for BillingMode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BILLING_MODE_UNSPECIFIED" => std::result::Result::Ok(BillingMode::Unspecified),
            "BILLING_MODE_LICENSED" => std::result::Result::Ok(BillingMode::Licensed),
            "BILLING_MODE_METERED" => std::result::Result::Ok(BillingMode::Metered),
            "BILLING_MODE_HYBRID" => std::result::Result::Ok(BillingMode::Hybrid),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BillingPlan {
    #[serde(rename = "BILLING_PLAN_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "BILLING_PLAN_STARTUP")]
    Startup,
    #[serde(rename = "BILLING_PLAN_BUSINESS")]
    Business,
    #[serde(rename = "BILLING_PLAN_ENTERPRISE")]
    Enterprise,
}

impl std::fmt::Display for BillingPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BillingPlan::Unspecified => write!(f, "BILLING_PLAN_UNSPECIFIED"),
            BillingPlan::Startup => write!(f, "BILLING_PLAN_STARTUP"),
            BillingPlan::Business => write!(f, "BILLING_PLAN_BUSINESS"),
            BillingPlan::Enterprise => write!(f, "BILLING_PLAN_ENTERPRISE"),
        }
    }
}

impl std::str::FromStr for BillingPlan {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BILLING_PLAN_UNSPECIFIED" => std::result::Result::Ok(BillingPlan::Unspecified),
            "BILLING_PLAN_STARTUP" => std::result::Result::Ok(BillingPlan::Startup),
            "BILLING_PLAN_BUSINESS" => std::result::Result::Ok(BillingPlan::Business),
            "BILLING_PLAN_ENTERPRISE" => std::result::Result::Ok(BillingPlan::Enterprise),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BranchMerge {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "branchId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch_id: Option<String>,

    #[serde(rename = "sourceBranch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_branch: Option<String>,

    #[serde(rename = "targetBranch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_branch: Option<String>,

    #[serde(rename = "mergeStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_status: Option<String>,

    #[serde(rename = "mergeStrategy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_strategy: Option<String>,

    #[serde(rename = "conflicts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conflicts: Option<Vec<String>>,

    #[serde(rename = "mergerId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merger_id: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "completedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl BranchMerge {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BranchMerge {
        BranchMerge {
            id: None,
            branch_id: None,
            source_branch: None,
            target_branch: None,
            merge_status: None,
            merge_strategy: None,
            conflicts: None,
            merger_id: None,
            created_at: None,
            completed_at: None,
        }
    }
}

/// Converts the BranchMerge value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BranchMerge {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.branch_id.as_ref().map(|branch_id| {
                [
                    "branchId".to_string(),
                    branch_id.to_string(),
                ].join(",")
            }),


            self.source_branch.as_ref().map(|source_branch| {
                [
                    "sourceBranch".to_string(),
                    source_branch.to_string(),
                ].join(",")
            }),


            self.target_branch.as_ref().map(|target_branch| {
                [
                    "targetBranch".to_string(),
                    target_branch.to_string(),
                ].join(",")
            }),


            self.merge_status.as_ref().map(|merge_status| {
                [
                    "mergeStatus".to_string(),
                    merge_status.to_string(),
                ].join(",")
            }),


            self.merge_strategy.as_ref().map(|merge_strategy| {
                [
                    "mergeStrategy".to_string(),
                    merge_strategy.to_string(),
                ].join(",")
            }),


            self.conflicts.as_ref().map(|conflicts| {
                [
                    "conflicts".to_string(),
                    conflicts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.merger_id.as_ref().map(|merger_id| {
                [
                    "mergerId".to_string(),
                    merger_id.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping completedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BranchMerge value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BranchMerge {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub branch_id: Vec<String>,
            pub source_branch: Vec<String>,
            pub target_branch: Vec<String>,
            pub merge_status: Vec<String>,
            pub merge_strategy: Vec<String>,
            pub conflicts: Vec<Vec<String>>,
            pub merger_id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub completed_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BranchMerge".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "branchId" => intermediate_rep.branch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sourceBranch" => intermediate_rep.source_branch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetBranch" => intermediate_rep.target_branch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mergeStatus" => intermediate_rep.merge_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mergeStrategy" => intermediate_rep.merge_strategy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "conflicts" => return std::result::Result::Err("Parsing a container in this style is not supported in BranchMerge".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mergerId" => intermediate_rep.merger_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completedAt" => intermediate_rep.completed_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BranchMerge".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BranchMerge {
            id: intermediate_rep.id.into_iter().next(),
            branch_id: intermediate_rep.branch_id.into_iter().next(),
            source_branch: intermediate_rep.source_branch.into_iter().next(),
            target_branch: intermediate_rep.target_branch.into_iter().next(),
            merge_status: intermediate_rep.merge_status.into_iter().next(),
            merge_strategy: intermediate_rep.merge_strategy.into_iter().next(),
            conflicts: intermediate_rep.conflicts.into_iter().next(),
            merger_id: intermediate_rep.merger_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            completed_at: intermediate_rep.completed_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BranchMerge> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BranchMerge>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BranchMerge>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BranchMerge - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BranchMerge> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BranchMerge as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BranchMerge - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BranchPolicy {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "branchId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch_id: Option<String>,

    #[serde(rename = "requiredApprovers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approvers: Option<Vec<String>>,

    #[serde(rename = "minimumApprovals")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minimum_approvals: Option<i32>,

    #[serde(rename = "enforceLinearHistory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_linear_history: Option<bool>,

    #[serde(rename = "allowForcePush")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_force_push: Option<bool>,

    #[serde(rename = "protectedPaths")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected_paths: Option<Vec<String>>,

    #[serde(rename = "mergeRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_rules: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "automatedChecks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub automated_checks: Option<Vec<String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl BranchPolicy {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BranchPolicy {
        BranchPolicy {
            id: None,
            branch_id: None,
            required_approvers: None,
            minimum_approvals: None,
            enforce_linear_history: None,
            allow_force_push: None,
            protected_paths: None,
            merge_rules: None,
            automated_checks: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the BranchPolicy value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BranchPolicy {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.branch_id.as_ref().map(|branch_id| {
                [
                    "branchId".to_string(),
                    branch_id.to_string(),
                ].join(",")
            }),


            self.required_approvers.as_ref().map(|required_approvers| {
                [
                    "requiredApprovers".to_string(),
                    required_approvers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.minimum_approvals.as_ref().map(|minimum_approvals| {
                [
                    "minimumApprovals".to_string(),
                    minimum_approvals.to_string(),
                ].join(",")
            }),


            self.enforce_linear_history.as_ref().map(|enforce_linear_history| {
                [
                    "enforceLinearHistory".to_string(),
                    enforce_linear_history.to_string(),
                ].join(",")
            }),


            self.allow_force_push.as_ref().map(|allow_force_push| {
                [
                    "allowForcePush".to_string(),
                    allow_force_push.to_string(),
                ].join(",")
            }),


            self.protected_paths.as_ref().map(|protected_paths| {
                [
                    "protectedPaths".to_string(),
                    protected_paths.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping mergeRules in query parameter serialization


            self.automated_checks.as_ref().map(|automated_checks| {
                [
                    "automatedChecks".to_string(),
                    automated_checks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BranchPolicy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BranchPolicy {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub branch_id: Vec<String>,
            pub required_approvers: Vec<Vec<String>>,
            pub minimum_approvals: Vec<i32>,
            pub enforce_linear_history: Vec<bool>,
            pub allow_force_push: Vec<bool>,
            pub protected_paths: Vec<Vec<String>>,
            pub merge_rules: Vec<std::collections::HashMap<String, String>>,
            pub automated_checks: Vec<Vec<String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BranchPolicy".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "branchId" => intermediate_rep.branch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "requiredApprovers" => return std::result::Result::Err("Parsing a container in this style is not supported in BranchPolicy".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "minimumApprovals" => intermediate_rep.minimum_approvals.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enforceLinearHistory" => intermediate_rep.enforce_linear_history.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allowForcePush" => intermediate_rep.allow_force_push.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "protectedPaths" => return std::result::Result::Err("Parsing a container in this style is not supported in BranchPolicy".to_string()),
                    "mergeRules" => return std::result::Result::Err("Parsing a container in this style is not supported in BranchPolicy".to_string()),
                    "automatedChecks" => return std::result::Result::Err("Parsing a container in this style is not supported in BranchPolicy".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BranchPolicy".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BranchPolicy {
            id: intermediate_rep.id.into_iter().next(),
            branch_id: intermediate_rep.branch_id.into_iter().next(),
            required_approvers: intermediate_rep.required_approvers.into_iter().next(),
            minimum_approvals: intermediate_rep.minimum_approvals.into_iter().next(),
            enforce_linear_history: intermediate_rep.enforce_linear_history.into_iter().next(),
            allow_force_push: intermediate_rep.allow_force_push.into_iter().next(),
            protected_paths: intermediate_rep.protected_paths.into_iter().next(),
            merge_rules: intermediate_rep.merge_rules.into_iter().next(),
            automated_checks: intermediate_rep.automated_checks.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BranchPolicy> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BranchPolicy>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BranchPolicy>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BranchPolicy - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BranchPolicy> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BranchPolicy as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BranchPolicy - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BusinessHours {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "day")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub day: Option<models::DayOfWeek>,

    #[serde(rename = "openTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_time: Option<String>,

    #[serde(rename = "closeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub close_time: Option<String>,

    #[serde(rename = "closed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed: Option<bool>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl BusinessHours {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BusinessHours {
        BusinessHours {
            id: None,
            day: None,
            open_time: None,
            close_time: None,
            closed: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
        }
    }
}

/// Converts the BusinessHours value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BusinessHours {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping day in query parameter serialization


            self.open_time.as_ref().map(|open_time| {
                [
                    "openTime".to_string(),
                    open_time.to_string(),
                ].join(",")
            }),


            self.close_time.as_ref().map(|close_time| {
                [
                    "closeTime".to_string(),
                    close_time.to_string(),
                ].join(",")
            }),


            self.closed.as_ref().map(|closed| {
                [
                    "closed".to_string(),
                    closed.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BusinessHours value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BusinessHours {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub day: Vec<models::DayOfWeek>,
            pub open_time: Vec<String>,
            pub close_time: Vec<String>,
            pub closed: Vec<bool>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BusinessHours".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "day" => intermediate_rep.day.push(<models::DayOfWeek as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "openTime" => intermediate_rep.open_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "closeTime" => intermediate_rep.close_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "closed" => intermediate_rep.closed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BusinessHours".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BusinessHours {
            id: intermediate_rep.id.into_iter().next(),
            day: intermediate_rep.day.into_iter().next(),
            open_time: intermediate_rep.open_time.into_iter().next(),
            close_time: intermediate_rep.close_time.into_iter().next(),
            closed: intermediate_rep.closed.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BusinessHours> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BusinessHours>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BusinessHours>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BusinessHours - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BusinessHours> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BusinessHours as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BusinessHours - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChangeSet {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_id: Option<String>,

    #[serde(rename = "changeType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_type: Option<String>,

    #[serde(rename = "contentBefore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_before: Option<String>,

    #[serde(rename = "contentAfter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_after: Option<String>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ChangeSet {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ChangeSet {
        ChangeSet {
            id: None,
            version_id: None,
            change_type: None,
            content_before: None,
            content_after: None,
            metadata: None,
            created_at: None,
        }
    }
}

/// Converts the ChangeSet value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChangeSet {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.version_id.as_ref().map(|version_id| {
                [
                    "versionId".to_string(),
                    version_id.to_string(),
                ].join(",")
            }),


            self.change_type.as_ref().map(|change_type| {
                [
                    "changeType".to_string(),
                    change_type.to_string(),
                ].join(",")
            }),


            self.content_before.as_ref().map(|content_before| {
                [
                    "contentBefore".to_string(),
                    content_before.to_string(),
                ].join(",")
            }),


            self.content_after.as_ref().map(|content_after| {
                [
                    "contentAfter".to_string(),
                    content_after.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChangeSet value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChangeSet {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub version_id: Vec<String>,
            pub change_type: Vec<String>,
            pub content_before: Vec<String>,
            pub content_after: Vec<String>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChangeSet".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "versionId" => intermediate_rep.version_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changeType" => intermediate_rep.change_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contentBefore" => intermediate_rep.content_before.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contentAfter" => intermediate_rep.content_after.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ChangeSet".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChangeSet".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChangeSet {
            id: intermediate_rep.id.into_iter().next(),
            version_id: intermediate_rep.version_id.into_iter().next(),
            change_type: intermediate_rep.change_type.into_iter().next(),
            content_before: intermediate_rep.content_before.into_iter().next(),
            content_after: intermediate_rep.content_after.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChangeSet> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChangeSet>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChangeSet>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChangeSet - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChangeSet> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChangeSet as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChangeSet - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CommentThread {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "authorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_id: Option<String>,

    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,

    #[serde(rename = "startPosition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_position: Option<i32>,

    #[serde(rename = "endPosition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_position: Option<i32>,

    #[serde(rename = "resolved")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved: Option<bool>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl CommentThread {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CommentThread {
        CommentThread {
            id: None,
            author_id: None,
            content: None,
            start_position: None,
            end_position: None,
            resolved: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the CommentThread value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CommentThread {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.author_id.as_ref().map(|author_id| {
                [
                    "authorId".to_string(),
                    author_id.to_string(),
                ].join(",")
            }),


            self.content.as_ref().map(|content| {
                [
                    "content".to_string(),
                    content.to_string(),
                ].join(",")
            }),


            self.start_position.as_ref().map(|start_position| {
                [
                    "startPosition".to_string(),
                    start_position.to_string(),
                ].join(",")
            }),


            self.end_position.as_ref().map(|end_position| {
                [
                    "endPosition".to_string(),
                    end_position.to_string(),
                ].join(",")
            }),


            self.resolved.as_ref().map(|resolved| {
                [
                    "resolved".to_string(),
                    resolved.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CommentThread value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CommentThread {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub author_id: Vec<String>,
            pub content: Vec<String>,
            pub start_position: Vec<i32>,
            pub end_position: Vec<i32>,
            pub resolved: Vec<bool>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CommentThread".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authorId" => intermediate_rep.author_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startPosition" => intermediate_rep.start_position.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endPosition" => intermediate_rep.end_position.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resolved" => intermediate_rep.resolved.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CommentThread".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CommentThread {
            id: intermediate_rep.id.into_iter().next(),
            author_id: intermediate_rep.author_id.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            start_position: intermediate_rep.start_position.into_iter().next(),
            end_position: intermediate_rep.end_position.into_iter().next(),
            resolved: intermediate_rep.resolved.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CommentThread> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CommentThread>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CommentThread>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CommentThread - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CommentThread> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CommentThread as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CommentThread - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ComplianceCheck {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "intelligenceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub intelligence_id: Option<String>,

    #[serde(rename = "complianceStandard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_standard: Option<String>,

    #[serde(rename = "checkResult")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_result: Option<String>,

    #[serde(rename = "violations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub violations: Option<Vec<String>>,

    #[serde(rename = "remediationSteps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remediation_steps: Option<String>,

    #[serde(rename = "checkDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_date: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ComplianceCheck {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ComplianceCheck {
        ComplianceCheck {
            id: None,
            intelligence_id: None,
            compliance_standard: None,
            check_result: None,
            violations: None,
            remediation_steps: None,
            check_date: None,
        }
    }
}

/// Converts the ComplianceCheck value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ComplianceCheck {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.intelligence_id.as_ref().map(|intelligence_id| {
                [
                    "intelligenceId".to_string(),
                    intelligence_id.to_string(),
                ].join(",")
            }),


            self.compliance_standard.as_ref().map(|compliance_standard| {
                [
                    "complianceStandard".to_string(),
                    compliance_standard.to_string(),
                ].join(",")
            }),


            self.check_result.as_ref().map(|check_result| {
                [
                    "checkResult".to_string(),
                    check_result.to_string(),
                ].join(",")
            }),


            self.violations.as_ref().map(|violations| {
                [
                    "violations".to_string(),
                    violations.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.remediation_steps.as_ref().map(|remediation_steps| {
                [
                    "remediationSteps".to_string(),
                    remediation_steps.to_string(),
                ].join(",")
            }),

            // Skipping checkDate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ComplianceCheck value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ComplianceCheck {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub intelligence_id: Vec<String>,
            pub compliance_standard: Vec<String>,
            pub check_result: Vec<String>,
            pub violations: Vec<Vec<String>>,
            pub remediation_steps: Vec<String>,
            pub check_date: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ComplianceCheck".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "intelligenceId" => intermediate_rep.intelligence_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complianceStandard" => intermediate_rep.compliance_standard.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "checkResult" => intermediate_rep.check_result.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "violations" => return std::result::Result::Err("Parsing a container in this style is not supported in ComplianceCheck".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remediationSteps" => intermediate_rep.remediation_steps.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "checkDate" => intermediate_rep.check_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ComplianceCheck".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ComplianceCheck {
            id: intermediate_rep.id.into_iter().next(),
            intelligence_id: intermediate_rep.intelligence_id.into_iter().next(),
            compliance_standard: intermediate_rep.compliance_standard.into_iter().next(),
            check_result: intermediate_rep.check_result.into_iter().next(),
            violations: intermediate_rep.violations.into_iter().next(),
            remediation_steps: intermediate_rep.remediation_steps.into_iter().next(),
            check_date: intermediate_rep.check_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ComplianceCheck> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ComplianceCheck>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ComplianceCheck>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ComplianceCheck - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ComplianceCheck> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ComplianceCheck as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ComplianceCheck - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ComplianceLevel {
    #[serde(rename = "COMPLIANCE_LEVEL_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "COMPLIANCE_LEVEL_NONE")]
    None,
    #[serde(rename = "COMPLIANCE_LEVEL_BASIC")]
    Basic,
    #[serde(rename = "COMPLIANCE_LEVEL_ADVANCED")]
    Advanced,
    #[serde(rename = "COMPLIANCE_LEVEL_ENTERPRISE")]
    Enterprise,
}

impl std::fmt::Display for ComplianceLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ComplianceLevel::Unspecified => write!(f, "COMPLIANCE_LEVEL_UNSPECIFIED"),
            ComplianceLevel::None => write!(f, "COMPLIANCE_LEVEL_NONE"),
            ComplianceLevel::Basic => write!(f, "COMPLIANCE_LEVEL_BASIC"),
            ComplianceLevel::Advanced => write!(f, "COMPLIANCE_LEVEL_ADVANCED"),
            ComplianceLevel::Enterprise => write!(f, "COMPLIANCE_LEVEL_ENTERPRISE"),
        }
    }
}

impl std::str::FromStr for ComplianceLevel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "COMPLIANCE_LEVEL_UNSPECIFIED" => std::result::Result::Ok(ComplianceLevel::Unspecified),
            "COMPLIANCE_LEVEL_NONE" => std::result::Result::Ok(ComplianceLevel::None),
            "COMPLIANCE_LEVEL_BASIC" => std::result::Result::Ok(ComplianceLevel::Basic),
            "COMPLIANCE_LEVEL_ADVANCED" => std::result::Result::Ok(ComplianceLevel::Advanced),
            "COMPLIANCE_LEVEL_ENTERPRISE" => std::result::Result::Ok(ComplianceLevel::Enterprise),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ComplianceMetrics {
    #[serde(rename = "gdprComplianceScore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gdpr_compliance_score: Option<f32>,

    #[serde(rename = "hipaaComplianceScore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hipaa_compliance_score: Option<f32>,

    #[serde(rename = "pendingApprovals")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_approvals: Option<i32>,

    #[serde(rename = "complianceViolations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_violations: Option<i32>,

}


impl ComplianceMetrics {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ComplianceMetrics {
        ComplianceMetrics {
            gdpr_compliance_score: None,
            hipaa_compliance_score: None,
            pending_approvals: None,
            compliance_violations: None,
        }
    }
}

/// Converts the ComplianceMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ComplianceMetrics {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.gdpr_compliance_score.as_ref().map(|gdpr_compliance_score| {
                [
                    "gdprComplianceScore".to_string(),
                    gdpr_compliance_score.to_string(),
                ].join(",")
            }),


            self.hipaa_compliance_score.as_ref().map(|hipaa_compliance_score| {
                [
                    "hipaaComplianceScore".to_string(),
                    hipaa_compliance_score.to_string(),
                ].join(",")
            }),


            self.pending_approvals.as_ref().map(|pending_approvals| {
                [
                    "pendingApprovals".to_string(),
                    pending_approvals.to_string(),
                ].join(",")
            }),


            self.compliance_violations.as_ref().map(|compliance_violations| {
                [
                    "complianceViolations".to_string(),
                    compliance_violations.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ComplianceMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ComplianceMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gdpr_compliance_score: Vec<f32>,
            pub hipaa_compliance_score: Vec<f32>,
            pub pending_approvals: Vec<i32>,
            pub compliance_violations: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ComplianceMetrics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "gdprComplianceScore" => intermediate_rep.gdpr_compliance_score.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hipaaComplianceScore" => intermediate_rep.hipaa_compliance_score.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pendingApprovals" => intermediate_rep.pending_approvals.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complianceViolations" => intermediate_rep.compliance_violations.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ComplianceMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ComplianceMetrics {
            gdpr_compliance_score: intermediate_rep.gdpr_compliance_score.into_iter().next(),
            hipaa_compliance_score: intermediate_rep.hipaa_compliance_score.into_iter().next(),
            pending_approvals: intermediate_rep.pending_approvals.into_iter().next(),
            compliance_violations: intermediate_rep.compliance_violations.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ComplianceMetrics> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ComplianceMetrics>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ComplianceMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ComplianceMetrics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ComplianceMetrics> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ComplianceMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ComplianceMetrics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ComplianceScore {
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    #[serde(rename = "score")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f32>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "improvements")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub improvements: Option<Vec<String>>,

}


impl ComplianceScore {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ComplianceScore {
        ComplianceScore {
            category: None,
            score: None,
            status: None,
            improvements: None,
        }
    }
}

/// Converts the ComplianceScore value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ComplianceScore {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.score.as_ref().map(|score| {
                [
                    "score".to_string(),
                    score.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.improvements.as_ref().map(|improvements| {
                [
                    "improvements".to_string(),
                    improvements.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ComplianceScore value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ComplianceScore {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub category: Vec<String>,
            pub score: Vec<f32>,
            pub status: Vec<String>,
            pub improvements: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ComplianceScore".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "score" => intermediate_rep.score.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "improvements" => return std::result::Result::Err("Parsing a container in this style is not supported in ComplianceScore".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ComplianceScore".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ComplianceScore {
            category: intermediate_rep.category.into_iter().next(),
            score: intermediate_rep.score.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            improvements: intermediate_rep.improvements.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ComplianceScore> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ComplianceScore>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ComplianceScore>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ComplianceScore - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ComplianceScore> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ComplianceScore as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ComplianceScore - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ComplianceViolation {
    #[serde(rename = "ruleId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule_id: Option<String>,

    #[serde(rename = "severity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "affectedResources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_resources: Option<Vec<String>>,

    #[serde(rename = "remediationSteps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remediation_steps: Option<String>,

}


impl ComplianceViolation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ComplianceViolation {
        ComplianceViolation {
            rule_id: None,
            severity: None,
            description: None,
            affected_resources: None,
            remediation_steps: None,
        }
    }
}

/// Converts the ComplianceViolation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ComplianceViolation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.rule_id.as_ref().map(|rule_id| {
                [
                    "ruleId".to_string(),
                    rule_id.to_string(),
                ].join(",")
            }),


            self.severity.as_ref().map(|severity| {
                [
                    "severity".to_string(),
                    severity.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.affected_resources.as_ref().map(|affected_resources| {
                [
                    "affectedResources".to_string(),
                    affected_resources.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.remediation_steps.as_ref().map(|remediation_steps| {
                [
                    "remediationSteps".to_string(),
                    remediation_steps.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ComplianceViolation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ComplianceViolation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rule_id: Vec<String>,
            pub severity: Vec<String>,
            pub description: Vec<String>,
            pub affected_resources: Vec<Vec<String>>,
            pub remediation_steps: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ComplianceViolation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ruleId" => intermediate_rep.rule_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "severity" => intermediate_rep.severity.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "affectedResources" => return std::result::Result::Err("Parsing a container in this style is not supported in ComplianceViolation".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remediationSteps" => intermediate_rep.remediation_steps.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ComplianceViolation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ComplianceViolation {
            rule_id: intermediate_rep.rule_id.into_iter().next(),
            severity: intermediate_rep.severity.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            affected_resources: intermediate_rep.affected_resources.into_iter().next(),
            remediation_steps: intermediate_rep.remediation_steps.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ComplianceViolation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ComplianceViolation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ComplianceViolation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ComplianceViolation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ComplianceViolation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ComplianceViolation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ComplianceViolation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents resource conflict errors
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConflictErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::ValidationErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "conflictInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conflict_info: Option<models::ConflictInfo>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl ConflictErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ConflictErrorMessageResponse {
        ConflictErrorMessageResponse {
            code: None,
            message: None,
            conflict_info: None,
            error_response: None,
        }
    }
}

/// Converts the ConflictErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConflictErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping conflictInfo in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConflictErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConflictErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::ValidationErrorCode>,
            pub message: Vec<String>,
            pub conflict_info: Vec<models::ConflictInfo>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConflictErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::ValidationErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conflictInfo" => intermediate_rep.conflict_info.push(<models::ConflictInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConflictErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConflictErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            conflict_info: intermediate_rep.conflict_info.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConflictErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConflictErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConflictErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConflictErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConflictErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConflictErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConflictErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConflictInfo {
    #[serde(rename = "resourceType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_type: Option<String>,

    #[serde(rename = "identifier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifier: Option<String>,

    #[serde(rename = "conflictReason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conflict_reason: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdBy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_by: Option<String>,

}


impl ConflictInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ConflictInfo {
        ConflictInfo {
            resource_type: None,
            identifier: None,
            conflict_reason: None,
            created_at: None,
            created_by: None,
        }
    }
}

/// Converts the ConflictInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConflictInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.resource_type.as_ref().map(|resource_type| {
                [
                    "resourceType".to_string(),
                    resource_type.to_string(),
                ].join(",")
            }),


            self.identifier.as_ref().map(|identifier| {
                [
                    "identifier".to_string(),
                    identifier.to_string(),
                ].join(",")
            }),


            self.conflict_reason.as_ref().map(|conflict_reason| {
                [
                    "conflictReason".to_string(),
                    conflict_reason.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization


            self.created_by.as_ref().map(|created_by| {
                [
                    "createdBy".to_string(),
                    created_by.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConflictInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConflictInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resource_type: Vec<String>,
            pub identifier: Vec<String>,
            pub conflict_reason: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_by: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConflictInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "resourceType" => intermediate_rep.resource_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "identifier" => intermediate_rep.identifier.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conflictReason" => intermediate_rep.conflict_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdBy" => intermediate_rep.created_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConflictInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConflictInfo {
            resource_type: intermediate_rep.resource_type.into_iter().next(),
            identifier: intermediate_rep.identifier.into_iter().next(),
            conflict_reason: intermediate_rep.conflict_reason.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            created_by: intermediate_rep.created_by.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConflictInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConflictInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConflictInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConflictInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConflictInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConflictInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConflictInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContextualSummary {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_id: Option<String>,

    #[serde(rename = "summaryType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_type: Option<String>,

    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,

    #[serde(rename = "targetAudience")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_audience: Option<String>,

    #[serde(rename = "keyPoints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_points: Option<Vec<String>>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ContextualSummary {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ContextualSummary {
        ContextualSummary {
            id: None,
            version_id: None,
            summary_type: None,
            content: None,
            target_audience: None,
            key_points: None,
            metadata: None,
            created_at: None,
        }
    }
}

/// Converts the ContextualSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContextualSummary {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.version_id.as_ref().map(|version_id| {
                [
                    "versionId".to_string(),
                    version_id.to_string(),
                ].join(",")
            }),


            self.summary_type.as_ref().map(|summary_type| {
                [
                    "summaryType".to_string(),
                    summary_type.to_string(),
                ].join(",")
            }),


            self.content.as_ref().map(|content| {
                [
                    "content".to_string(),
                    content.to_string(),
                ].join(",")
            }),


            self.target_audience.as_ref().map(|target_audience| {
                [
                    "targetAudience".to_string(),
                    target_audience.to_string(),
                ].join(",")
            }),


            self.key_points.as_ref().map(|key_points| {
                [
                    "keyPoints".to_string(),
                    key_points.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContextualSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContextualSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub version_id: Vec<String>,
            pub summary_type: Vec<String>,
            pub content: Vec<String>,
            pub target_audience: Vec<String>,
            pub key_points: Vec<Vec<String>>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContextualSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "versionId" => intermediate_rep.version_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "summaryType" => intermediate_rep.summary_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetAudience" => intermediate_rep.target_audience.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "keyPoints" => return std::result::Result::Err("Parsing a container in this style is not supported in ContextualSummary".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ContextualSummary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContextualSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContextualSummary {
            id: intermediate_rep.id.into_iter().next(),
            version_id: intermediate_rep.version_id.into_iter().next(),
            summary_type: intermediate_rep.summary_type.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            target_audience: intermediate_rep.target_audience.into_iter().next(),
            key_points: intermediate_rep.key_points.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContextualSummary> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ContextualSummary>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContextualSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContextualSummary - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ContextualSummary> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContextualSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContextualSummary - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContractIntelligence {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "contractType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub contract_type: Option<String>,

    #[serde(rename = "riskScores")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub risk_scores: Option<std::collections::HashMap<String, f32>>,

    #[serde(rename = "detectedClauses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detected_clauses: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "keyObligations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_obligations: Option<Vec<String>>,

    #[serde(rename = "complianceScores")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_scores: Option<std::collections::HashMap<String, f32>>,

    #[serde(rename = "jurisdiction")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub jurisdiction: Option<String>,

    #[serde(rename = "governingLaws")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub governing_laws: Option<Vec<String>>,

    #[serde(rename = "semanticAnalysis")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub semantic_analysis: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "analysisDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub analysis_date: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "riskAssessments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub risk_assessments: Option<Vec<models::RiskAssessment>>,

    #[serde(rename = "complianceChecks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_checks: Option<Vec<models::ComplianceCheck>>,

}


impl ContractIntelligence {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ContractIntelligence {
        ContractIntelligence {
            id: None,
            contract_type: None,
            risk_scores: None,
            detected_clauses: None,
            key_obligations: None,
            compliance_scores: None,
            jurisdiction: None,
            governing_laws: None,
            semantic_analysis: None,
            analysis_date: None,
            risk_assessments: None,
            compliance_checks: None,
        }
    }
}

/// Converts the ContractIntelligence value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContractIntelligence {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.contract_type.as_ref().map(|contract_type| {
                [
                    "contractType".to_string(),
                    contract_type.to_string(),
                ].join(",")
            }),

            // Skipping riskScores in query parameter serialization

            // Skipping detectedClauses in query parameter serialization


            self.key_obligations.as_ref().map(|key_obligations| {
                [
                    "keyObligations".to_string(),
                    key_obligations.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping complianceScores in query parameter serialization


            self.jurisdiction.as_ref().map(|jurisdiction| {
                [
                    "jurisdiction".to_string(),
                    jurisdiction.to_string(),
                ].join(",")
            }),


            self.governing_laws.as_ref().map(|governing_laws| {
                [
                    "governingLaws".to_string(),
                    governing_laws.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping semanticAnalysis in query parameter serialization

            // Skipping analysisDate in query parameter serialization

            // Skipping riskAssessments in query parameter serialization

            // Skipping complianceChecks in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContractIntelligence value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContractIntelligence {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub contract_type: Vec<String>,
            pub risk_scores: Vec<std::collections::HashMap<String, f32>>,
            pub detected_clauses: Vec<std::collections::HashMap<String, String>>,
            pub key_obligations: Vec<Vec<String>>,
            pub compliance_scores: Vec<std::collections::HashMap<String, f32>>,
            pub jurisdiction: Vec<String>,
            pub governing_laws: Vec<Vec<String>>,
            pub semantic_analysis: Vec<std::collections::HashMap<String, String>>,
            pub analysis_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub risk_assessments: Vec<Vec<models::RiskAssessment>>,
            pub compliance_checks: Vec<Vec<models::ComplianceCheck>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContractIntelligence".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contractType" => intermediate_rep.contract_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "riskScores" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    "detectedClauses" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    "keyObligations" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    "complianceScores" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "jurisdiction" => intermediate_rep.jurisdiction.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "governingLaws" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    "semanticAnalysis" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "analysisDate" => intermediate_rep.analysis_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "riskAssessments" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    "complianceChecks" => return std::result::Result::Err("Parsing a container in this style is not supported in ContractIntelligence".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContractIntelligence".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContractIntelligence {
            id: intermediate_rep.id.into_iter().next(),
            contract_type: intermediate_rep.contract_type.into_iter().next(),
            risk_scores: intermediate_rep.risk_scores.into_iter().next(),
            detected_clauses: intermediate_rep.detected_clauses.into_iter().next(),
            key_obligations: intermediate_rep.key_obligations.into_iter().next(),
            compliance_scores: intermediate_rep.compliance_scores.into_iter().next(),
            jurisdiction: intermediate_rep.jurisdiction.into_iter().next(),
            governing_laws: intermediate_rep.governing_laws.into_iter().next(),
            semantic_analysis: intermediate_rep.semantic_analysis.into_iter().next(),
            analysis_date: intermediate_rep.analysis_date.into_iter().next(),
            risk_assessments: intermediate_rep.risk_assessments.into_iter().next(),
            compliance_checks: intermediate_rep.compliance_checks.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContractIntelligence> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ContractIntelligence>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContractIntelligence>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContractIntelligence - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ContractIntelligence> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContractIntelligence as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContractIntelligence - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAccountRequest {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account>,

    #[serde(rename = "initialWorkspaceName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_workspace_name: Option<String>,

    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

}


impl CreateAccountRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateAccountRequest {
        CreateAccountRequest {
            account: None,
            initial_workspace_name: None,
            organization_id: None,
            tenant_id: None,
        }
    }
}

/// Converts the CreateAccountRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateAccountRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization


            self.initial_workspace_name.as_ref().map(|initial_workspace_name| {
                [
                    "initialWorkspaceName".to_string(),
                    initial_workspace_name.to_string(),
                ].join(",")
            }),


            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAccountRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAccountRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account>,
            pub initial_workspace_name: Vec<String>,
            pub organization_id: Vec<String>,
            pub tenant_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAccountRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "initialWorkspaceName" => intermediate_rep.initial_workspace_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAccountRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAccountRequest {
            account: intermediate_rep.account.into_iter().next(),
            initial_workspace_name: intermediate_rep.initial_workspace_name.into_iter().next(),
            organization_id: intermediate_rep.organization_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAccountRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAccountRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAccountRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateAccountRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateAccountRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAccountRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateAccountRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAccountRequest1 {
    #[serde(rename = "auth0UserId")]
    pub auth0_user_id: String,

    #[serde(rename = "email")]
    pub email: String,

    #[serde(rename = "baseDirectory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_directory: Option<String>,

    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<String>,

    #[serde(rename = "orgId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "roles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub roles: Option<Vec<String>>,

    #[serde(rename = "permissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<Vec<String>>,

    #[serde(rename = "mfaEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mfa_enabled: Option<bool>,

    #[serde(rename = "complianceLevel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_level: Option<models::ComplianceLevel>,

    #[serde(rename = "preferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferences: Option<std::collections::HashMap<String, String>>,

}


impl CreateAccountRequest1 {
    #[allow(clippy::new_without_default)]
    pub fn new(auth0_user_id: String, email: String, ) -> CreateAccountRequest1 {
        CreateAccountRequest1 {
            auth0_user_id,
            email,
            base_directory: None,
            region: None,
            org_id: None,
            tenant_id: None,
            roles: None,
            permissions: None,
            mfa_enabled: None,
            compliance_level: None,
            preferences: None,
        }
    }
}

/// Converts the CreateAccountRequest1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateAccountRequest1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("auth0UserId".to_string()),
            Some(self.auth0_user_id.to_string()),


            Some("email".to_string()),
            Some(self.email.to_string()),


            self.base_directory.as_ref().map(|base_directory| {
                [
                    "baseDirectory".to_string(),
                    base_directory.to_string(),
                ].join(",")
            }),


            self.region.as_ref().map(|region| {
                [
                    "region".to_string(),
                    region.to_string(),
                ].join(",")
            }),


            self.org_id.as_ref().map(|org_id| {
                [
                    "orgId".to_string(),
                    org_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.roles.as_ref().map(|roles| {
                [
                    "roles".to_string(),
                    roles.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.permissions.as_ref().map(|permissions| {
                [
                    "permissions".to_string(),
                    permissions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mfa_enabled.as_ref().map(|mfa_enabled| {
                [
                    "mfaEnabled".to_string(),
                    mfa_enabled.to_string(),
                ].join(",")
            }),

            // Skipping complianceLevel in query parameter serialization

            // Skipping preferences in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAccountRequest1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAccountRequest1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auth0_user_id: Vec<String>,
            pub email: Vec<String>,
            pub base_directory: Vec<String>,
            pub region: Vec<String>,
            pub org_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub roles: Vec<Vec<String>>,
            pub permissions: Vec<Vec<String>>,
            pub mfa_enabled: Vec<bool>,
            pub compliance_level: Vec<models::ComplianceLevel>,
            pub preferences: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAccountRequest1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "auth0UserId" => intermediate_rep.auth0_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baseDirectory" => intermediate_rep.base_directory.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orgId" => intermediate_rep.org_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "roles" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAccountRequest1".to_string()),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAccountRequest1".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mfaEnabled" => intermediate_rep.mfa_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complianceLevel" => intermediate_rep.compliance_level.push(<models::ComplianceLevel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferences" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAccountRequest1".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAccountRequest1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAccountRequest1 {
            auth0_user_id: intermediate_rep.auth0_user_id.into_iter().next().ok_or_else(|| "auth0UserId missing in CreateAccountRequest1".to_string())?,
            email: intermediate_rep.email.into_iter().next().ok_or_else(|| "email missing in CreateAccountRequest1".to_string())?,
            base_directory: intermediate_rep.base_directory.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
            org_id: intermediate_rep.org_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            roles: intermediate_rep.roles.into_iter().next(),
            permissions: intermediate_rep.permissions.into_iter().next(),
            mfa_enabled: intermediate_rep.mfa_enabled.into_iter().next(),
            compliance_level: intermediate_rep.compliance_level.into_iter().next(),
            preferences: intermediate_rep.preferences.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAccountRequest1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAccountRequest1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAccountRequest1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateAccountRequest1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateAccountRequest1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAccountRequest1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateAccountRequest1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAccountResponse {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account>,

    #[serde(rename = "initialWorkspaceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_workspace_id: Option<String>,

}


impl CreateAccountResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateAccountResponse {
        CreateAccountResponse {
            account: None,
            initial_workspace_id: None,
        }
    }
}

/// Converts the CreateAccountResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateAccountResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization


            self.initial_workspace_id.as_ref().map(|initial_workspace_id| {
                [
                    "initialWorkspaceId".to_string(),
                    initial_workspace_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAccountResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAccountResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account>,
            pub initial_workspace_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAccountResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "initialWorkspaceId" => intermediate_rep.initial_workspace_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAccountResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAccountResponse {
            account: intermediate_rep.account.into_iter().next(),
            initial_workspace_id: intermediate_rep.initial_workspace_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAccountResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAccountResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAccountResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateAccountResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateAccountResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAccountResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateAccountResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAccountResponse1 {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account1>,

    #[serde(rename = "initialWorkspaceName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_workspace_name: Option<String>,

}


impl CreateAccountResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateAccountResponse1 {
        CreateAccountResponse1 {
            account: None,
            initial_workspace_name: None,
        }
    }
}

/// Converts the CreateAccountResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateAccountResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization


            self.initial_workspace_name.as_ref().map(|initial_workspace_name| {
                [
                    "initialWorkspaceName".to_string(),
                    initial_workspace_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAccountResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAccountResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account1>,
            pub initial_workspace_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAccountResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "initialWorkspaceName" => intermediate_rep.initial_workspace_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAccountResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAccountResponse1 {
            account: intermediate_rep.account.into_iter().next(),
            initial_workspace_name: intermediate_rep.initial_workspace_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAccountResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAccountResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAccountResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateAccountResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateAccountResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAccountResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateAccountResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateApiKeyRequest {
    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

    #[serde(rename = "workspaceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<String>>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "maxUses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_uses: Option<i32>,

    #[serde(rename = "allowedIps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_ips: Option<Vec<String>>,

    #[serde(rename = "rateLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limit: Option<i32>,

    #[serde(rename = "enforceSigning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_signing: Option<bool>,

    #[serde(rename = "allowedSignatureAlgorithms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_signature_algorithms: Option<Vec<String>>,

    #[serde(rename = "enforceMutualTls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_mutual_tls: Option<bool>,

    #[serde(rename = "alertEmails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_emails: Option<Vec<String>>,

    #[serde(rename = "alertOnQuotaThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_on_quota_threshold: Option<bool>,

    #[serde(rename = "quotaAlertThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quota_alert_threshold: Option<f32>,

}


impl CreateApiKeyRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateApiKeyRequest {
        CreateApiKeyRequest {
            organization_id: None,
            workspace_id: None,
            tenant_id: None,
            account_id: None,
            name: None,
            description: None,
            scopes: None,
            expires_at: None,
            max_uses: None,
            allowed_ips: None,
            rate_limit: None,
            enforce_signing: None,
            allowed_signature_algorithms: None,
            enforce_mutual_tls: None,
            alert_emails: None,
            alert_on_quota_threshold: None,
            quota_alert_threshold: None,
        }
    }
}

/// Converts the CreateApiKeyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateApiKeyRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),


            self.workspace_id.as_ref().map(|workspace_id| {
                [
                    "workspaceId".to_string(),
                    workspace_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.account_id.as_ref().map(|account_id| {
                [
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping expiresAt in query parameter serialization


            self.max_uses.as_ref().map(|max_uses| {
                [
                    "maxUses".to_string(),
                    max_uses.to_string(),
                ].join(",")
            }),


            self.allowed_ips.as_ref().map(|allowed_ips| {
                [
                    "allowedIps".to_string(),
                    allowed_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.rate_limit.as_ref().map(|rate_limit| {
                [
                    "rateLimit".to_string(),
                    rate_limit.to_string(),
                ].join(",")
            }),


            self.enforce_signing.as_ref().map(|enforce_signing| {
                [
                    "enforceSigning".to_string(),
                    enforce_signing.to_string(),
                ].join(",")
            }),


            self.allowed_signature_algorithms.as_ref().map(|allowed_signature_algorithms| {
                [
                    "allowedSignatureAlgorithms".to_string(),
                    allowed_signature_algorithms.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.enforce_mutual_tls.as_ref().map(|enforce_mutual_tls| {
                [
                    "enforceMutualTls".to_string(),
                    enforce_mutual_tls.to_string(),
                ].join(",")
            }),


            self.alert_emails.as_ref().map(|alert_emails| {
                [
                    "alertEmails".to_string(),
                    alert_emails.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.alert_on_quota_threshold.as_ref().map(|alert_on_quota_threshold| {
                [
                    "alertOnQuotaThreshold".to_string(),
                    alert_on_quota_threshold.to_string(),
                ].join(",")
            }),


            self.quota_alert_threshold.as_ref().map(|quota_alert_threshold| {
                [
                    "quotaAlertThreshold".to_string(),
                    quota_alert_threshold.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateApiKeyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateApiKeyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization_id: Vec<String>,
            pub workspace_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub account_id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub scopes: Vec<Vec<String>>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub max_uses: Vec<i32>,
            pub allowed_ips: Vec<Vec<String>>,
            pub rate_limit: Vec<i32>,
            pub enforce_signing: Vec<bool>,
            pub allowed_signature_algorithms: Vec<Vec<String>>,
            pub enforce_mutual_tls: Vec<bool>,
            pub alert_emails: Vec<Vec<String>>,
            pub alert_on_quota_threshold: Vec<bool>,
            pub quota_alert_threshold: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateApiKeyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspaceId" => intermediate_rep.workspace_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "scopes" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateApiKeyRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxUses" => intermediate_rep.max_uses.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedIps" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateApiKeyRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "rateLimit" => intermediate_rep.rate_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enforceSigning" => intermediate_rep.enforce_signing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedSignatureAlgorithms" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateApiKeyRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "enforceMutualTls" => intermediate_rep.enforce_mutual_tls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "alertEmails" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateApiKeyRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "alertOnQuotaThreshold" => intermediate_rep.alert_on_quota_threshold.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quotaAlertThreshold" => intermediate_rep.quota_alert_threshold.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateApiKeyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateApiKeyRequest {
            organization_id: intermediate_rep.organization_id.into_iter().next(),
            workspace_id: intermediate_rep.workspace_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            account_id: intermediate_rep.account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            max_uses: intermediate_rep.max_uses.into_iter().next(),
            allowed_ips: intermediate_rep.allowed_ips.into_iter().next(),
            rate_limit: intermediate_rep.rate_limit.into_iter().next(),
            enforce_signing: intermediate_rep.enforce_signing.into_iter().next(),
            allowed_signature_algorithms: intermediate_rep.allowed_signature_algorithms.into_iter().next(),
            enforce_mutual_tls: intermediate_rep.enforce_mutual_tls.into_iter().next(),
            alert_emails: intermediate_rep.alert_emails.into_iter().next(),
            alert_on_quota_threshold: intermediate_rep.alert_on_quota_threshold.into_iter().next(),
            quota_alert_threshold: intermediate_rep.quota_alert_threshold.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateApiKeyRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateApiKeyRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateApiKeyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateApiKeyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateApiKeyRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateApiKeyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateApiKeyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateApiKeyResponse {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::ApiKey>,

    #[serde(rename = "keyValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_value: Option<String>,

}


impl CreateApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateApiKeyResponse {
        CreateApiKeyResponse {
            api_key: None,
            key_value: None,
        }
    }
}

/// Converts the CreateApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization


            self.key_value.as_ref().map(|key_value| {
                [
                    "keyValue".to_string(),
                    key_value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::ApiKey>,
            pub key_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::ApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyValue" => intermediate_rep.key_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateApiKeyResponse {
            api_key: intermediate_rep.api_key.into_iter().next(),
            key_value: intermediate_rep.key_value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateOrganizationRequest {
    #[serde(rename = "organization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<models::Organization>,

}


impl CreateOrganizationRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateOrganizationRequest {
        CreateOrganizationRequest {
            organization: None,
        }
    }
}

/// Converts the CreateOrganizationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateOrganizationRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping organization in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateOrganizationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateOrganizationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization: Vec<models::Organization>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateOrganizationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organization" => intermediate_rep.organization.push(<models::Organization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateOrganizationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateOrganizationRequest {
            organization: intermediate_rep.organization.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateOrganizationRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateOrganizationRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateOrganizationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateOrganizationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateOrganizationRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateOrganizationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateOrganizationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateOrganizationResponse {
    #[serde(rename = "organization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<models::Organization>,

}


impl CreateOrganizationResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateOrganizationResponse {
        CreateOrganizationResponse {
            organization: None,
        }
    }
}

/// Converts the CreateOrganizationResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateOrganizationResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping organization in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateOrganizationResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateOrganizationResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization: Vec<models::Organization>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateOrganizationResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organization" => intermediate_rep.organization.push(<models::Organization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateOrganizationResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateOrganizationResponse {
            organization: intermediate_rep.organization.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateOrganizationResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateOrganizationResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateOrganizationResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateOrganizationResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateOrganizationResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateOrganizationResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateOrganizationResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateScrapingJobRequest {
    #[serde(rename = "authPlatformUserId")]
    pub auth_platform_user_id: String,

    #[serde(rename = "orgId")]
    pub org_id: String,

    #[serde(rename = "tenantId")]
    pub tenant_id: String,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "keywords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<String>>,

    #[serde(rename = "lang")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lang: Option<String>,

    #[serde(rename = "zoom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub zoom: Option<i32>,

    #[serde(rename = "lat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lat: Option<String>,

    #[serde(rename = "lon")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lon: Option<String>,

    #[serde(rename = "fastMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fast_mode: Option<bool>,

    #[serde(rename = "radius")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub radius: Option<i32>,

    #[serde(rename = "depth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub depth: Option<i32>,

    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<bool>,

    #[serde(rename = "maxTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_time: Option<i32>,

    #[serde(rename = "proxies")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub proxies: Option<Vec<String>>,

}


impl CreateScrapingJobRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(auth_platform_user_id: String, org_id: String, tenant_id: String, ) -> CreateScrapingJobRequest {
        CreateScrapingJobRequest {
            auth_platform_user_id,
            org_id,
            tenant_id,
            name: None,
            keywords: None,
            lang: None,
            zoom: None,
            lat: None,
            lon: None,
            fast_mode: None,
            radius: None,
            depth: None,
            email: None,
            max_time: None,
            proxies: None,
        }
    }
}

/// Converts the CreateScrapingJobRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateScrapingJobRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("authPlatformUserId".to_string()),
            Some(self.auth_platform_user_id.to_string()),


            Some("orgId".to_string()),
            Some(self.org_id.to_string()),


            Some("tenantId".to_string()),
            Some(self.tenant_id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.keywords.as_ref().map(|keywords| {
                [
                    "keywords".to_string(),
                    keywords.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.lang.as_ref().map(|lang| {
                [
                    "lang".to_string(),
                    lang.to_string(),
                ].join(",")
            }),


            self.zoom.as_ref().map(|zoom| {
                [
                    "zoom".to_string(),
                    zoom.to_string(),
                ].join(",")
            }),


            self.lat.as_ref().map(|lat| {
                [
                    "lat".to_string(),
                    lat.to_string(),
                ].join(",")
            }),


            self.lon.as_ref().map(|lon| {
                [
                    "lon".to_string(),
                    lon.to_string(),
                ].join(",")
            }),


            self.fast_mode.as_ref().map(|fast_mode| {
                [
                    "fastMode".to_string(),
                    fast_mode.to_string(),
                ].join(",")
            }),


            self.radius.as_ref().map(|radius| {
                [
                    "radius".to_string(),
                    radius.to_string(),
                ].join(",")
            }),


            self.depth.as_ref().map(|depth| {
                [
                    "depth".to_string(),
                    depth.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.max_time.as_ref().map(|max_time| {
                [
                    "maxTime".to_string(),
                    max_time.to_string(),
                ].join(",")
            }),


            self.proxies.as_ref().map(|proxies| {
                [
                    "proxies".to_string(),
                    proxies.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateScrapingJobRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateScrapingJobRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auth_platform_user_id: Vec<String>,
            pub org_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub name: Vec<String>,
            pub keywords: Vec<Vec<String>>,
            pub lang: Vec<String>,
            pub zoom: Vec<i32>,
            pub lat: Vec<String>,
            pub lon: Vec<String>,
            pub fast_mode: Vec<bool>,
            pub radius: Vec<i32>,
            pub depth: Vec<i32>,
            pub email: Vec<bool>,
            pub max_time: Vec<i32>,
            pub proxies: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateScrapingJobRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authPlatformUserId" => intermediate_rep.auth_platform_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orgId" => intermediate_rep.org_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateScrapingJobRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "lang" => intermediate_rep.lang.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "zoom" => intermediate_rep.zoom.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lat" => intermediate_rep.lat.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lon" => intermediate_rep.lon.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fastMode" => intermediate_rep.fast_mode.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "radius" => intermediate_rep.radius.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "depth" => intermediate_rep.depth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxTime" => intermediate_rep.max_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "proxies" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateScrapingJobRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateScrapingJobRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateScrapingJobRequest {
            auth_platform_user_id: intermediate_rep.auth_platform_user_id.into_iter().next().ok_or_else(|| "authPlatformUserId missing in CreateScrapingJobRequest".to_string())?,
            org_id: intermediate_rep.org_id.into_iter().next().ok_or_else(|| "orgId missing in CreateScrapingJobRequest".to_string())?,
            tenant_id: intermediate_rep.tenant_id.into_iter().next().ok_or_else(|| "tenantId missing in CreateScrapingJobRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            keywords: intermediate_rep.keywords.into_iter().next(),
            lang: intermediate_rep.lang.into_iter().next(),
            zoom: intermediate_rep.zoom.into_iter().next(),
            lat: intermediate_rep.lat.into_iter().next(),
            lon: intermediate_rep.lon.into_iter().next(),
            fast_mode: intermediate_rep.fast_mode.into_iter().next(),
            radius: intermediate_rep.radius.into_iter().next(),
            depth: intermediate_rep.depth.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            max_time: intermediate_rep.max_time.into_iter().next(),
            proxies: intermediate_rep.proxies.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateScrapingJobRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateScrapingJobRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateScrapingJobRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateScrapingJobRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateScrapingJobRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateScrapingJobRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateScrapingJobRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateScrapingJobResponse {
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub job_id: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BackgroundJobStatus>,

}


impl CreateScrapingJobResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateScrapingJobResponse {
        CreateScrapingJobResponse {
            job_id: None,
            status: None,
        }
    }
}

/// Converts the CreateScrapingJobResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateScrapingJobResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.job_id.as_ref().map(|job_id| {
                [
                    "jobId".to_string(),
                    job_id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateScrapingJobResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateScrapingJobResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub job_id: Vec<String>,
            pub status: Vec<models::BackgroundJobStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateScrapingJobResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jobId" => intermediate_rep.job_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::BackgroundJobStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateScrapingJobResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateScrapingJobResponse {
            job_id: intermediate_rep.job_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateScrapingJobResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateScrapingJobResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateScrapingJobResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateScrapingJobResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateScrapingJobResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateScrapingJobResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateScrapingJobResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTenantApiKeyRequest {
    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::TenantApiKey>,

}


impl CreateTenantApiKeyRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateTenantApiKeyRequest {
        CreateTenantApiKeyRequest {
            organization_id: None,
            tenant_id: None,
            api_key: None,
        }
    }
}

/// Converts the CreateTenantApiKeyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateTenantApiKeyRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),

            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTenantApiKeyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTenantApiKeyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub api_key: Vec<models::TenantApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTenantApiKeyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::TenantApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTenantApiKeyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTenantApiKeyRequest {
            organization_id: intermediate_rep.organization_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTenantApiKeyRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTenantApiKeyRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTenantApiKeyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTenantApiKeyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateTenantApiKeyRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTenantApiKeyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTenantApiKeyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTenantApiKeyResponse {
    #[serde(rename = "keyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,

    #[serde(rename = "keyValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_value: Option<String>,

}


impl CreateTenantApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateTenantApiKeyResponse {
        CreateTenantApiKeyResponse {
            key_id: None,
            key_value: None,
        }
    }
}

/// Converts the CreateTenantApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateTenantApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key_id.as_ref().map(|key_id| {
                [
                    "keyId".to_string(),
                    key_id.to_string(),
                ].join(",")
            }),


            self.key_value.as_ref().map(|key_value| {
                [
                    "keyValue".to_string(),
                    key_value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTenantApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTenantApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key_id: Vec<String>,
            pub key_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTenantApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "keyId" => intermediate_rep.key_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyValue" => intermediate_rep.key_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTenantApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTenantApiKeyResponse {
            key_id: intermediate_rep.key_id.into_iter().next(),
            key_value: intermediate_rep.key_value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTenantApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTenantApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTenantApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTenantApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateTenantApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTenantApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTenantApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTenantBody {
    #[serde(rename = "tenant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant: Option<models::Tenant>,

}


impl CreateTenantBody {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateTenantBody {
        CreateTenantBody {
            tenant: None,
        }
    }
}

/// Converts the CreateTenantBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateTenantBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tenant in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTenantBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTenantBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant: Vec<models::Tenant>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTenantBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tenant" => intermediate_rep.tenant.push(<models::Tenant as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTenantBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTenantBody {
            tenant: intermediate_rep.tenant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTenantBody> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTenantBody>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTenantBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTenantBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateTenantBody> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTenantBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTenantBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTenantResponse {
    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

}


impl CreateTenantResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateTenantResponse {
        CreateTenantResponse {
            tenant_id: None,
        }
    }
}

/// Converts the CreateTenantResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateTenantResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTenantResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTenantResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTenantResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTenantResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTenantResponse {
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTenantResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTenantResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTenantResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTenantResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateTenantResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTenantResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTenantResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWebhookRequest {
    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

    #[serde(rename = "workspaceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<models::WebhookConfig>,

}


impl CreateWebhookRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWebhookRequest {
        CreateWebhookRequest {
            organization_id: None,
            workspace_id: None,
            tenant_id: None,
            account_id: None,
            webhook: None,
        }
    }
}

/// Converts the CreateWebhookRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWebhookRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),


            self.workspace_id.as_ref().map(|workspace_id| {
                [
                    "workspaceId".to_string(),
                    workspace_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.account_id.as_ref().map(|account_id| {
                [
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),

            // Skipping webhook in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWebhookRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWebhookRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization_id: Vec<String>,
            pub workspace_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub account_id: Vec<String>,
            pub webhook: Vec<models::WebhookConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWebhookRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspaceId" => intermediate_rep.workspace_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "webhook" => intermediate_rep.webhook.push(<models::WebhookConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWebhookRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWebhookRequest {
            organization_id: intermediate_rep.organization_id.into_iter().next(),
            workspace_id: intermediate_rep.workspace_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            account_id: intermediate_rep.account_id.into_iter().next(),
            webhook: intermediate_rep.webhook.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWebhookRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWebhookRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWebhookRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWebhookRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWebhookRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWebhookRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWebhookRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWebhookResponse {
    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<models::WebhookConfig>,

}


impl CreateWebhookResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWebhookResponse {
        CreateWebhookResponse {
            webhook: None,
        }
    }
}

/// Converts the CreateWebhookResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWebhookResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping webhook in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWebhookResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWebhookResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub webhook: Vec<models::WebhookConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWebhookResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "webhook" => intermediate_rep.webhook.push(<models::WebhookConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWebhookResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWebhookResponse {
            webhook: intermediate_rep.webhook.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWebhookResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWebhookResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWebhookResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWebhookResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWebhookResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWebhookResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWebhookResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWorkflowBody {
    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::ScrapingWorkflow>,

}


impl CreateWorkflowBody {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWorkflowBody {
        CreateWorkflowBody {
            workflow: None,
        }
    }
}

/// Converts the CreateWorkflowBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWorkflowBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWorkflowBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWorkflowBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflow: Vec<models::ScrapingWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWorkflowBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::ScrapingWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWorkflowBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWorkflowBody {
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWorkflowBody> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWorkflowBody>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWorkflowBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWorkflowBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWorkflowBody> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWorkflowBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWorkflowBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWorkflowResponse {
    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::ScrapingWorkflow>,

}


impl CreateWorkflowResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWorkflowResponse {
        CreateWorkflowResponse {
            workflow: None,
        }
    }
}

/// Converts the CreateWorkflowResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWorkflowResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWorkflowResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWorkflowResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflow: Vec<models::ScrapingWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWorkflowResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::ScrapingWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWorkflowResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWorkflowResponse {
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWorkflowResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWorkflowResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWorkflowResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWorkflowResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWorkflowResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWorkflowResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWorkflowResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWorkspaceRequest {
    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace>,

    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

}


impl CreateWorkspaceRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWorkspaceRequest {
        CreateWorkspaceRequest {
            workspace: None,
            account_id: None,
        }
    }
}

/// Converts the CreateWorkspaceRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWorkspaceRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspace in query parameter serialization


            self.account_id.as_ref().map(|account_id| {
                [
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWorkspaceRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWorkspaceRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspace: Vec<models::Workspace>,
            pub account_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWorkspaceRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWorkspaceRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWorkspaceRequest {
            workspace: intermediate_rep.workspace.into_iter().next(),
            account_id: intermediate_rep.account_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWorkspaceRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWorkspaceRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWorkspaceRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWorkspaceRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWorkspaceRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWorkspaceRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWorkspaceRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWorkspaceRequest1 {
    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "storageQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_quota: Option<String>,

    #[serde(rename = "allowPublicSharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_public_sharing: Option<bool>,

    #[serde(rename = "requireApproval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_approval: Option<bool>,

    #[serde(rename = "gdprCompliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gdpr_compliant: Option<bool>,

    #[serde(rename = "hipaaCompliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hipaa_compliant: Option<bool>,

}


impl CreateWorkspaceRequest1 {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, ) -> CreateWorkspaceRequest1 {
        CreateWorkspaceRequest1 {
            account_id: None,
            name,
            storage_quota: None,
            allow_public_sharing: None,
            require_approval: None,
            gdpr_compliant: None,
            hipaa_compliant: None,
        }
    }
}

/// Converts the CreateWorkspaceRequest1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWorkspaceRequest1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.account_id.as_ref().map(|account_id| {
                [
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.storage_quota.as_ref().map(|storage_quota| {
                [
                    "storageQuota".to_string(),
                    storage_quota.to_string(),
                ].join(",")
            }),


            self.allow_public_sharing.as_ref().map(|allow_public_sharing| {
                [
                    "allowPublicSharing".to_string(),
                    allow_public_sharing.to_string(),
                ].join(",")
            }),


            self.require_approval.as_ref().map(|require_approval| {
                [
                    "requireApproval".to_string(),
                    require_approval.to_string(),
                ].join(",")
            }),


            self.gdpr_compliant.as_ref().map(|gdpr_compliant| {
                [
                    "gdprCompliant".to_string(),
                    gdpr_compliant.to_string(),
                ].join(",")
            }),


            self.hipaa_compliant.as_ref().map(|hipaa_compliant| {
                [
                    "hipaaCompliant".to_string(),
                    hipaa_compliant.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWorkspaceRequest1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWorkspaceRequest1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account_id: Vec<String>,
            pub name: Vec<String>,
            pub storage_quota: Vec<String>,
            pub allow_public_sharing: Vec<bool>,
            pub require_approval: Vec<bool>,
            pub gdpr_compliant: Vec<bool>,
            pub hipaa_compliant: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWorkspaceRequest1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageQuota" => intermediate_rep.storage_quota.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allowPublicSharing" => intermediate_rep.allow_public_sharing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requireApproval" => intermediate_rep.require_approval.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gdprCompliant" => intermediate_rep.gdpr_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hipaaCompliant" => intermediate_rep.hipaa_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWorkspaceRequest1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWorkspaceRequest1 {
            account_id: intermediate_rep.account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CreateWorkspaceRequest1".to_string())?,
            storage_quota: intermediate_rep.storage_quota.into_iter().next(),
            allow_public_sharing: intermediate_rep.allow_public_sharing.into_iter().next(),
            require_approval: intermediate_rep.require_approval.into_iter().next(),
            gdpr_compliant: intermediate_rep.gdpr_compliant.into_iter().next(),
            hipaa_compliant: intermediate_rep.hipaa_compliant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWorkspaceRequest1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWorkspaceRequest1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWorkspaceRequest1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWorkspaceRequest1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWorkspaceRequest1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWorkspaceRequest1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWorkspaceRequest1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWorkspaceResponse {
    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace>,

}


impl CreateWorkspaceResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWorkspaceResponse {
        CreateWorkspaceResponse {
            workspace: None,
        }
    }
}

/// Converts the CreateWorkspaceResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWorkspaceResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspace in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWorkspaceResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWorkspaceResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspace: Vec<models::Workspace>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWorkspaceResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWorkspaceResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWorkspaceResponse {
            workspace: intermediate_rep.workspace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWorkspaceResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWorkspaceResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWorkspaceResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWorkspaceResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWorkspaceResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWorkspaceResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWorkspaceResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateWorkspaceResponse1 {
    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace1>,

}


impl CreateWorkspaceResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateWorkspaceResponse1 {
        CreateWorkspaceResponse1 {
            workspace: None,
        }
    }
}

/// Converts the CreateWorkspaceResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateWorkspaceResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspace in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateWorkspaceResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateWorkspaceResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspace: Vec<models::Workspace1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateWorkspaceResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateWorkspaceResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateWorkspaceResponse1 {
            workspace: intermediate_rep.workspace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateWorkspaceResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateWorkspaceResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateWorkspaceResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateWorkspaceResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateWorkspaceResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateWorkspaceResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateWorkspaceResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DataProfile {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "profileType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub profile_type: Option<String>,

    #[serde(rename = "dataFields")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_fields: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "isDefault")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_default: Option<bool>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl DataProfile {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DataProfile {
        DataProfile {
            id: None,
            name: None,
            profile_type: None,
            data_fields: None,
            is_default: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the DataProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DataProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.profile_type.as_ref().map(|profile_type| {
                [
                    "profileType".to_string(),
                    profile_type.to_string(),
                ].join(",")
            }),

            // Skipping dataFields in query parameter serialization


            self.is_default.as_ref().map(|is_default| {
                [
                    "isDefault".to_string(),
                    is_default.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DataProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DataProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub profile_type: Vec<String>,
            pub data_fields: Vec<std::collections::HashMap<String, String>>,
            pub is_default: Vec<bool>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DataProfile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "profileType" => intermediate_rep.profile_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dataFields" => return std::result::Result::Err("Parsing a container in this style is not supported in DataProfile".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isDefault" => intermediate_rep.is_default.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DataProfile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DataProfile {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            profile_type: intermediate_rep.profile_type.into_iter().next(),
            data_fields: intermediate_rep.data_fields.into_iter().next(),
            is_default: intermediate_rep.is_default.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DataProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DataProfile>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DataProfile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DataProfile - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DataProfile> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DataProfile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DataProfile - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DayOfWeek {
    #[serde(rename = "DAY_OF_WEEK_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "DAY_OF_WEEK_MONDAY")]
    Monday,
    #[serde(rename = "DAY_OF_WEEK_TUESDAY")]
    Tuesday,
    #[serde(rename = "DAY_OF_WEEK_WEDNESDAY")]
    Wednesday,
    #[serde(rename = "DAY_OF_WEEK_THURSDAY")]
    Thursday,
    #[serde(rename = "DAY_OF_WEEK_FRIDAY")]
    Friday,
    #[serde(rename = "DAY_OF_WEEK_SATURDAY")]
    Saturday,
    #[serde(rename = "DAY_OF_WEEK_SUNDAY")]
    Sunday,
}

impl std::fmt::Display for DayOfWeek {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DayOfWeek::Unspecified => write!(f, "DAY_OF_WEEK_UNSPECIFIED"),
            DayOfWeek::Monday => write!(f, "DAY_OF_WEEK_MONDAY"),
            DayOfWeek::Tuesday => write!(f, "DAY_OF_WEEK_TUESDAY"),
            DayOfWeek::Wednesday => write!(f, "DAY_OF_WEEK_WEDNESDAY"),
            DayOfWeek::Thursday => write!(f, "DAY_OF_WEEK_THURSDAY"),
            DayOfWeek::Friday => write!(f, "DAY_OF_WEEK_FRIDAY"),
            DayOfWeek::Saturday => write!(f, "DAY_OF_WEEK_SATURDAY"),
            DayOfWeek::Sunday => write!(f, "DAY_OF_WEEK_SUNDAY"),
        }
    }
}

impl std::str::FromStr for DayOfWeek {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DAY_OF_WEEK_UNSPECIFIED" => std::result::Result::Ok(DayOfWeek::Unspecified),
            "DAY_OF_WEEK_MONDAY" => std::result::Result::Ok(DayOfWeek::Monday),
            "DAY_OF_WEEK_TUESDAY" => std::result::Result::Ok(DayOfWeek::Tuesday),
            "DAY_OF_WEEK_WEDNESDAY" => std::result::Result::Ok(DayOfWeek::Wednesday),
            "DAY_OF_WEEK_THURSDAY" => std::result::Result::Ok(DayOfWeek::Thursday),
            "DAY_OF_WEEK_FRIDAY" => std::result::Result::Ok(DayOfWeek::Friday),
            "DAY_OF_WEEK_SATURDAY" => std::result::Result::Ok(DayOfWeek::Saturday),
            "DAY_OF_WEEK_SUNDAY" => std::result::Result::Ok(DayOfWeek::Sunday),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteAccountResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteAccountResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteAccountResponse {
        DeleteAccountResponse {
            success: None,
        }
    }
}

/// Converts the DeleteAccountResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteAccountResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteAccountResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteAccountResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteAccountResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteAccountResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteAccountResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteAccountResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteAccountResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteAccountResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteAccountResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteAccountResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteAccountResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteAccountResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteApiKeyResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteApiKeyResponse {
        DeleteApiKeyResponse {
            success: None,
        }
    }
}

/// Converts the DeleteApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteApiKeyResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOrganizationResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteOrganizationResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteOrganizationResponse {
        DeleteOrganizationResponse {
            success: None,
        }
    }
}

/// Converts the DeleteOrganizationResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOrganizationResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOrganizationResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOrganizationResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOrganizationResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOrganizationResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOrganizationResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOrganizationResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOrganizationResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOrganizationResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOrganizationResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOrganizationResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOrganizationResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOrganizationResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteScrapingJobResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteScrapingJobResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteScrapingJobResponse {
        DeleteScrapingJobResponse {
            success: None,
        }
    }
}

/// Converts the DeleteScrapingJobResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteScrapingJobResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteScrapingJobResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteScrapingJobResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteScrapingJobResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteScrapingJobResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteScrapingJobResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteScrapingJobResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteScrapingJobResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteScrapingJobResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteScrapingJobResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteScrapingJobResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteScrapingJobResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteScrapingJobResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteTenantApiKeyResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteTenantApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteTenantApiKeyResponse {
        DeleteTenantApiKeyResponse {
            success: None,
        }
    }
}

/// Converts the DeleteTenantApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteTenantApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteTenantApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteTenantApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteTenantApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteTenantApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteTenantApiKeyResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteTenantApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteTenantApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteTenantApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteTenantApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteTenantApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteTenantApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteTenantApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteTenantResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteTenantResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteTenantResponse {
        DeleteTenantResponse {
            success: None,
        }
    }
}

/// Converts the DeleteTenantResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteTenantResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteTenantResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteTenantResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteTenantResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteTenantResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteTenantResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteTenantResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteTenantResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteTenantResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteTenantResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteTenantResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteTenantResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteTenantResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteWebhookResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteWebhookResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteWebhookResponse {
        DeleteWebhookResponse {
            success: None,
        }
    }
}

/// Converts the DeleteWebhookResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteWebhookResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteWebhookResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteWebhookResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteWebhookResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteWebhookResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteWebhookResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteWebhookResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteWebhookResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteWebhookResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteWebhookResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteWebhookResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteWebhookResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteWebhookResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteWorkspaceResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl DeleteWorkspaceResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteWorkspaceResponse {
        DeleteWorkspaceResponse {
            success: None,
        }
    }
}

/// Converts the DeleteWorkspaceResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteWorkspaceResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteWorkspaceResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteWorkspaceResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteWorkspaceResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteWorkspaceResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteWorkspaceResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteWorkspaceResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteWorkspaceResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteWorkspaceResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteWorkspaceResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteWorkspaceResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteWorkspaceResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteWorkspaceResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dependency {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

    #[serde(rename = "latency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub latency: Option<i32>,

}


impl Dependency {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Dependency {
        Dependency {
            name: None,
            status: None,
            error: None,
            latency: None,
        }
    }
}

/// Converts the Dependency value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Dependency {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.error.as_ref().map(|error| {
                [
                    "error".to_string(),
                    error.to_string(),
                ].join(",")
            }),


            self.latency.as_ref().map(|latency| {
                [
                    "latency".to_string(),
                    latency.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Dependency value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Dependency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<String>,
            pub error: Vec<String>,
            pub latency: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Dependency".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "latency" => intermediate_rep.latency.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Dependency".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Dependency {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
            latency: intermediate_rep.latency.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Dependency> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Dependency>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Dependency>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Dependency - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Dependency> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Dependency as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Dependency - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DocumentBranch {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "baseVersionHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_version_hash: Option<String>,

    #[serde(rename = "currentHeadHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_head_hash: Option<String>,

    #[serde(rename = "purpose")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub purpose: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "reviewers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<String>>,

    #[serde(rename = "branchMetadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch_metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "isLocked")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_locked: Option<bool>,

    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "merges")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges: Option<Vec<models::BranchMerge>>,

    #[serde(rename = "policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub policy: Option<models::BranchPolicy>,

    #[serde(rename = "mergeRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_requests: Option<Vec<models::MergeRequest>>,

}


impl DocumentBranch {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DocumentBranch {
        DocumentBranch {
            id: None,
            name: None,
            base_version_hash: None,
            current_head_hash: None,
            purpose: None,
            status: None,
            reviewers: None,
            branch_metadata: None,
            is_locked: None,
            last_updated: None,
            merges: None,
            policy: None,
            merge_requests: None,
        }
    }
}

/// Converts the DocumentBranch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DocumentBranch {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.base_version_hash.as_ref().map(|base_version_hash| {
                [
                    "baseVersionHash".to_string(),
                    base_version_hash.to_string(),
                ].join(",")
            }),


            self.current_head_hash.as_ref().map(|current_head_hash| {
                [
                    "currentHeadHash".to_string(),
                    current_head_hash.to_string(),
                ].join(",")
            }),


            self.purpose.as_ref().map(|purpose| {
                [
                    "purpose".to_string(),
                    purpose.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.reviewers.as_ref().map(|reviewers| {
                [
                    "reviewers".to_string(),
                    reviewers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping branchMetadata in query parameter serialization


            self.is_locked.as_ref().map(|is_locked| {
                [
                    "isLocked".to_string(),
                    is_locked.to_string(),
                ].join(",")
            }),

            // Skipping lastUpdated in query parameter serialization

            // Skipping merges in query parameter serialization

            // Skipping policy in query parameter serialization

            // Skipping mergeRequests in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DocumentBranch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DocumentBranch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub base_version_hash: Vec<String>,
            pub current_head_hash: Vec<String>,
            pub purpose: Vec<String>,
            pub status: Vec<String>,
            pub reviewers: Vec<Vec<String>>,
            pub branch_metadata: Vec<std::collections::HashMap<String, String>>,
            pub is_locked: Vec<bool>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
            pub merges: Vec<Vec<models::BranchMerge>>,
            pub policy: Vec<models::BranchPolicy>,
            pub merge_requests: Vec<Vec<models::MergeRequest>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DocumentBranch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baseVersionHash" => intermediate_rep.base_version_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentHeadHash" => intermediate_rep.current_head_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purpose" => intermediate_rep.purpose.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "reviewers" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentBranch".to_string()),
                    "branchMetadata" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentBranch".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isLocked" => intermediate_rep.is_locked.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "merges" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentBranch".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "policy" => intermediate_rep.policy.push(<models::BranchPolicy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "mergeRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentBranch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DocumentBranch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DocumentBranch {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            base_version_hash: intermediate_rep.base_version_hash.into_iter().next(),
            current_head_hash: intermediate_rep.current_head_hash.into_iter().next(),
            purpose: intermediate_rep.purpose.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            reviewers: intermediate_rep.reviewers.into_iter().next(),
            branch_metadata: intermediate_rep.branch_metadata.into_iter().next(),
            is_locked: intermediate_rep.is_locked.into_iter().next(),
            last_updated: intermediate_rep.last_updated.into_iter().next(),
            merges: intermediate_rep.merges.into_iter().next(),
            policy: intermediate_rep.policy.into_iter().next(),
            merge_requests: intermediate_rep.merge_requests.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DocumentBranch> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DocumentBranch>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DocumentBranch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DocumentBranch - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DocumentBranch> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DocumentBranch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DocumentBranch - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DocumentInstance {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "templateId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_id: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::DocumentStatus>,

    #[serde(rename = "fieldValues")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field_values: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "signers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signers: Option<Vec<String>>,

    #[serde(rename = "language")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,

    #[serde(rename = "isCompleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_completed: Option<bool>,

    #[serde(rename = "dueDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_date: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "generatedContent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generated_content: Option<String>,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attachments: Option<Vec<String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "signatureRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature_requests: Option<Vec<models::SignatureRequest>>,

    #[serde(rename = "aiAssistance")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ai_assistance: Option<Vec<models::AiAssistanceLog>>,

    #[serde(rename = "negotiation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negotiation: Option<models::NegotiationHistory>,

    #[serde(rename = "versions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub versions: Option<Vec<models::DocumentVersion>>,

}


impl DocumentInstance {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DocumentInstance {
        DocumentInstance {
            id: None,
            template_id: None,
            status: None,
            field_values: None,
            signers: None,
            language: None,
            is_completed: None,
            due_date: None,
            generated_content: None,
            attachments: None,
            created_at: None,
            updated_at: None,
            signature_requests: None,
            ai_assistance: None,
            negotiation: None,
            versions: None,
        }
    }
}

/// Converts the DocumentInstance value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DocumentInstance {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.template_id.as_ref().map(|template_id| {
                [
                    "templateId".to_string(),
                    template_id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping fieldValues in query parameter serialization


            self.signers.as_ref().map(|signers| {
                [
                    "signers".to_string(),
                    signers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.language.as_ref().map(|language| {
                [
                    "language".to_string(),
                    language.to_string(),
                ].join(",")
            }),


            self.is_completed.as_ref().map(|is_completed| {
                [
                    "isCompleted".to_string(),
                    is_completed.to_string(),
                ].join(",")
            }),

            // Skipping dueDate in query parameter serialization


            self.generated_content.as_ref().map(|generated_content| {
                [
                    "generatedContent".to_string(),
                    generated_content.to_string(),
                ].join(",")
            }),


            self.attachments.as_ref().map(|attachments| {
                [
                    "attachments".to_string(),
                    attachments.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping signatureRequests in query parameter serialization

            // Skipping aiAssistance in query parameter serialization

            // Skipping negotiation in query parameter serialization

            // Skipping versions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DocumentInstance value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DocumentInstance {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub template_id: Vec<String>,
            pub status: Vec<models::DocumentStatus>,
            pub field_values: Vec<std::collections::HashMap<String, String>>,
            pub signers: Vec<Vec<String>>,
            pub language: Vec<String>,
            pub is_completed: Vec<bool>,
            pub due_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub generated_content: Vec<String>,
            pub attachments: Vec<Vec<String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub signature_requests: Vec<Vec<models::SignatureRequest>>,
            pub ai_assistance: Vec<Vec<models::AiAssistanceLog>>,
            pub negotiation: Vec<models::NegotiationHistory>,
            pub versions: Vec<Vec<models::DocumentVersion>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DocumentInstance".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "templateId" => intermediate_rep.template_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::DocumentStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "fieldValues" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentInstance".to_string()),
                    "signers" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentInstance".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isCompleted" => intermediate_rep.is_completed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dueDate" => intermediate_rep.due_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generatedContent" => intermediate_rep.generated_content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "attachments" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentInstance".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "signatureRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentInstance".to_string()),
                    "aiAssistance" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentInstance".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "negotiation" => intermediate_rep.negotiation.push(<models::NegotiationHistory as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentInstance".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DocumentInstance".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DocumentInstance {
            id: intermediate_rep.id.into_iter().next(),
            template_id: intermediate_rep.template_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            field_values: intermediate_rep.field_values.into_iter().next(),
            signers: intermediate_rep.signers.into_iter().next(),
            language: intermediate_rep.language.into_iter().next(),
            is_completed: intermediate_rep.is_completed.into_iter().next(),
            due_date: intermediate_rep.due_date.into_iter().next(),
            generated_content: intermediate_rep.generated_content.into_iter().next(),
            attachments: intermediate_rep.attachments.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            signature_requests: intermediate_rep.signature_requests.into_iter().next(),
            ai_assistance: intermediate_rep.ai_assistance.into_iter().next(),
            negotiation: intermediate_rep.negotiation.into_iter().next(),
            versions: intermediate_rep.versions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DocumentInstance> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DocumentInstance>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DocumentInstance>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DocumentInstance - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DocumentInstance> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DocumentInstance as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DocumentInstance - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DocumentSnapshot {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "fileId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

    #[serde(rename = "snapshotHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub snapshot_hash: Option<String>,

    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<swagger::ByteArray>,

    #[serde(rename = "authorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_id: Option<String>,

    #[serde(rename = "reason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl DocumentSnapshot {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DocumentSnapshot {
        DocumentSnapshot {
            id: None,
            file_id: None,
            snapshot_hash: None,
            content: None,
            author_id: None,
            reason: None,
            created_at: None,
        }
    }
}

/// Converts the DocumentSnapshot value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DocumentSnapshot {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.file_id.as_ref().map(|file_id| {
                [
                    "fileId".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),


            self.snapshot_hash.as_ref().map(|snapshot_hash| {
                [
                    "snapshotHash".to_string(),
                    snapshot_hash.to_string(),
                ].join(",")
            }),

            // Skipping content in query parameter serialization
            // Skipping content in query parameter serialization


            self.author_id.as_ref().map(|author_id| {
                [
                    "authorId".to_string(),
                    author_id.to_string(),
                ].join(",")
            }),


            self.reason.as_ref().map(|reason| {
                [
                    "reason".to_string(),
                    reason.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DocumentSnapshot value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DocumentSnapshot {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub file_id: Vec<String>,
            pub snapshot_hash: Vec<String>,
            pub content: Vec<swagger::ByteArray>,
            pub author_id: Vec<String>,
            pub reason: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DocumentSnapshot".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fileId" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "snapshotHash" => intermediate_rep.snapshot_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing binary data in this style is not supported in DocumentSnapshot".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "authorId" => intermediate_rep.author_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DocumentSnapshot".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DocumentSnapshot {
            id: intermediate_rep.id.into_iter().next(),
            file_id: intermediate_rep.file_id.into_iter().next(),
            snapshot_hash: intermediate_rep.snapshot_hash.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            author_id: intermediate_rep.author_id.into_iter().next(),
            reason: intermediate_rep.reason.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DocumentSnapshot> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DocumentSnapshot>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DocumentSnapshot>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DocumentSnapshot - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DocumentSnapshot> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DocumentSnapshot as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DocumentSnapshot - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DocumentStatus {
    #[serde(rename = "DOCUMENT_STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "DOCUMENT_STATUS_DRAFT")]
    Draft,
    #[serde(rename = "DOCUMENT_STATUS_IN_REVIEW")]
    InReview,
    #[serde(rename = "DOCUMENT_STATUS_APPROVED")]
    Approved,
    #[serde(rename = "DOCUMENT_STATUS_REJECTED")]
    Rejected,
    #[serde(rename = "DOCUMENT_STATUS_EXPIRED")]
    Expired,
    #[serde(rename = "DOCUMENT_STATUS_ARCHIVED")]
    Archived,
}

impl std::fmt::Display for DocumentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DocumentStatus::Unspecified => write!(f, "DOCUMENT_STATUS_UNSPECIFIED"),
            DocumentStatus::Draft => write!(f, "DOCUMENT_STATUS_DRAFT"),
            DocumentStatus::InReview => write!(f, "DOCUMENT_STATUS_IN_REVIEW"),
            DocumentStatus::Approved => write!(f, "DOCUMENT_STATUS_APPROVED"),
            DocumentStatus::Rejected => write!(f, "DOCUMENT_STATUS_REJECTED"),
            DocumentStatus::Expired => write!(f, "DOCUMENT_STATUS_EXPIRED"),
            DocumentStatus::Archived => write!(f, "DOCUMENT_STATUS_ARCHIVED"),
        }
    }
}

impl std::str::FromStr for DocumentStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DOCUMENT_STATUS_UNSPECIFIED" => std::result::Result::Ok(DocumentStatus::Unspecified),
            "DOCUMENT_STATUS_DRAFT" => std::result::Result::Ok(DocumentStatus::Draft),
            "DOCUMENT_STATUS_IN_REVIEW" => std::result::Result::Ok(DocumentStatus::InReview),
            "DOCUMENT_STATUS_APPROVED" => std::result::Result::Ok(DocumentStatus::Approved),
            "DOCUMENT_STATUS_REJECTED" => std::result::Result::Ok(DocumentStatus::Rejected),
            "DOCUMENT_STATUS_EXPIRED" => std::result::Result::Ok(DocumentStatus::Expired),
            "DOCUMENT_STATUS_ARCHIVED" => std::result::Result::Ok(DocumentStatus::Archived),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DocumentTemplate {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "industryType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub industry_type: Option<String>,

    #[serde(rename = "documentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub document_type: Option<String>,

    #[serde(rename = "baseContent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_content: Option<String>,

    #[serde(rename = "isAdaptive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_adaptive: Option<bool>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "supportedLanguages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_languages: Option<Vec<String>>,

    #[serde(rename = "requiredDataFields")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_data_fields: Option<Vec<String>>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "templateType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_type: Option<models::TemplateType>,

    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,

    #[serde(rename = "detectedVariables")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detected_variables: Option<Vec<String>>,

    #[serde(rename = "variableMappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variable_mappings: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "isContextAware")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_context_aware: Option<bool>,

    #[serde(rename = "supportedContexts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_contexts: Option<Vec<String>>,

    #[serde(rename = "formattingRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub formatting_rules: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "conditionalSections")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditional_sections: Option<Vec<String>>,

    #[serde(rename = "versions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub versions: Option<Vec<models::TemplateVersion>>,

    #[serde(rename = "variables")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variables: Option<Vec<models::TemplateVariable>>,

    #[serde(rename = "instances")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances: Option<Vec<models::DocumentInstance>>,

    #[serde(rename = "explanations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub explanations: Option<Vec<models::ExplanationBlock>>,

    #[serde(rename = "intelligence")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub intelligence: Option<Vec<models::ContractIntelligence>>,

}


impl DocumentTemplate {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DocumentTemplate {
        DocumentTemplate {
            id: None,
            name: None,
            description: None,
            industry_type: None,
            document_type: None,
            base_content: None,
            is_adaptive: None,
            metadata: None,
            supported_languages: None,
            required_data_fields: None,
            version: None,
            created_at: None,
            updated_at: None,
            template_type: None,
            content: None,
            detected_variables: None,
            variable_mappings: None,
            is_context_aware: None,
            supported_contexts: None,
            formatting_rules: None,
            conditional_sections: None,
            versions: None,
            variables: None,
            instances: None,
            explanations: None,
            intelligence: None,
        }
    }
}

/// Converts the DocumentTemplate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DocumentTemplate {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.industry_type.as_ref().map(|industry_type| {
                [
                    "industryType".to_string(),
                    industry_type.to_string(),
                ].join(",")
            }),


            self.document_type.as_ref().map(|document_type| {
                [
                    "documentType".to_string(),
                    document_type.to_string(),
                ].join(",")
            }),


            self.base_content.as_ref().map(|base_content| {
                [
                    "baseContent".to_string(),
                    base_content.to_string(),
                ].join(",")
            }),


            self.is_adaptive.as_ref().map(|is_adaptive| {
                [
                    "isAdaptive".to_string(),
                    is_adaptive.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.supported_languages.as_ref().map(|supported_languages| {
                [
                    "supportedLanguages".to_string(),
                    supported_languages.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.required_data_fields.as_ref().map(|required_data_fields| {
                [
                    "requiredDataFields".to_string(),
                    required_data_fields.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping templateType in query parameter serialization


            self.content.as_ref().map(|content| {
                [
                    "content".to_string(),
                    content.to_string(),
                ].join(",")
            }),


            self.detected_variables.as_ref().map(|detected_variables| {
                [
                    "detectedVariables".to_string(),
                    detected_variables.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping variableMappings in query parameter serialization


            self.is_context_aware.as_ref().map(|is_context_aware| {
                [
                    "isContextAware".to_string(),
                    is_context_aware.to_string(),
                ].join(",")
            }),


            self.supported_contexts.as_ref().map(|supported_contexts| {
                [
                    "supportedContexts".to_string(),
                    supported_contexts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping formattingRules in query parameter serialization


            self.conditional_sections.as_ref().map(|conditional_sections| {
                [
                    "conditionalSections".to_string(),
                    conditional_sections.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping versions in query parameter serialization

            // Skipping variables in query parameter serialization

            // Skipping instances in query parameter serialization

            // Skipping explanations in query parameter serialization

            // Skipping intelligence in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DocumentTemplate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DocumentTemplate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub industry_type: Vec<String>,
            pub document_type: Vec<String>,
            pub base_content: Vec<String>,
            pub is_adaptive: Vec<bool>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub supported_languages: Vec<Vec<String>>,
            pub required_data_fields: Vec<Vec<String>>,
            pub version: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub template_type: Vec<models::TemplateType>,
            pub content: Vec<String>,
            pub detected_variables: Vec<Vec<String>>,
            pub variable_mappings: Vec<std::collections::HashMap<String, String>>,
            pub is_context_aware: Vec<bool>,
            pub supported_contexts: Vec<Vec<String>>,
            pub formatting_rules: Vec<std::collections::HashMap<String, String>>,
            pub conditional_sections: Vec<Vec<String>>,
            pub versions: Vec<Vec<models::TemplateVersion>>,
            pub variables: Vec<Vec<models::TemplateVariable>>,
            pub instances: Vec<Vec<models::DocumentInstance>>,
            pub explanations: Vec<Vec<models::ExplanationBlock>>,
            pub intelligence: Vec<Vec<models::ContractIntelligence>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DocumentTemplate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "industryType" => intermediate_rep.industry_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "documentType" => intermediate_rep.document_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baseContent" => intermediate_rep.base_content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isAdaptive" => intermediate_rep.is_adaptive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "supportedLanguages" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "requiredDataFields" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "templateType" => intermediate_rep.template_type.push(<models::TemplateType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "detectedVariables" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "variableMappings" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isContextAware" => intermediate_rep.is_context_aware.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supportedContexts" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "formattingRules" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "conditionalSections" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "variables" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "explanations" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    "intelligence" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentTemplate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DocumentTemplate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DocumentTemplate {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            industry_type: intermediate_rep.industry_type.into_iter().next(),
            document_type: intermediate_rep.document_type.into_iter().next(),
            base_content: intermediate_rep.base_content.into_iter().next(),
            is_adaptive: intermediate_rep.is_adaptive.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            supported_languages: intermediate_rep.supported_languages.into_iter().next(),
            required_data_fields: intermediate_rep.required_data_fields.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            template_type: intermediate_rep.template_type.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            detected_variables: intermediate_rep.detected_variables.into_iter().next(),
            variable_mappings: intermediate_rep.variable_mappings.into_iter().next(),
            is_context_aware: intermediate_rep.is_context_aware.into_iter().next(),
            supported_contexts: intermediate_rep.supported_contexts.into_iter().next(),
            formatting_rules: intermediate_rep.formatting_rules.into_iter().next(),
            conditional_sections: intermediate_rep.conditional_sections.into_iter().next(),
            versions: intermediate_rep.versions.into_iter().next(),
            variables: intermediate_rep.variables.into_iter().next(),
            instances: intermediate_rep.instances.into_iter().next(),
            explanations: intermediate_rep.explanations.into_iter().next(),
            intelligence: intermediate_rep.intelligence.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DocumentTemplate> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DocumentTemplate>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DocumentTemplate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DocumentTemplate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DocumentTemplate> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DocumentTemplate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DocumentTemplate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DocumentVersion {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "versionHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_hash: Option<String>,

    #[serde(rename = "parentHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_hash: Option<String>,

    #[serde(rename = "commitMessage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,

    #[serde(rename = "authorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_id: Option<String>,

    #[serde(rename = "branchName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch_name: Option<String>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,

    #[serde(rename = "isApproved")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_approved: Option<bool>,

    #[serde(rename = "approvalChain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub approval_chain: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "branches")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches: Option<Vec<models::DocumentBranch>>,

    #[serde(rename = "changes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<Vec<models::ChangeSet>>,

    #[serde(rename = "summaries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summaries: Option<Vec<models::ContextualSummary>>,

}


impl DocumentVersion {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DocumentVersion {
        DocumentVersion {
            id: None,
            version_hash: None,
            parent_hash: None,
            commit_message: None,
            author_id: None,
            branch_name: None,
            metadata: None,
            tags: None,
            is_approved: None,
            approval_chain: None,
            created_at: None,
            branches: None,
            changes: None,
            summaries: None,
        }
    }
}

/// Converts the DocumentVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DocumentVersion {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.version_hash.as_ref().map(|version_hash| {
                [
                    "versionHash".to_string(),
                    version_hash.to_string(),
                ].join(",")
            }),


            self.parent_hash.as_ref().map(|parent_hash| {
                [
                    "parentHash".to_string(),
                    parent_hash.to_string(),
                ].join(",")
            }),


            self.commit_message.as_ref().map(|commit_message| {
                [
                    "commitMessage".to_string(),
                    commit_message.to_string(),
                ].join(",")
            }),


            self.author_id.as_ref().map(|author_id| {
                [
                    "authorId".to_string(),
                    author_id.to_string(),
                ].join(",")
            }),


            self.branch_name.as_ref().map(|branch_name| {
                [
                    "branchName".to_string(),
                    branch_name.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.is_approved.as_ref().map(|is_approved| {
                [
                    "isApproved".to_string(),
                    is_approved.to_string(),
                ].join(",")
            }),


            self.approval_chain.as_ref().map(|approval_chain| {
                [
                    "approvalChain".to_string(),
                    approval_chain.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping branches in query parameter serialization

            // Skipping changes in query parameter serialization

            // Skipping summaries in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DocumentVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DocumentVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub version_hash: Vec<String>,
            pub parent_hash: Vec<String>,
            pub commit_message: Vec<String>,
            pub author_id: Vec<String>,
            pub branch_name: Vec<String>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub tags: Vec<Vec<String>>,
            pub is_approved: Vec<bool>,
            pub approval_chain: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub branches: Vec<Vec<models::DocumentBranch>>,
            pub changes: Vec<Vec<models::ChangeSet>>,
            pub summaries: Vec<Vec<models::ContextualSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DocumentVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "versionHash" => intermediate_rep.version_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parentHash" => intermediate_rep.parent_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "commitMessage" => intermediate_rep.commit_message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authorId" => intermediate_rep.author_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "branchName" => intermediate_rep.branch_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentVersion".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentVersion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isApproved" => intermediate_rep.is_approved.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "approvalChain" => intermediate_rep.approval_chain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "branches" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentVersion".to_string()),
                    "changes" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentVersion".to_string()),
                    "summaries" => return std::result::Result::Err("Parsing a container in this style is not supported in DocumentVersion".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DocumentVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DocumentVersion {
            id: intermediate_rep.id.into_iter().next(),
            version_hash: intermediate_rep.version_hash.into_iter().next(),
            parent_hash: intermediate_rep.parent_hash.into_iter().next(),
            commit_message: intermediate_rep.commit_message.into_iter().next(),
            author_id: intermediate_rep.author_id.into_iter().next(),
            branch_name: intermediate_rep.branch_name.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            tags: intermediate_rep.tags.into_iter().next(),
            is_approved: intermediate_rep.is_approved.into_iter().next(),
            approval_chain: intermediate_rep.approval_chain.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            branches: intermediate_rep.branches.into_iter().next(),
            changes: intermediate_rep.changes.into_iter().next(),
            summaries: intermediate_rep.summaries.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DocumentVersion> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DocumentVersion>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DocumentVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DocumentVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DocumentVersion> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DocumentVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DocumentVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DownloadScrapingResultsResponse {
    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<swagger::ByteArray>,

    #[serde(rename = "filename")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,

    #[serde(rename = "contentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,

}


impl DownloadScrapingResultsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DownloadScrapingResultsResponse {
        DownloadScrapingResultsResponse {
            content: None,
            filename: None,
            content_type: None,
        }
    }
}

/// Converts the DownloadScrapingResultsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DownloadScrapingResultsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization
            // Skipping content in query parameter serialization


            self.filename.as_ref().map(|filename| {
                [
                    "filename".to_string(),
                    filename.to_string(),
                ].join(",")
            }),


            self.content_type.as_ref().map(|content_type| {
                [
                    "contentType".to_string(),
                    content_type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DownloadScrapingResultsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DownloadScrapingResultsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<swagger::ByteArray>,
            pub filename: Vec<String>,
            pub content_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DownloadScrapingResultsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing binary data in this style is not supported in DownloadScrapingResultsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "filename" => intermediate_rep.filename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contentType" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DownloadScrapingResultsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DownloadScrapingResultsResponse {
            content: intermediate_rep.content.into_iter().next(),
            filename: intermediate_rep.filename.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DownloadScrapingResultsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DownloadScrapingResultsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DownloadScrapingResultsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DownloadScrapingResultsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DownloadScrapingResultsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DownloadScrapingResultsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DownloadScrapingResultsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EmployeeBenefit {
    #[serde(rename = "EMPLOYEE_BENEFIT_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "EMPLOYEE_BENEFIT_HEALTH_INSURANCE")]
    HealthInsurance,
    #[serde(rename = "EMPLOYEE_BENEFIT_RETIREMENT_PLAN")]
    RetirementPlan,
    #[serde(rename = "EMPLOYEE_BENEFIT_PAID_TIME_OFF")]
    PaidTimeOff,
    #[serde(rename = "EMPLOYEE_BENEFIT_REMOTE_WORK")]
    RemoteWork,
}

impl std::fmt::Display for EmployeeBenefit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EmployeeBenefit::Unspecified => write!(f, "EMPLOYEE_BENEFIT_UNSPECIFIED"),
            EmployeeBenefit::HealthInsurance => write!(f, "EMPLOYEE_BENEFIT_HEALTH_INSURANCE"),
            EmployeeBenefit::RetirementPlan => write!(f, "EMPLOYEE_BENEFIT_RETIREMENT_PLAN"),
            EmployeeBenefit::PaidTimeOff => write!(f, "EMPLOYEE_BENEFIT_PAID_TIME_OFF"),
            EmployeeBenefit::RemoteWork => write!(f, "EMPLOYEE_BENEFIT_REMOTE_WORK"),
        }
    }
}

impl std::str::FromStr for EmployeeBenefit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "EMPLOYEE_BENEFIT_UNSPECIFIED" => std::result::Result::Ok(EmployeeBenefit::Unspecified),
            "EMPLOYEE_BENEFIT_HEALTH_INSURANCE" => std::result::Result::Ok(EmployeeBenefit::HealthInsurance),
            "EMPLOYEE_BENEFIT_RETIREMENT_PLAN" => std::result::Result::Ok(EmployeeBenefit::RetirementPlan),
            "EMPLOYEE_BENEFIT_PAID_TIME_OFF" => std::result::Result::Ok(EmployeeBenefit::PaidTimeOff),
            "EMPLOYEE_BENEFIT_REMOTE_WORK" => std::result::Result::Ok(EmployeeBenefit::RemoteWork),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::Status>,

}


impl ErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ErrorResponse {
        ErrorResponse {
            status: None,
        }
    }
}

/// Converts the ErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::Status>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::Status as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExplanationBlock {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "templateId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_id: Option<String>,

    #[serde(rename = "sectionIdentifier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub section_identifier: Option<String>,

    #[serde(rename = "explanationText")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub explanation_text: Option<String>,

    #[serde(rename = "complexityLevel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub complexity_level: Option<String>,

    #[serde(rename = "relatedTerms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub related_terms: Option<Vec<String>>,

    #[serde(rename = "legalReferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub legal_references: Option<Vec<String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ExplanationBlock {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ExplanationBlock {
        ExplanationBlock {
            id: None,
            template_id: None,
            section_identifier: None,
            explanation_text: None,
            complexity_level: None,
            related_terms: None,
            legal_references: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the ExplanationBlock value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExplanationBlock {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.template_id.as_ref().map(|template_id| {
                [
                    "templateId".to_string(),
                    template_id.to_string(),
                ].join(",")
            }),


            self.section_identifier.as_ref().map(|section_identifier| {
                [
                    "sectionIdentifier".to_string(),
                    section_identifier.to_string(),
                ].join(",")
            }),


            self.explanation_text.as_ref().map(|explanation_text| {
                [
                    "explanationText".to_string(),
                    explanation_text.to_string(),
                ].join(",")
            }),


            self.complexity_level.as_ref().map(|complexity_level| {
                [
                    "complexityLevel".to_string(),
                    complexity_level.to_string(),
                ].join(",")
            }),


            self.related_terms.as_ref().map(|related_terms| {
                [
                    "relatedTerms".to_string(),
                    related_terms.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.legal_references.as_ref().map(|legal_references| {
                [
                    "legalReferences".to_string(),
                    legal_references.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExplanationBlock value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExplanationBlock {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub template_id: Vec<String>,
            pub section_identifier: Vec<String>,
            pub explanation_text: Vec<String>,
            pub complexity_level: Vec<String>,
            pub related_terms: Vec<Vec<String>>,
            pub legal_references: Vec<Vec<String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExplanationBlock".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "templateId" => intermediate_rep.template_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sectionIdentifier" => intermediate_rep.section_identifier.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "explanationText" => intermediate_rep.explanation_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complexityLevel" => intermediate_rep.complexity_level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "relatedTerms" => return std::result::Result::Err("Parsing a container in this style is not supported in ExplanationBlock".to_string()),
                    "legalReferences" => return std::result::Result::Err("Parsing a container in this style is not supported in ExplanationBlock".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExplanationBlock".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExplanationBlock {
            id: intermediate_rep.id.into_iter().next(),
            template_id: intermediate_rep.template_id.into_iter().next(),
            section_identifier: intermediate_rep.section_identifier.into_iter().next(),
            explanation_text: intermediate_rep.explanation_text.into_iter().next(),
            complexity_level: intermediate_rep.complexity_level.into_iter().next(),
            related_terms: intermediate_rep.related_terms.into_iter().next(),
            legal_references: intermediate_rep.legal_references.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExplanationBlock> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExplanationBlock>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExplanationBlock>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExplanationBlock - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExplanationBlock> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExplanationBlock as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExplanationBlock - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FieldError {
    #[serde(rename = "field")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field: Option<String>,

    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

}


impl FieldError {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FieldError {
        FieldError {
            field: None,
            error: None,
        }
    }
}

/// Converts the FieldError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FieldError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.field.as_ref().map(|field| {
                [
                    "field".to_string(),
                    field.to_string(),
                ].join(",")
            }),


            self.error.as_ref().map(|error| {
                [
                    "error".to_string(),
                    error.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FieldError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FieldError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub field: Vec<String>,
            pub error: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FieldError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "field" => intermediate_rep.field.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FieldError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FieldError {
            field: intermediate_rep.field.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FieldError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FieldError>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FieldError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FieldError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FieldError> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FieldError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FieldError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FieldViolation {
    #[serde(rename = "field")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field: Option<String>,

    #[serde(rename = "validation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub validation: Option<String>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "expected")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expected: Option<String>,

    #[serde(rename = "actual")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub actual: Option<String>,

}


impl FieldViolation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FieldViolation {
        FieldViolation {
            field: None,
            validation: None,
            message: None,
            expected: None,
            actual: None,
        }
    }
}

/// Converts the FieldViolation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FieldViolation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.field.as_ref().map(|field| {
                [
                    "field".to_string(),
                    field.to_string(),
                ].join(",")
            }),


            self.validation.as_ref().map(|validation| {
                [
                    "validation".to_string(),
                    validation.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.expected.as_ref().map(|expected| {
                [
                    "expected".to_string(),
                    expected.to_string(),
                ].join(",")
            }),


            self.actual.as_ref().map(|actual| {
                [
                    "actual".to_string(),
                    actual.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FieldViolation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FieldViolation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub field: Vec<String>,
            pub validation: Vec<String>,
            pub message: Vec<String>,
            pub expected: Vec<String>,
            pub actual: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FieldViolation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "field" => intermediate_rep.field.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validation" => intermediate_rep.validation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expected" => intermediate_rep.expected.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "actual" => intermediate_rep.actual.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FieldViolation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FieldViolation {
            field: intermediate_rep.field.into_iter().next(),
            validation: intermediate_rep.validation.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            expected: intermediate_rep.expected.into_iter().next(),
            actual: intermediate_rep.actual.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FieldViolation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FieldViolation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FieldViolation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FieldViolation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FieldViolation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FieldViolation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FieldViolation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileEmbeddings {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "embeddings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub embeddings: Option<Vec<f32>>,

    #[serde(rename = "modelVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model_version: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl FileEmbeddings {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FileEmbeddings {
        FileEmbeddings {
            id: None,
            embeddings: None,
            model_version: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the FileEmbeddings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FileEmbeddings {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.embeddings.as_ref().map(|embeddings| {
                [
                    "embeddings".to_string(),
                    embeddings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.model_version.as_ref().map(|model_version| {
                [
                    "modelVersion".to_string(),
                    model_version.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FileEmbeddings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FileEmbeddings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub embeddings: Vec<Vec<f32>>,
            pub model_version: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FileEmbeddings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "embeddings" => return std::result::Result::Err("Parsing a container in this style is not supported in FileEmbeddings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "modelVersion" => intermediate_rep.model_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FileEmbeddings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FileEmbeddings {
            id: intermediate_rep.id.into_iter().next(),
            embeddings: intermediate_rep.embeddings.into_iter().next(),
            model_version: intermediate_rep.model_version.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FileEmbeddings> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FileEmbeddings>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FileEmbeddings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FileEmbeddings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FileEmbeddings> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FileEmbeddings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FileEmbeddings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileMetadata {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<String>,

    #[serde(rename = "s3Key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_key: Option<String>,

    #[serde(rename = "s3BucketName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_bucket_name: Option<String>,

    #[serde(rename = "isDeleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_deleted: Option<bool>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<i32>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "embeddings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub embeddings: Option<models::FileEmbeddings>,

    #[serde(rename = "versions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub versions: Option<Vec<models::FileVersion>>,

    #[serde(rename = "comments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Vec<models::CommentThread>>,

    #[serde(rename = "sharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharing: Option<Vec<models::FileSharing>>,

    #[serde(rename = "snapshots")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub snapshots: Option<Vec<models::DocumentSnapshot>>,

}


impl FileMetadata {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FileMetadata {
        FileMetadata {
            id: None,
            name: None,
            size: None,
            s3_key: None,
            s3_bucket_name: None,
            is_deleted: None,
            version: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            embeddings: None,
            versions: None,
            comments: None,
            sharing: None,
            snapshots: None,
        }
    }
}

/// Converts the FileMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FileMetadata {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.s3_key.as_ref().map(|s3_key| {
                [
                    "s3Key".to_string(),
                    s3_key.to_string(),
                ].join(",")
            }),


            self.s3_bucket_name.as_ref().map(|s3_bucket_name| {
                [
                    "s3BucketName".to_string(),
                    s3_bucket_name.to_string(),
                ].join(",")
            }),


            self.is_deleted.as_ref().map(|is_deleted| {
                [
                    "isDeleted".to_string(),
                    is_deleted.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping embeddings in query parameter serialization

            // Skipping versions in query parameter serialization

            // Skipping comments in query parameter serialization

            // Skipping sharing in query parameter serialization

            // Skipping snapshots in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FileMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FileMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub size: Vec<String>,
            pub s3_key: Vec<String>,
            pub s3_bucket_name: Vec<String>,
            pub is_deleted: Vec<bool>,
            pub version: Vec<i32>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub embeddings: Vec<models::FileEmbeddings>,
            pub versions: Vec<Vec<models::FileVersion>>,
            pub comments: Vec<Vec<models::CommentThread>>,
            pub sharing: Vec<Vec<models::FileSharing>>,
            pub snapshots: Vec<Vec<models::DocumentSnapshot>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FileMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3Key" => intermediate_rep.s3_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3BucketName" => intermediate_rep.s3_bucket_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isDeleted" => intermediate_rep.is_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "embeddings" => intermediate_rep.embeddings.push(<models::FileEmbeddings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in FileMetadata".to_string()),
                    "comments" => return std::result::Result::Err("Parsing a container in this style is not supported in FileMetadata".to_string()),
                    "sharing" => return std::result::Result::Err("Parsing a container in this style is not supported in FileMetadata".to_string()),
                    "snapshots" => return std::result::Result::Err("Parsing a container in this style is not supported in FileMetadata".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FileMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FileMetadata {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            s3_key: intermediate_rep.s3_key.into_iter().next(),
            s3_bucket_name: intermediate_rep.s3_bucket_name.into_iter().next(),
            is_deleted: intermediate_rep.is_deleted.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            embeddings: intermediate_rep.embeddings.into_iter().next(),
            versions: intermediate_rep.versions.into_iter().next(),
            comments: intermediate_rep.comments.into_iter().next(),
            sharing: intermediate_rep.sharing.into_iter().next(),
            snapshots: intermediate_rep.snapshots.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FileMetadata> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FileMetadata>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FileMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FileMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FileMetadata> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FileMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FileMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileSharing {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "sharedWithEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_with_email: Option<String>,

    #[serde(rename = "permissionLevel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission_level: Option<String>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl FileSharing {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FileSharing {
        FileSharing {
            id: None,
            shared_with_email: None,
            permission_level: None,
            expires_at: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the FileSharing value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FileSharing {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.shared_with_email.as_ref().map(|shared_with_email| {
                [
                    "sharedWithEmail".to_string(),
                    shared_with_email.to_string(),
                ].join(",")
            }),


            self.permission_level.as_ref().map(|permission_level| {
                [
                    "permissionLevel".to_string(),
                    permission_level.to_string(),
                ].join(",")
            }),

            // Skipping expiresAt in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FileSharing value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FileSharing {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub shared_with_email: Vec<String>,
            pub permission_level: Vec<String>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FileSharing".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sharedWithEmail" => intermediate_rep.shared_with_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "permissionLevel" => intermediate_rep.permission_level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FileSharing".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FileSharing {
            id: intermediate_rep.id.into_iter().next(),
            shared_with_email: intermediate_rep.shared_with_email.into_iter().next(),
            permission_level: intermediate_rep.permission_level.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FileSharing> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FileSharing>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FileSharing>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FileSharing - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FileSharing> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FileSharing as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FileSharing - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileVersion {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "fileId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

    #[serde(rename = "versionNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_number: Option<i32>,

    #[serde(rename = "s3Key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_key: Option<String>,

    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<String>,

    #[serde(rename = "commitMessage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,

    #[serde(rename = "authorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_id: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl FileVersion {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FileVersion {
        FileVersion {
            id: None,
            file_id: None,
            version_number: None,
            s3_key: None,
            size: None,
            commit_message: None,
            author_id: None,
            created_at: None,
        }
    }
}

/// Converts the FileVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FileVersion {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.file_id.as_ref().map(|file_id| {
                [
                    "fileId".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),


            self.version_number.as_ref().map(|version_number| {
                [
                    "versionNumber".to_string(),
                    version_number.to_string(),
                ].join(",")
            }),


            self.s3_key.as_ref().map(|s3_key| {
                [
                    "s3Key".to_string(),
                    s3_key.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.commit_message.as_ref().map(|commit_message| {
                [
                    "commitMessage".to_string(),
                    commit_message.to_string(),
                ].join(",")
            }),


            self.author_id.as_ref().map(|author_id| {
                [
                    "authorId".to_string(),
                    author_id.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FileVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FileVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub file_id: Vec<String>,
            pub version_number: Vec<i32>,
            pub s3_key: Vec<String>,
            pub size: Vec<String>,
            pub commit_message: Vec<String>,
            pub author_id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FileVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fileId" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "versionNumber" => intermediate_rep.version_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3Key" => intermediate_rep.s3_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "commitMessage" => intermediate_rep.commit_message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authorId" => intermediate_rep.author_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FileVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FileVersion {
            id: intermediate_rep.id.into_iter().next(),
            file_id: intermediate_rep.file_id.into_iter().next(),
            version_number: intermediate_rep.version_number.into_iter().next(),
            s3_key: intermediate_rep.s3_key.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            commit_message: intermediate_rep.commit_message.into_iter().next(),
            author_id: intermediate_rep.author_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FileVersion> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FileVersion>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FileVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FileVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FileVersion> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FileVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FileVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FolderMetadata {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "s3BucketName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_bucket_name: Option<String>,

    #[serde(rename = "s3FolderPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_folder_path: Option<String>,

    #[serde(rename = "isDeleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_deleted: Option<bool>,

    #[serde(rename = "parentFolderId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_folder_id: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "childFolders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub child_folders: Option<Vec<models::FolderMetadata>>,

    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<Vec<models::FileMetadata>>,

}


impl FolderMetadata {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FolderMetadata {
        FolderMetadata {
            id: None,
            name: None,
            s3_bucket_name: None,
            s3_folder_path: None,
            is_deleted: None,
            parent_folder_id: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            child_folders: None,
            files: None,
        }
    }
}

/// Converts the FolderMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FolderMetadata {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.s3_bucket_name.as_ref().map(|s3_bucket_name| {
                [
                    "s3BucketName".to_string(),
                    s3_bucket_name.to_string(),
                ].join(",")
            }),


            self.s3_folder_path.as_ref().map(|s3_folder_path| {
                [
                    "s3FolderPath".to_string(),
                    s3_folder_path.to_string(),
                ].join(",")
            }),


            self.is_deleted.as_ref().map(|is_deleted| {
                [
                    "isDeleted".to_string(),
                    is_deleted.to_string(),
                ].join(",")
            }),


            self.parent_folder_id.as_ref().map(|parent_folder_id| {
                [
                    "parentFolderId".to_string(),
                    parent_folder_id.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping childFolders in query parameter serialization

            // Skipping files in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FolderMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FolderMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub s3_bucket_name: Vec<String>,
            pub s3_folder_path: Vec<String>,
            pub is_deleted: Vec<bool>,
            pub parent_folder_id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub child_folders: Vec<Vec<models::FolderMetadata>>,
            pub files: Vec<Vec<models::FileMetadata>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FolderMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3BucketName" => intermediate_rep.s3_bucket_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3FolderPath" => intermediate_rep.s3_folder_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isDeleted" => intermediate_rep.is_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parentFolderId" => intermediate_rep.parent_folder_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "childFolders" => return std::result::Result::Err("Parsing a container in this style is not supported in FolderMetadata".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in FolderMetadata".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FolderMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FolderMetadata {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            s3_bucket_name: intermediate_rep.s3_bucket_name.into_iter().next(),
            s3_folder_path: intermediate_rep.s3_folder_path.into_iter().next(),
            is_deleted: intermediate_rep.is_deleted.into_iter().next(),
            parent_folder_id: intermediate_rep.parent_folder_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            child_folders: intermediate_rep.child_folders.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FolderMetadata> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FolderMetadata>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FolderMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FolderMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FolderMetadata> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FolderMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FolderMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Indicates that the server understood the request but refuses to authorize it
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ForbiddenErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "reason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,

    #[serde(rename = "requiredPermissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_permissions: Option<Vec<String>>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl ForbiddenErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ForbiddenErrorMessageResponse {
        ForbiddenErrorMessageResponse {
            code: None,
            message: None,
            reason: None,
            required_permissions: None,
            error_response: None,
        }
    }
}

/// Converts the ForbiddenErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ForbiddenErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.reason.as_ref().map(|reason| {
                [
                    "reason".to_string(),
                    reason.to_string(),
                ].join(",")
            }),


            self.required_permissions.as_ref().map(|required_permissions| {
                [
                    "requiredPermissions".to_string(),
                    required_permissions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ForbiddenErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ForbiddenErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub reason: Vec<String>,
            pub required_permissions: Vec<Vec<String>>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ForbiddenErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "requiredPermissions" => return std::result::Result::Err("Parsing a container in this style is not supported in ForbiddenErrorMessageResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ForbiddenErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ForbiddenErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            reason: intermediate_rep.reason.into_iter().next(),
            required_permissions: intermediate_rep.required_permissions.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ForbiddenErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ForbiddenErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ForbiddenErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ForbiddenErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ForbiddenErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ForbiddenErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ForbiddenErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents errors when the server did not receive a timely response from an upstream server
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GatewayTimeoutErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "upstreamService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upstream_service: Option<String>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl GatewayTimeoutErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GatewayTimeoutErrorMessageResponse {
        GatewayTimeoutErrorMessageResponse {
            code: None,
            message: None,
            upstream_service: None,
            error_response: None,
        }
    }
}

/// Converts the GatewayTimeoutErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GatewayTimeoutErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.upstream_service.as_ref().map(|upstream_service| {
                [
                    "upstreamService".to_string(),
                    upstream_service.to_string(),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GatewayTimeoutErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GatewayTimeoutErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub upstream_service: Vec<String>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GatewayTimeoutErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upstreamService" => intermediate_rep.upstream_service.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GatewayTimeoutErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GatewayTimeoutErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            upstream_service: intermediate_rep.upstream_service.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GatewayTimeoutErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GatewayTimeoutErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GatewayTimeoutErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GatewayTimeoutErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GatewayTimeoutErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GatewayTimeoutErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GatewayTimeoutErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAccountResponse {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account>,

}


impl GetAccountResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetAccountResponse {
        GetAccountResponse {
            account: None,
        }
    }
}

/// Converts the GetAccountResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetAccountResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAccountResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAccountResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetAccountResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAccountResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAccountResponse {
            account: intermediate_rep.account.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAccountResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAccountResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetAccountResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetAccountResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetAccountResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetAccountResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetAccountResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAccountResponse1 {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account1>,

}


impl GetAccountResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetAccountResponse1 {
        GetAccountResponse1 {
            account: None,
        }
    }
}

/// Converts the GetAccountResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetAccountResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAccountResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAccountResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetAccountResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAccountResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAccountResponse1 {
            account: intermediate_rep.account.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAccountResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAccountResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetAccountResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetAccountResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetAccountResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetAccountResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetAccountResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAccountUsageResponse {
    #[serde(rename = "totalJobsRun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_jobs_run: Option<i32>,

    #[serde(rename = "monthlyJobLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_job_limit: Option<i32>,

    #[serde(rename = "remainingJobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remaining_jobs: Option<i32>,

    #[serde(rename = "resetTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reset_time: Option<chrono::DateTime::<chrono::Utc>>,

}


impl GetAccountUsageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetAccountUsageResponse {
        GetAccountUsageResponse {
            total_jobs_run: None,
            monthly_job_limit: None,
            remaining_jobs: None,
            reset_time: None,
        }
    }
}

/// Converts the GetAccountUsageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetAccountUsageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.total_jobs_run.as_ref().map(|total_jobs_run| {
                [
                    "totalJobsRun".to_string(),
                    total_jobs_run.to_string(),
                ].join(",")
            }),


            self.monthly_job_limit.as_ref().map(|monthly_job_limit| {
                [
                    "monthlyJobLimit".to_string(),
                    monthly_job_limit.to_string(),
                ].join(",")
            }),


            self.remaining_jobs.as_ref().map(|remaining_jobs| {
                [
                    "remainingJobs".to_string(),
                    remaining_jobs.to_string(),
                ].join(",")
            }),

            // Skipping resetTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAccountUsageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAccountUsageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total_jobs_run: Vec<i32>,
            pub monthly_job_limit: Vec<i32>,
            pub remaining_jobs: Vec<i32>,
            pub reset_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetAccountUsageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "totalJobsRun" => intermediate_rep.total_jobs_run.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "monthlyJobLimit" => intermediate_rep.monthly_job_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remainingJobs" => intermediate_rep.remaining_jobs.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resetTime" => intermediate_rep.reset_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAccountUsageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAccountUsageResponse {
            total_jobs_run: intermediate_rep.total_jobs_run.into_iter().next(),
            monthly_job_limit: intermediate_rep.monthly_job_limit.into_iter().next(),
            remaining_jobs: intermediate_rep.remaining_jobs.into_iter().next(),
            reset_time: intermediate_rep.reset_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAccountUsageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAccountUsageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetAccountUsageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetAccountUsageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetAccountUsageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetAccountUsageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetAccountUsageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetApiKeyResponse {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::ApiKey>,

}


impl GetApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetApiKeyResponse {
        GetApiKeyResponse {
            api_key: None,
        }
    }
}

/// Converts the GetApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::ApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::ApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetApiKeyResponse {
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLeadResponse {
    #[serde(rename = "lead")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead: Option<models::Lead>,

}


impl GetLeadResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetLeadResponse {
        GetLeadResponse {
            lead: None,
        }
    }
}

/// Converts the GetLeadResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetLeadResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping lead in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLeadResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLeadResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lead: Vec<models::Lead>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetLeadResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lead" => intermediate_rep.lead.push(<models::Lead as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetLeadResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLeadResponse {
            lead: intermediate_rep.lead.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLeadResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLeadResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetLeadResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetLeadResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetLeadResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetLeadResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetLeadResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrganizationResponse {
    #[serde(rename = "organization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<models::Organization>,

}


impl GetOrganizationResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOrganizationResponse {
        GetOrganizationResponse {
            organization: None,
        }
    }
}

/// Converts the GetOrganizationResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrganizationResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping organization in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrganizationResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrganizationResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization: Vec<models::Organization>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrganizationResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organization" => intermediate_rep.organization.push(<models::Organization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrganizationResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrganizationResponse {
            organization: intermediate_rep.organization.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrganizationResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrganizationResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrganizationResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrganizationResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrganizationResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrganizationResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrganizationResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetScrapingJobResponse {
    #[serde(rename = "job")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub job: Option<models::ScrapingJob>,

}


impl GetScrapingJobResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetScrapingJobResponse {
        GetScrapingJobResponse {
            job: None,
        }
    }
}

/// Converts the GetScrapingJobResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetScrapingJobResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping job in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetScrapingJobResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetScrapingJobResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub job: Vec<models::ScrapingJob>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetScrapingJobResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "job" => intermediate_rep.job.push(<models::ScrapingJob as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetScrapingJobResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetScrapingJobResponse {
            job: intermediate_rep.job.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetScrapingJobResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetScrapingJobResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetScrapingJobResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetScrapingJobResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetScrapingJobResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetScrapingJobResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetScrapingJobResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTenantApiKeyResponse {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::TenantApiKey>,

}


impl GetTenantApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetTenantApiKeyResponse {
        GetTenantApiKeyResponse {
            api_key: None,
        }
    }
}

/// Converts the GetTenantApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetTenantApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTenantApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTenantApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::TenantApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetTenantApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::TenantApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetTenantApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetTenantApiKeyResponse {
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetTenantApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetTenantApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetTenantApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetTenantApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetTenantApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetTenantApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetTenantApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTenantResponse {
    #[serde(rename = "tenant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant: Option<models::Tenant>,

}


impl GetTenantResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetTenantResponse {
        GetTenantResponse {
            tenant: None,
        }
    }
}

/// Converts the GetTenantResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetTenantResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tenant in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTenantResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTenantResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant: Vec<models::Tenant>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetTenantResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tenant" => intermediate_rep.tenant.push(<models::Tenant as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetTenantResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetTenantResponse {
            tenant: intermediate_rep.tenant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetTenantResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetTenantResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetTenantResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetTenantResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetTenantResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetTenantResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetTenantResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWebhookResponse {
    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<models::WebhookConfig>,

}


impl GetWebhookResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWebhookResponse {
        GetWebhookResponse {
            webhook: None,
        }
    }
}

/// Converts the GetWebhookResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWebhookResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping webhook in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWebhookResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWebhookResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub webhook: Vec<models::WebhookConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWebhookResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "webhook" => intermediate_rep.webhook.push(<models::WebhookConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWebhookResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWebhookResponse {
            webhook: intermediate_rep.webhook.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWebhookResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWebhookResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWebhookResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWebhookResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWebhookResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWebhookResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWebhookResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWorkflowResponse {
    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::ScrapingWorkflow>,

}


impl GetWorkflowResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWorkflowResponse {
        GetWorkflowResponse {
            workflow: None,
        }
    }
}

/// Converts the GetWorkflowResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWorkflowResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWorkflowResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWorkflowResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflow: Vec<models::ScrapingWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWorkflowResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::ScrapingWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWorkflowResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWorkflowResponse {
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWorkflowResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWorkflowResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWorkflowResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWorkflowResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWorkflowResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWorkflowResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWorkflowResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWorkspaceAnalyticsResponse {
    #[serde(rename = "totalLeads")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_leads: Option<i32>,

    #[serde(rename = "activeWorkflows")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_workflows: Option<i32>,

    #[serde(rename = "jobsLast30Days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_last30_days: Option<i32>,

    #[serde(rename = "successRates")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success_rates: Option<Vec<models::JobSuccessRate>>,

}


impl GetWorkspaceAnalyticsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWorkspaceAnalyticsResponse {
        GetWorkspaceAnalyticsResponse {
            total_leads: None,
            active_workflows: None,
            jobs_last30_days: None,
            success_rates: None,
        }
    }
}

/// Converts the GetWorkspaceAnalyticsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWorkspaceAnalyticsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.total_leads.as_ref().map(|total_leads| {
                [
                    "totalLeads".to_string(),
                    total_leads.to_string(),
                ].join(",")
            }),


            self.active_workflows.as_ref().map(|active_workflows| {
                [
                    "activeWorkflows".to_string(),
                    active_workflows.to_string(),
                ].join(",")
            }),


            self.jobs_last30_days.as_ref().map(|jobs_last30_days| {
                [
                    "jobsLast30Days".to_string(),
                    jobs_last30_days.to_string(),
                ].join(",")
            }),

            // Skipping successRates in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWorkspaceAnalyticsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWorkspaceAnalyticsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total_leads: Vec<i32>,
            pub active_workflows: Vec<i32>,
            pub jobs_last30_days: Vec<i32>,
            pub success_rates: Vec<Vec<models::JobSuccessRate>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWorkspaceAnalyticsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "totalLeads" => intermediate_rep.total_leads.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "activeWorkflows" => intermediate_rep.active_workflows.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "jobsLast30Days" => intermediate_rep.jobs_last30_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "successRates" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWorkspaceAnalyticsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWorkspaceAnalyticsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWorkspaceAnalyticsResponse {
            total_leads: intermediate_rep.total_leads.into_iter().next(),
            active_workflows: intermediate_rep.active_workflows.into_iter().next(),
            jobs_last30_days: intermediate_rep.jobs_last30_days.into_iter().next(),
            success_rates: intermediate_rep.success_rates.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWorkspaceAnalyticsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWorkspaceAnalyticsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWorkspaceAnalyticsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWorkspaceAnalyticsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWorkspaceAnalyticsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWorkspaceAnalyticsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWorkspaceAnalyticsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWorkspaceAnalyticsResponse1 {
    #[serde(rename = "activity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub activity: Option<models::ActivityMetrics>,

    #[serde(rename = "userActivities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_activities: Option<Vec<models::UserActivity>>,

    #[serde(rename = "compliance")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance: Option<models::ComplianceMetrics>,

    #[serde(rename = "recentActivities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recent_activities: Option<Vec<models::WorkspaceActivity>>,

}


impl GetWorkspaceAnalyticsResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWorkspaceAnalyticsResponse1 {
        GetWorkspaceAnalyticsResponse1 {
            activity: None,
            user_activities: None,
            compliance: None,
            recent_activities: None,
        }
    }
}

/// Converts the GetWorkspaceAnalyticsResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWorkspaceAnalyticsResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping activity in query parameter serialization

            // Skipping userActivities in query parameter serialization

            // Skipping compliance in query parameter serialization

            // Skipping recentActivities in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWorkspaceAnalyticsResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWorkspaceAnalyticsResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub activity: Vec<models::ActivityMetrics>,
            pub user_activities: Vec<Vec<models::UserActivity>>,
            pub compliance: Vec<models::ComplianceMetrics>,
            pub recent_activities: Vec<Vec<models::WorkspaceActivity>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWorkspaceAnalyticsResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "activity" => intermediate_rep.activity.push(<models::ActivityMetrics as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "userActivities" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWorkspaceAnalyticsResponse1".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "compliance" => intermediate_rep.compliance.push(<models::ComplianceMetrics as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "recentActivities" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWorkspaceAnalyticsResponse1".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWorkspaceAnalyticsResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWorkspaceAnalyticsResponse1 {
            activity: intermediate_rep.activity.into_iter().next(),
            user_activities: intermediate_rep.user_activities.into_iter().next(),
            compliance: intermediate_rep.compliance.into_iter().next(),
            recent_activities: intermediate_rep.recent_activities.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWorkspaceAnalyticsResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWorkspaceAnalyticsResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWorkspaceAnalyticsResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWorkspaceAnalyticsResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWorkspaceAnalyticsResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWorkspaceAnalyticsResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWorkspaceAnalyticsResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWorkspaceComplianceReportResponse {
    #[serde(rename = "overallScore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub overall_score: Option<f32>,

    #[serde(rename = "complianceStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_status: Option<String>,

    #[serde(rename = "violations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub violations: Option<Vec<models::ComplianceViolation>>,

    #[serde(rename = "categoryScores")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_scores: Option<Vec<models::ComplianceScore>>,

    #[serde(rename = "reportGeneratedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_generated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "certificationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certification_id: Option<String>,

}


impl GetWorkspaceComplianceReportResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWorkspaceComplianceReportResponse {
        GetWorkspaceComplianceReportResponse {
            overall_score: None,
            compliance_status: None,
            violations: None,
            category_scores: None,
            report_generated_at: None,
            certification_id: None,
        }
    }
}

/// Converts the GetWorkspaceComplianceReportResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWorkspaceComplianceReportResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.overall_score.as_ref().map(|overall_score| {
                [
                    "overallScore".to_string(),
                    overall_score.to_string(),
                ].join(",")
            }),


            self.compliance_status.as_ref().map(|compliance_status| {
                [
                    "complianceStatus".to_string(),
                    compliance_status.to_string(),
                ].join(",")
            }),

            // Skipping violations in query parameter serialization

            // Skipping categoryScores in query parameter serialization

            // Skipping reportGeneratedAt in query parameter serialization


            self.certification_id.as_ref().map(|certification_id| {
                [
                    "certificationId".to_string(),
                    certification_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWorkspaceComplianceReportResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWorkspaceComplianceReportResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub overall_score: Vec<f32>,
            pub compliance_status: Vec<String>,
            pub violations: Vec<Vec<models::ComplianceViolation>>,
            pub category_scores: Vec<Vec<models::ComplianceScore>>,
            pub report_generated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub certification_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWorkspaceComplianceReportResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "overallScore" => intermediate_rep.overall_score.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complianceStatus" => intermediate_rep.compliance_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "violations" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWorkspaceComplianceReportResponse".to_string()),
                    "categoryScores" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWorkspaceComplianceReportResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "reportGeneratedAt" => intermediate_rep.report_generated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certificationId" => intermediate_rep.certification_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWorkspaceComplianceReportResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWorkspaceComplianceReportResponse {
            overall_score: intermediate_rep.overall_score.into_iter().next(),
            compliance_status: intermediate_rep.compliance_status.into_iter().next(),
            violations: intermediate_rep.violations.into_iter().next(),
            category_scores: intermediate_rep.category_scores.into_iter().next(),
            report_generated_at: intermediate_rep.report_generated_at.into_iter().next(),
            certification_id: intermediate_rep.certification_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWorkspaceComplianceReportResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWorkspaceComplianceReportResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWorkspaceComplianceReportResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWorkspaceComplianceReportResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWorkspaceComplianceReportResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWorkspaceComplianceReportResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWorkspaceComplianceReportResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWorkspaceResponse {
    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace1>,

}


impl GetWorkspaceResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWorkspaceResponse {
        GetWorkspaceResponse {
            workspace: None,
        }
    }
}

/// Converts the GetWorkspaceResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWorkspaceResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspace in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWorkspaceResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWorkspaceResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspace: Vec<models::Workspace1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWorkspaceResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWorkspaceResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWorkspaceResponse {
            workspace: intermediate_rep.workspace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWorkspaceResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWorkspaceResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWorkspaceResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWorkspaceResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWorkspaceResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWorkspaceResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWorkspaceResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWorkspaceStorageStatsResponse {
    #[serde(rename = "totalStorageUsed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_storage_used: Option<String>,

    #[serde(rename = "storageQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_quota: Option<String>,

    #[serde(rename = "usagePercentage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage_percentage: Option<f32>,

    #[serde(rename = "storageByType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_by_type: Option<Vec<models::StorageBreakdown>>,

    #[serde(rename = "totalFiles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_files: Option<i32>,

    #[serde(rename = "totalFolders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_folders: Option<i32>,

    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

}


impl GetWorkspaceStorageStatsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWorkspaceStorageStatsResponse {
        GetWorkspaceStorageStatsResponse {
            total_storage_used: None,
            storage_quota: None,
            usage_percentage: None,
            storage_by_type: None,
            total_files: None,
            total_folders: None,
            last_updated: None,
        }
    }
}

/// Converts the GetWorkspaceStorageStatsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWorkspaceStorageStatsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.total_storage_used.as_ref().map(|total_storage_used| {
                [
                    "totalStorageUsed".to_string(),
                    total_storage_used.to_string(),
                ].join(",")
            }),


            self.storage_quota.as_ref().map(|storage_quota| {
                [
                    "storageQuota".to_string(),
                    storage_quota.to_string(),
                ].join(",")
            }),


            self.usage_percentage.as_ref().map(|usage_percentage| {
                [
                    "usagePercentage".to_string(),
                    usage_percentage.to_string(),
                ].join(",")
            }),

            // Skipping storageByType in query parameter serialization


            self.total_files.as_ref().map(|total_files| {
                [
                    "totalFiles".to_string(),
                    total_files.to_string(),
                ].join(",")
            }),


            self.total_folders.as_ref().map(|total_folders| {
                [
                    "totalFolders".to_string(),
                    total_folders.to_string(),
                ].join(",")
            }),

            // Skipping lastUpdated in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWorkspaceStorageStatsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWorkspaceStorageStatsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total_storage_used: Vec<String>,
            pub storage_quota: Vec<String>,
            pub usage_percentage: Vec<f32>,
            pub storage_by_type: Vec<Vec<models::StorageBreakdown>>,
            pub total_files: Vec<i32>,
            pub total_folders: Vec<i32>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWorkspaceStorageStatsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "totalStorageUsed" => intermediate_rep.total_storage_used.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageQuota" => intermediate_rep.storage_quota.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usagePercentage" => intermediate_rep.usage_percentage.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "storageByType" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWorkspaceStorageStatsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "totalFiles" => intermediate_rep.total_files.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalFolders" => intermediate_rep.total_folders.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWorkspaceStorageStatsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWorkspaceStorageStatsResponse {
            total_storage_used: intermediate_rep.total_storage_used.into_iter().next(),
            storage_quota: intermediate_rep.storage_quota.into_iter().next(),
            usage_percentage: intermediate_rep.usage_percentage.into_iter().next(),
            storage_by_type: intermediate_rep.storage_by_type.into_iter().next(),
            total_files: intermediate_rep.total_files.into_iter().next(),
            total_folders: intermediate_rep.total_folders.into_iter().next(),
            last_updated: intermediate_rep.last_updated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWorkspaceStorageStatsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWorkspaceStorageStatsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWorkspaceStorageStatsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWorkspaceStorageStatsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWorkspaceStorageStatsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWorkspaceStorageStatsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWorkspaceStorageStatsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Indicates that the resource requested is no longer available and will not be available again
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoneErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "resource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource: Option<String>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl GoneErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GoneErrorMessageResponse {
        GoneErrorMessageResponse {
            code: None,
            message: None,
            resource: None,
            error_response: None,
        }
    }
}

/// Converts the GoneErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoneErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.resource.as_ref().map(|resource| {
                [
                    "resource".to_string(),
                    resource.to_string(),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoneErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoneErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub resource: Vec<String>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoneErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resource" => intermediate_rep.resource.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoneErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoneErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            resource: intermediate_rep.resource.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoneErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoneErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoneErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoneErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoneErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoneErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoneErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// - INCLUDED_FIELD_NAME: Core business information  - INCLUDED_FIELD_LOCATION: city, state, country  - INCLUDED_FIELD_COORDINATES: Geographic data  latitude, longitude  - INCLUDED_FIELD_GOOGLE_RATING: Ratings and reviews  - INCLUDED_FIELD_BUSINESS_HOURS: Business details  - INCLUDED_FIELD_PHOTOS: Rich media  - INCLUDED_FIELD_BUSINESS_TYPES: Categories and attributes  - INCLUDED_FIELD_SOCIAL_PROFILES: Social media  - INCLUDED_FIELD_EMPLOYEE_COUNT: Enhanced business data  - INCLUDED_FIELD_NAICS_CODE: Industry classification  - INCLUDED_FIELD_SCRAPING_METADATA: Metadata  timestamps, session info  - INCLUDED_FIELD_COMPLIANCE_INFO: sustainability, certifications  - INCLUDED_FIELD_ALTERNATE_PHONES: Contact information
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum IncludedField {
    #[serde(rename = "INCLUDED_FIELD_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "INCLUDED_FIELD_NAME")]
    Name,
    #[serde(rename = "INCLUDED_FIELD_WEBSITE")]
    Website,
    #[serde(rename = "INCLUDED_FIELD_PHONE")]
    Phone,
    #[serde(rename = "INCLUDED_FIELD_ADDRESS")]
    Address,
    #[serde(rename = "INCLUDED_FIELD_LOCATION")]
    Location,
    #[serde(rename = "INCLUDED_FIELD_COORDINATES")]
    Coordinates,
    #[serde(rename = "INCLUDED_FIELD_GOOGLE_RATING")]
    GoogleRating,
    #[serde(rename = "INCLUDED_FIELD_REVIEW_COUNT")]
    ReviewCount,
    #[serde(rename = "INCLUDED_FIELD_REVIEWS")]
    Reviews,
    #[serde(rename = "INCLUDED_FIELD_BUSINESS_HOURS")]
    BusinessHours,
    #[serde(rename = "INCLUDED_FIELD_BUSINESS_STATUS")]
    BusinessStatus,
    #[serde(rename = "INCLUDED_FIELD_PLACE_ID")]
    PlaceId,
    #[serde(rename = "INCLUDED_FIELD_GOOGLE_MAPS_URL")]
    GoogleMapsUrl,
    #[serde(rename = "INCLUDED_FIELD_PHOTOS")]
    Photos,
    #[serde(rename = "INCLUDED_FIELD_MAIN_PHOTO")]
    MainPhoto,
    #[serde(rename = "INCLUDED_FIELD_BUSINESS_TYPES")]
    BusinessTypes,
    #[serde(rename = "INCLUDED_FIELD_AMENITIES")]
    Amenities,
    #[serde(rename = "INCLUDED_FIELD_PAYMENT_METHODS")]
    PaymentMethods,
    #[serde(rename = "INCLUDED_FIELD_SOCIAL_PROFILES")]
    SocialProfiles,
    #[serde(rename = "INCLUDED_FIELD_EMPLOYEE_COUNT")]
    EmployeeCount,
    #[serde(rename = "INCLUDED_FIELD_REVENUE_INFO")]
    RevenueInfo,
    #[serde(rename = "INCLUDED_FIELD_FOUNDED_YEAR")]
    FoundedYear,
    #[serde(rename = "INCLUDED_FIELD_CERTIFICATIONS")]
    Certifications,
    #[serde(rename = "INCLUDED_FIELD_NAICS_CODE")]
    NaicsCode,
    #[serde(rename = "INCLUDED_FIELD_SIC_CODE")]
    SicCode,
    #[serde(rename = "INCLUDED_FIELD_SCRAPING_METADATA")]
    ScrapingMetadata,
    #[serde(rename = "INCLUDED_FIELD_COMPLIANCE_INFO")]
    ComplianceInfo,
    #[serde(rename = "INCLUDED_FIELD_ALTERNATE_PHONES")]
    AlternatePhones,
    #[serde(rename = "INCLUDED_FIELD_CONTACT_PERSON")]
    ContactPerson,
    #[serde(rename = "INCLUDED_FIELD_CONTACT_EMAIL")]
    ContactEmail,
}

impl std::fmt::Display for IncludedField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            IncludedField::Unspecified => write!(f, "INCLUDED_FIELD_UNSPECIFIED"),
            IncludedField::Name => write!(f, "INCLUDED_FIELD_NAME"),
            IncludedField::Website => write!(f, "INCLUDED_FIELD_WEBSITE"),
            IncludedField::Phone => write!(f, "INCLUDED_FIELD_PHONE"),
            IncludedField::Address => write!(f, "INCLUDED_FIELD_ADDRESS"),
            IncludedField::Location => write!(f, "INCLUDED_FIELD_LOCATION"),
            IncludedField::Coordinates => write!(f, "INCLUDED_FIELD_COORDINATES"),
            IncludedField::GoogleRating => write!(f, "INCLUDED_FIELD_GOOGLE_RATING"),
            IncludedField::ReviewCount => write!(f, "INCLUDED_FIELD_REVIEW_COUNT"),
            IncludedField::Reviews => write!(f, "INCLUDED_FIELD_REVIEWS"),
            IncludedField::BusinessHours => write!(f, "INCLUDED_FIELD_BUSINESS_HOURS"),
            IncludedField::BusinessStatus => write!(f, "INCLUDED_FIELD_BUSINESS_STATUS"),
            IncludedField::PlaceId => write!(f, "INCLUDED_FIELD_PLACE_ID"),
            IncludedField::GoogleMapsUrl => write!(f, "INCLUDED_FIELD_GOOGLE_MAPS_URL"),
            IncludedField::Photos => write!(f, "INCLUDED_FIELD_PHOTOS"),
            IncludedField::MainPhoto => write!(f, "INCLUDED_FIELD_MAIN_PHOTO"),
            IncludedField::BusinessTypes => write!(f, "INCLUDED_FIELD_BUSINESS_TYPES"),
            IncludedField::Amenities => write!(f, "INCLUDED_FIELD_AMENITIES"),
            IncludedField::PaymentMethods => write!(f, "INCLUDED_FIELD_PAYMENT_METHODS"),
            IncludedField::SocialProfiles => write!(f, "INCLUDED_FIELD_SOCIAL_PROFILES"),
            IncludedField::EmployeeCount => write!(f, "INCLUDED_FIELD_EMPLOYEE_COUNT"),
            IncludedField::RevenueInfo => write!(f, "INCLUDED_FIELD_REVENUE_INFO"),
            IncludedField::FoundedYear => write!(f, "INCLUDED_FIELD_FOUNDED_YEAR"),
            IncludedField::Certifications => write!(f, "INCLUDED_FIELD_CERTIFICATIONS"),
            IncludedField::NaicsCode => write!(f, "INCLUDED_FIELD_NAICS_CODE"),
            IncludedField::SicCode => write!(f, "INCLUDED_FIELD_SIC_CODE"),
            IncludedField::ScrapingMetadata => write!(f, "INCLUDED_FIELD_SCRAPING_METADATA"),
            IncludedField::ComplianceInfo => write!(f, "INCLUDED_FIELD_COMPLIANCE_INFO"),
            IncludedField::AlternatePhones => write!(f, "INCLUDED_FIELD_ALTERNATE_PHONES"),
            IncludedField::ContactPerson => write!(f, "INCLUDED_FIELD_CONTACT_PERSON"),
            IncludedField::ContactEmail => write!(f, "INCLUDED_FIELD_CONTACT_EMAIL"),
        }
    }
}

impl std::str::FromStr for IncludedField {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INCLUDED_FIELD_UNSPECIFIED" => std::result::Result::Ok(IncludedField::Unspecified),
            "INCLUDED_FIELD_NAME" => std::result::Result::Ok(IncludedField::Name),
            "INCLUDED_FIELD_WEBSITE" => std::result::Result::Ok(IncludedField::Website),
            "INCLUDED_FIELD_PHONE" => std::result::Result::Ok(IncludedField::Phone),
            "INCLUDED_FIELD_ADDRESS" => std::result::Result::Ok(IncludedField::Address),
            "INCLUDED_FIELD_LOCATION" => std::result::Result::Ok(IncludedField::Location),
            "INCLUDED_FIELD_COORDINATES" => std::result::Result::Ok(IncludedField::Coordinates),
            "INCLUDED_FIELD_GOOGLE_RATING" => std::result::Result::Ok(IncludedField::GoogleRating),
            "INCLUDED_FIELD_REVIEW_COUNT" => std::result::Result::Ok(IncludedField::ReviewCount),
            "INCLUDED_FIELD_REVIEWS" => std::result::Result::Ok(IncludedField::Reviews),
            "INCLUDED_FIELD_BUSINESS_HOURS" => std::result::Result::Ok(IncludedField::BusinessHours),
            "INCLUDED_FIELD_BUSINESS_STATUS" => std::result::Result::Ok(IncludedField::BusinessStatus),
            "INCLUDED_FIELD_PLACE_ID" => std::result::Result::Ok(IncludedField::PlaceId),
            "INCLUDED_FIELD_GOOGLE_MAPS_URL" => std::result::Result::Ok(IncludedField::GoogleMapsUrl),
            "INCLUDED_FIELD_PHOTOS" => std::result::Result::Ok(IncludedField::Photos),
            "INCLUDED_FIELD_MAIN_PHOTO" => std::result::Result::Ok(IncludedField::MainPhoto),
            "INCLUDED_FIELD_BUSINESS_TYPES" => std::result::Result::Ok(IncludedField::BusinessTypes),
            "INCLUDED_FIELD_AMENITIES" => std::result::Result::Ok(IncludedField::Amenities),
            "INCLUDED_FIELD_PAYMENT_METHODS" => std::result::Result::Ok(IncludedField::PaymentMethods),
            "INCLUDED_FIELD_SOCIAL_PROFILES" => std::result::Result::Ok(IncludedField::SocialProfiles),
            "INCLUDED_FIELD_EMPLOYEE_COUNT" => std::result::Result::Ok(IncludedField::EmployeeCount),
            "INCLUDED_FIELD_REVENUE_INFO" => std::result::Result::Ok(IncludedField::RevenueInfo),
            "INCLUDED_FIELD_FOUNDED_YEAR" => std::result::Result::Ok(IncludedField::FoundedYear),
            "INCLUDED_FIELD_CERTIFICATIONS" => std::result::Result::Ok(IncludedField::Certifications),
            "INCLUDED_FIELD_NAICS_CODE" => std::result::Result::Ok(IncludedField::NaicsCode),
            "INCLUDED_FIELD_SIC_CODE" => std::result::Result::Ok(IncludedField::SicCode),
            "INCLUDED_FIELD_SCRAPING_METADATA" => std::result::Result::Ok(IncludedField::ScrapingMetadata),
            "INCLUDED_FIELD_COMPLIANCE_INFO" => std::result::Result::Ok(IncludedField::ComplianceInfo),
            "INCLUDED_FIELD_ALTERNATE_PHONES" => std::result::Result::Ok(IncludedField::AlternatePhones),
            "INCLUDED_FIELD_CONTACT_PERSON" => std::result::Result::Ok(IncludedField::ContactPerson),
            "INCLUDED_FIELD_CONTACT_EMAIL" => std::result::Result::Ok(IncludedField::ContactEmail),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// - INTERNAL_ERROR: General internal errors  - RESOURCE_EXHAUSTED: Resource exhaustion errors  - CANCELLED: Operation errors  - UNAVAILABLE: Availability errors  - DEPENDENCY_FAILURE: New internal error codes  Failure in external dependency  - CONFIGURATION_ERROR: Service configuration error  - SECURITY_BREACH_DETECTED: Potential security breach detected
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum InternalErrorCode {
    #[serde(rename = "NO_INTERNAL_ERROR")]
    NoInternalError,
    #[serde(rename = "INTERNAL_ERROR")]
    InternalError,
    #[serde(rename = "DATA_CORRUPTION")]
    DataCorruption,
    #[serde(rename = "DATABASE_ERROR")]
    DatabaseError,
    #[serde(rename = "CACHE_ERROR")]
    CacheError,
    #[serde(rename = "RESOURCE_EXHAUSTED")]
    ResourceExhausted,
    #[serde(rename = "QUOTA_EXCEEDED")]
    QuotaExceeded,
    #[serde(rename = "RATE_LIMIT_EXCEEDED")]
    RateLimitExceeded,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "DEADLINE_EXCEEDED")]
    DeadlineExceeded,
    #[serde(rename = "ALREADY_EXISTS")]
    AlreadyExists,
    #[serde(rename = "FAILED_PRECONDITION")]
    FailedPrecondition,
    #[serde(rename = "ABORTED")]
    Aborted,
    #[serde(rename = "OUT_OF_RANGE")]
    OutOfRange,
    #[serde(rename = "UNAVAILABLE")]
    Unavailable,
    #[serde(rename = "DATA_LOSS")]
    DataLoss,
    #[serde(rename = "SERVICE_DEGRADED")]
    ServiceDegraded,
    #[serde(rename = "DEPENDENCY_FAILURE")]
    DependencyFailure,
    #[serde(rename = "CONFIGURATION_ERROR")]
    ConfigurationError,
    #[serde(rename = "SECURITY_BREACH_DETECTED")]
    SecurityBreachDetected,
}

impl std::fmt::Display for InternalErrorCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            InternalErrorCode::NoInternalError => write!(f, "NO_INTERNAL_ERROR"),
            InternalErrorCode::InternalError => write!(f, "INTERNAL_ERROR"),
            InternalErrorCode::DataCorruption => write!(f, "DATA_CORRUPTION"),
            InternalErrorCode::DatabaseError => write!(f, "DATABASE_ERROR"),
            InternalErrorCode::CacheError => write!(f, "CACHE_ERROR"),
            InternalErrorCode::ResourceExhausted => write!(f, "RESOURCE_EXHAUSTED"),
            InternalErrorCode::QuotaExceeded => write!(f, "QUOTA_EXCEEDED"),
            InternalErrorCode::RateLimitExceeded => write!(f, "RATE_LIMIT_EXCEEDED"),
            InternalErrorCode::Cancelled => write!(f, "CANCELLED"),
            InternalErrorCode::DeadlineExceeded => write!(f, "DEADLINE_EXCEEDED"),
            InternalErrorCode::AlreadyExists => write!(f, "ALREADY_EXISTS"),
            InternalErrorCode::FailedPrecondition => write!(f, "FAILED_PRECONDITION"),
            InternalErrorCode::Aborted => write!(f, "ABORTED"),
            InternalErrorCode::OutOfRange => write!(f, "OUT_OF_RANGE"),
            InternalErrorCode::Unavailable => write!(f, "UNAVAILABLE"),
            InternalErrorCode::DataLoss => write!(f, "DATA_LOSS"),
            InternalErrorCode::ServiceDegraded => write!(f, "SERVICE_DEGRADED"),
            InternalErrorCode::DependencyFailure => write!(f, "DEPENDENCY_FAILURE"),
            InternalErrorCode::ConfigurationError => write!(f, "CONFIGURATION_ERROR"),
            InternalErrorCode::SecurityBreachDetected => write!(f, "SECURITY_BREACH_DETECTED"),
        }
    }
}

impl std::str::FromStr for InternalErrorCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NO_INTERNAL_ERROR" => std::result::Result::Ok(InternalErrorCode::NoInternalError),
            "INTERNAL_ERROR" => std::result::Result::Ok(InternalErrorCode::InternalError),
            "DATA_CORRUPTION" => std::result::Result::Ok(InternalErrorCode::DataCorruption),
            "DATABASE_ERROR" => std::result::Result::Ok(InternalErrorCode::DatabaseError),
            "CACHE_ERROR" => std::result::Result::Ok(InternalErrorCode::CacheError),
            "RESOURCE_EXHAUSTED" => std::result::Result::Ok(InternalErrorCode::ResourceExhausted),
            "QUOTA_EXCEEDED" => std::result::Result::Ok(InternalErrorCode::QuotaExceeded),
            "RATE_LIMIT_EXCEEDED" => std::result::Result::Ok(InternalErrorCode::RateLimitExceeded),
            "CANCELLED" => std::result::Result::Ok(InternalErrorCode::Cancelled),
            "DEADLINE_EXCEEDED" => std::result::Result::Ok(InternalErrorCode::DeadlineExceeded),
            "ALREADY_EXISTS" => std::result::Result::Ok(InternalErrorCode::AlreadyExists),
            "FAILED_PRECONDITION" => std::result::Result::Ok(InternalErrorCode::FailedPrecondition),
            "ABORTED" => std::result::Result::Ok(InternalErrorCode::Aborted),
            "OUT_OF_RANGE" => std::result::Result::Ok(InternalErrorCode::OutOfRange),
            "UNAVAILABLE" => std::result::Result::Ok(InternalErrorCode::Unavailable),
            "DATA_LOSS" => std::result::Result::Ok(InternalErrorCode::DataLoss),
            "SERVICE_DEGRADED" => std::result::Result::Ok(InternalErrorCode::ServiceDegraded),
            "DEPENDENCY_FAILURE" => std::result::Result::Ok(InternalErrorCode::DependencyFailure),
            "CONFIGURATION_ERROR" => std::result::Result::Ok(InternalErrorCode::ConfigurationError),
            "SECURITY_BREACH_DETECTED" => std::result::Result::Ok(InternalErrorCode::SecurityBreachDetected),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents internal server and system-level errors
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InternalErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::InternalErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "incidentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_id: Option<String>,

    #[serde(rename = "serviceStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_status: Option<models::ServiceStatus>,

    #[serde(rename = "resourceUtilization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_utilization: Option<models::ResourceUtilization>,

    #[serde(rename = "operationDetails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operation_details: Option<models::OperationDetails>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl InternalErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> InternalErrorMessageResponse {
        InternalErrorMessageResponse {
            code: None,
            message: None,
            incident_id: None,
            service_status: None,
            resource_utilization: None,
            operation_details: None,
            error_response: None,
        }
    }
}

/// Converts the InternalErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InternalErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.incident_id.as_ref().map(|incident_id| {
                [
                    "incidentId".to_string(),
                    incident_id.to_string(),
                ].join(",")
            }),

            // Skipping serviceStatus in query parameter serialization

            // Skipping resourceUtilization in query parameter serialization

            // Skipping operationDetails in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InternalErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InternalErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::InternalErrorCode>,
            pub message: Vec<String>,
            pub incident_id: Vec<String>,
            pub service_status: Vec<models::ServiceStatus>,
            pub resource_utilization: Vec<models::ResourceUtilization>,
            pub operation_details: Vec<models::OperationDetails>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InternalErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::InternalErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "incidentId" => intermediate_rep.incident_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceStatus" => intermediate_rep.service_status.push(<models::ServiceStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resourceUtilization" => intermediate_rep.resource_utilization.push(<models::ResourceUtilization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operationDetails" => intermediate_rep.operation_details.push(<models::OperationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InternalErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InternalErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            incident_id: intermediate_rep.incident_id.into_iter().next(),
            service_status: intermediate_rep.service_status.into_iter().next(),
            resource_utilization: intermediate_rep.resource_utilization.into_iter().next(),
            operation_details: intermediate_rep.operation_details.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InternalErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InternalErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InternalErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InternalErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<InternalErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InternalErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InternalErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Interval {
    #[serde(rename = "INTERVAL_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "INTERVAL_MONTHLY")]
    Monthly,
    #[serde(rename = "INTERVAL_YEARLY")]
    Yearly,
}

impl std::fmt::Display for Interval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Interval::Unspecified => write!(f, "INTERVAL_UNSPECIFIED"),
            Interval::Monthly => write!(f, "INTERVAL_MONTHLY"),
            Interval::Yearly => write!(f, "INTERVAL_YEARLY"),
        }
    }
}

impl std::str::FromStr for Interval {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INTERVAL_UNSPECIFIED" => std::result::Result::Ok(Interval::Unspecified),
            "INTERVAL_MONTHLY" => std::result::Result::Ok(Interval::Monthly),
            "INTERVAL_YEARLY" => std::result::Result::Ok(Interval::Yearly),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JobSuccessRate {
    #[serde(rename = "workflowId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<String>,

    #[serde(rename = "successRate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success_rate: Option<f32>,

    #[serde(rename = "totalRuns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_runs: Option<i32>,

}


impl JobSuccessRate {
    #[allow(clippy::new_without_default)]
    pub fn new() -> JobSuccessRate {
        JobSuccessRate {
            workflow_id: None,
            success_rate: None,
            total_runs: None,
        }
    }
}

/// Converts the JobSuccessRate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for JobSuccessRate {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.workflow_id.as_ref().map(|workflow_id| {
                [
                    "workflowId".to_string(),
                    workflow_id.to_string(),
                ].join(",")
            }),


            self.success_rate.as_ref().map(|success_rate| {
                [
                    "successRate".to_string(),
                    success_rate.to_string(),
                ].join(",")
            }),


            self.total_runs.as_ref().map(|total_runs| {
                [
                    "totalRuns".to_string(),
                    total_runs.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JobSuccessRate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JobSuccessRate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflow_id: Vec<String>,
            pub success_rate: Vec<f32>,
            pub total_runs: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing JobSuccessRate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workflowId" => intermediate_rep.workflow_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "successRate" => intermediate_rep.success_rate.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalRuns" => intermediate_rep.total_runs.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing JobSuccessRate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(JobSuccessRate {
            workflow_id: intermediate_rep.workflow_id.into_iter().next(),
            success_rate: intermediate_rep.success_rate.into_iter().next(),
            total_runs: intermediate_rep.total_runs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<JobSuccessRate> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<JobSuccessRate>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<JobSuccessRate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for JobSuccessRate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<JobSuccessRate> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <JobSuccessRate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into JobSuccessRate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// - LANGUAGE_ENGLISH: en  - LANGUAGE_SPANISH: es  - LANGUAGE_FRENCH: fr  - LANGUAGE_GERMAN: de  - LANGUAGE_ITALIAN: it  - LANGUAGE_PORTUGUESE: pt  - LANGUAGE_DUTCH: nl  - LANGUAGE_RUSSIAN: ru  - LANGUAGE_CHINESE: zh  - LANGUAGE_JAPANESE: ja  - LANGUAGE_KOREAN: ko  - LANGUAGE_ARABIC: ar  - LANGUAGE_HINDI: hi  - LANGUAGE_GREEK: el  - LANGUAGE_TURKISH: tr
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Language {
    #[serde(rename = "LANGUAGE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "LANGUAGE_ENGLISH")]
    English,
    #[serde(rename = "LANGUAGE_SPANISH")]
    Spanish,
    #[serde(rename = "LANGUAGE_FRENCH")]
    French,
    #[serde(rename = "LANGUAGE_GERMAN")]
    German,
    #[serde(rename = "LANGUAGE_ITALIAN")]
    Italian,
    #[serde(rename = "LANGUAGE_PORTUGUESE")]
    Portuguese,
    #[serde(rename = "LANGUAGE_DUTCH")]
    Dutch,
    #[serde(rename = "LANGUAGE_RUSSIAN")]
    Russian,
    #[serde(rename = "LANGUAGE_CHINESE")]
    Chinese,
    #[serde(rename = "LANGUAGE_JAPANESE")]
    Japanese,
    #[serde(rename = "LANGUAGE_KOREAN")]
    Korean,
    #[serde(rename = "LANGUAGE_ARABIC")]
    Arabic,
    #[serde(rename = "LANGUAGE_HINDI")]
    Hindi,
    #[serde(rename = "LANGUAGE_GREEK")]
    Greek,
    #[serde(rename = "LANGUAGE_TURKISH")]
    Turkish,
}

impl std::fmt::Display for Language {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Language::Unspecified => write!(f, "LANGUAGE_UNSPECIFIED"),
            Language::English => write!(f, "LANGUAGE_ENGLISH"),
            Language::Spanish => write!(f, "LANGUAGE_SPANISH"),
            Language::French => write!(f, "LANGUAGE_FRENCH"),
            Language::German => write!(f, "LANGUAGE_GERMAN"),
            Language::Italian => write!(f, "LANGUAGE_ITALIAN"),
            Language::Portuguese => write!(f, "LANGUAGE_PORTUGUESE"),
            Language::Dutch => write!(f, "LANGUAGE_DUTCH"),
            Language::Russian => write!(f, "LANGUAGE_RUSSIAN"),
            Language::Chinese => write!(f, "LANGUAGE_CHINESE"),
            Language::Japanese => write!(f, "LANGUAGE_JAPANESE"),
            Language::Korean => write!(f, "LANGUAGE_KOREAN"),
            Language::Arabic => write!(f, "LANGUAGE_ARABIC"),
            Language::Hindi => write!(f, "LANGUAGE_HINDI"),
            Language::Greek => write!(f, "LANGUAGE_GREEK"),
            Language::Turkish => write!(f, "LANGUAGE_TURKISH"),
        }
    }
}

impl std::str::FromStr for Language {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LANGUAGE_UNSPECIFIED" => std::result::Result::Ok(Language::Unspecified),
            "LANGUAGE_ENGLISH" => std::result::Result::Ok(Language::English),
            "LANGUAGE_SPANISH" => std::result::Result::Ok(Language::Spanish),
            "LANGUAGE_FRENCH" => std::result::Result::Ok(Language::French),
            "LANGUAGE_GERMAN" => std::result::Result::Ok(Language::German),
            "LANGUAGE_ITALIAN" => std::result::Result::Ok(Language::Italian),
            "LANGUAGE_PORTUGUESE" => std::result::Result::Ok(Language::Portuguese),
            "LANGUAGE_DUTCH" => std::result::Result::Ok(Language::Dutch),
            "LANGUAGE_RUSSIAN" => std::result::Result::Ok(Language::Russian),
            "LANGUAGE_CHINESE" => std::result::Result::Ok(Language::Chinese),
            "LANGUAGE_JAPANESE" => std::result::Result::Ok(Language::Japanese),
            "LANGUAGE_KOREAN" => std::result::Result::Ok(Language::Korean),
            "LANGUAGE_ARABIC" => std::result::Result::Ok(Language::Arabic),
            "LANGUAGE_HINDI" => std::result::Result::Ok(Language::Hindi),
            "LANGUAGE_GREEK" => std::result::Result::Ok(Language::Greek),
            "LANGUAGE_TURKISH" => std::result::Result::Ok(Language::Turkish),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Lead {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "website")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website: Option<String>,

    #[serde(rename = "phone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub phone: Option<String>,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<String>,

    #[serde(rename = "city")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub city: Option<String>,

    #[serde(rename = "state")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,

    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<String>,

    #[serde(rename = "latitude")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub latitude: Option<f64>,

    #[serde(rename = "longitude")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub longitude: Option<f64>,

    #[serde(rename = "googleRating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub google_rating: Option<f32>,

    #[serde(rename = "reviewCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_count: Option<i32>,

    #[serde(rename = "industry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub industry: Option<String>,

    #[serde(rename = "employeeCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub employee_count: Option<i32>,

    #[serde(rename = "estimatedRevenue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_revenue: Option<String>,

    #[serde(rename = "orgId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "job")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub job: Option<models::ScrapingJob>,

    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace>,

    #[serde(rename = "placeId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub place_id: Option<String>,

    #[serde(rename = "googleMapsUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub google_maps_url: Option<String>,

    #[serde(rename = "businessStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_status: Option<String>,

    #[serde(rename = "regularHours")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub regular_hours: Option<Vec<models::BusinessHours>>,

    #[serde(rename = "specialHours")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub special_hours: Option<Vec<models::BusinessHours>>,

    /// Google Places photo IDs
    #[serde(rename = "photoReferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub photo_references: Option<Vec<String>>,

    #[serde(rename = "mainPhotoUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub main_photo_url: Option<String>,

    #[serde(rename = "reviews")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviews: Option<Vec<models::Review>>,

    /// Google Places types
    #[serde(rename = "types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub types: Option<Vec<String>>,

    #[serde(rename = "amenities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub amenities: Option<Vec<String>>,

    #[serde(rename = "servesVegetarianFood")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub serves_vegetarian_food: Option<bool>,

    #[serde(rename = "outdoorSeating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outdoor_seating: Option<bool>,

    /// visa, amex, cash, etc
    #[serde(rename = "paymentMethods")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_methods: Option<Vec<String>>,

    #[serde(rename = "wheelchairAccessible")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub wheelchair_accessible: Option<bool>,

    #[serde(rename = "parkingAvailable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parking_available: Option<bool>,

    /// platform -> url
    #[serde(rename = "socialMedia")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub social_media: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "ratingCategory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating_category: Option<String>,

    #[serde(rename = "rating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating: Option<f32>,

    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "dataSourceVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_source_version: Option<String>,

    #[serde(rename = "scrapingSessionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scraping_session_id: Option<String>,

    #[serde(rename = "alternatePhones")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alternate_phones: Option<Vec<String>>,

    #[serde(rename = "contactPersonName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub contact_person_name: Option<String>,

    #[serde(rename = "contactPersonTitle")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub contact_person_title: Option<String>,

    #[serde(rename = "contactEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub contact_email: Option<String>,

    #[serde(rename = "foundedYear")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub founded_year: Option<i32>,

    #[serde(rename = "businessType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_type: Option<String>,

    #[serde(rename = "certifications")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certifications: Option<Vec<String>>,

    #[serde(rename = "licenseNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_number: Option<String>,

    #[serde(rename = "revenueRange")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub revenue_range: Option<models::RevenueRange>,

    #[serde(rename = "fundingStage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub funding_stage: Option<String>,

    #[serde(rename = "isPublicCompany")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_public_company: Option<bool>,

    /// In seconds
    #[serde(rename = "websiteLoadSpeed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_load_speed: Option<f32>,

    #[serde(rename = "hasSslCertificate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_ssl_certificate: Option<bool>,

    #[serde(rename = "cmsUsed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cms_used: Option<String>,

    #[serde(rename = "ecommercePlatforms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecommerce_platforms: Option<Vec<String>>,

    #[serde(rename = "timezone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timezone: Option<String>,

    #[serde(rename = "neighborhood")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub neighborhood: Option<String>,

    #[serde(rename = "nearbyLandmarks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nearby_landmarks: Option<Vec<String>>,

    #[serde(rename = "transportationAccess")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transportation_access: Option<String>,

    #[serde(rename = "employeeBenefits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub employee_benefits: Option<Vec<models::EmployeeBenefit>>,

    #[serde(rename = "parentCompany")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_company: Option<String>,

    #[serde(rename = "subsidiaries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsidiaries: Option<Vec<String>>,

    #[serde(rename = "isFranchise")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_franchise: Option<bool>,

    #[serde(rename = "seoKeywords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seo_keywords: Option<Vec<String>>,

    #[serde(rename = "usesGoogleAds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uses_google_ads: Option<bool>,

    #[serde(rename = "googleMyBusinessCategory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub google_my_business_category: Option<String>,

    #[serde(rename = "naicsCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub naics_code: Option<String>,

    #[serde(rename = "sicCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sic_code: Option<String>,

    #[serde(rename = "unspscCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unspsc_code: Option<String>,

    #[serde(rename = "isGreenCertified")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_green_certified: Option<bool>,

    #[serde(rename = "energySources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub energy_sources: Option<Vec<String>>,

    #[serde(rename = "sustainabilityRating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sustainability_rating: Option<String>,

    #[serde(rename = "recentAnnouncements")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recent_announcements: Option<Vec<String>>,

    #[serde(rename = "lastProductLaunch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_product_launch: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "hasLitigationHistory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_litigation_history: Option<bool>,

    #[serde(rename = "exportControlStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub export_control_status: Option<String>,

}


impl Lead {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Lead {
        Lead {
            id: None,
            name: None,
            website: None,
            phone: None,
            address: None,
            city: None,
            state: None,
            country: None,
            latitude: None,
            longitude: None,
            google_rating: None,
            review_count: None,
            industry: None,
            employee_count: None,
            estimated_revenue: None,
            org_id: None,
            tenant_id: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            job: None,
            workspace: None,
            place_id: None,
            google_maps_url: None,
            business_status: None,
            regular_hours: None,
            special_hours: None,
            photo_references: None,
            main_photo_url: None,
            reviews: None,
            types: None,
            amenities: None,
            serves_vegetarian_food: None,
            outdoor_seating: None,
            payment_methods: None,
            wheelchair_accessible: None,
            parking_available: None,
            social_media: None,
            rating_category: None,
            rating: None,
            count: None,
            last_updated: None,
            data_source_version: None,
            scraping_session_id: None,
            alternate_phones: None,
            contact_person_name: None,
            contact_person_title: None,
            contact_email: None,
            founded_year: None,
            business_type: None,
            certifications: None,
            license_number: None,
            revenue_range: None,
            funding_stage: None,
            is_public_company: None,
            website_load_speed: None,
            has_ssl_certificate: None,
            cms_used: None,
            ecommerce_platforms: None,
            timezone: None,
            neighborhood: None,
            nearby_landmarks: None,
            transportation_access: None,
            employee_benefits: None,
            parent_company: None,
            subsidiaries: None,
            is_franchise: None,
            seo_keywords: None,
            uses_google_ads: None,
            google_my_business_category: None,
            naics_code: None,
            sic_code: None,
            unspsc_code: None,
            is_green_certified: None,
            energy_sources: None,
            sustainability_rating: None,
            recent_announcements: None,
            last_product_launch: None,
            has_litigation_history: None,
            export_control_status: None,
        }
    }
}

/// Converts the Lead value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Lead {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.website.as_ref().map(|website| {
                [
                    "website".to_string(),
                    website.to_string(),
                ].join(",")
            }),


            self.phone.as_ref().map(|phone| {
                [
                    "phone".to_string(),
                    phone.to_string(),
                ].join(",")
            }),


            self.address.as_ref().map(|address| {
                [
                    "address".to_string(),
                    address.to_string(),
                ].join(",")
            }),


            self.city.as_ref().map(|city| {
                [
                    "city".to_string(),
                    city.to_string(),
                ].join(",")
            }),


            self.state.as_ref().map(|state| {
                [
                    "state".to_string(),
                    state.to_string(),
                ].join(",")
            }),


            self.country.as_ref().map(|country| {
                [
                    "country".to_string(),
                    country.to_string(),
                ].join(",")
            }),


            self.latitude.as_ref().map(|latitude| {
                [
                    "latitude".to_string(),
                    latitude.to_string(),
                ].join(",")
            }),


            self.longitude.as_ref().map(|longitude| {
                [
                    "longitude".to_string(),
                    longitude.to_string(),
                ].join(",")
            }),


            self.google_rating.as_ref().map(|google_rating| {
                [
                    "googleRating".to_string(),
                    google_rating.to_string(),
                ].join(",")
            }),


            self.review_count.as_ref().map(|review_count| {
                [
                    "reviewCount".to_string(),
                    review_count.to_string(),
                ].join(",")
            }),


            self.industry.as_ref().map(|industry| {
                [
                    "industry".to_string(),
                    industry.to_string(),
                ].join(",")
            }),


            self.employee_count.as_ref().map(|employee_count| {
                [
                    "employeeCount".to_string(),
                    employee_count.to_string(),
                ].join(",")
            }),


            self.estimated_revenue.as_ref().map(|estimated_revenue| {
                [
                    "estimatedRevenue".to_string(),
                    estimated_revenue.to_string(),
                ].join(",")
            }),


            self.org_id.as_ref().map(|org_id| {
                [
                    "orgId".to_string(),
                    org_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping job in query parameter serialization

            // Skipping workspace in query parameter serialization


            self.place_id.as_ref().map(|place_id| {
                [
                    "placeId".to_string(),
                    place_id.to_string(),
                ].join(",")
            }),


            self.google_maps_url.as_ref().map(|google_maps_url| {
                [
                    "googleMapsUrl".to_string(),
                    google_maps_url.to_string(),
                ].join(",")
            }),


            self.business_status.as_ref().map(|business_status| {
                [
                    "businessStatus".to_string(),
                    business_status.to_string(),
                ].join(",")
            }),

            // Skipping regularHours in query parameter serialization

            // Skipping specialHours in query parameter serialization


            self.photo_references.as_ref().map(|photo_references| {
                [
                    "photoReferences".to_string(),
                    photo_references.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.main_photo_url.as_ref().map(|main_photo_url| {
                [
                    "mainPhotoUrl".to_string(),
                    main_photo_url.to_string(),
                ].join(",")
            }),

            // Skipping reviews in query parameter serialization


            self.types.as_ref().map(|types| {
                [
                    "types".to_string(),
                    types.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.amenities.as_ref().map(|amenities| {
                [
                    "amenities".to_string(),
                    amenities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.serves_vegetarian_food.as_ref().map(|serves_vegetarian_food| {
                [
                    "servesVegetarianFood".to_string(),
                    serves_vegetarian_food.to_string(),
                ].join(",")
            }),


            self.outdoor_seating.as_ref().map(|outdoor_seating| {
                [
                    "outdoorSeating".to_string(),
                    outdoor_seating.to_string(),
                ].join(",")
            }),


            self.payment_methods.as_ref().map(|payment_methods| {
                [
                    "paymentMethods".to_string(),
                    payment_methods.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.wheelchair_accessible.as_ref().map(|wheelchair_accessible| {
                [
                    "wheelchairAccessible".to_string(),
                    wheelchair_accessible.to_string(),
                ].join(",")
            }),


            self.parking_available.as_ref().map(|parking_available| {
                [
                    "parkingAvailable".to_string(),
                    parking_available.to_string(),
                ].join(",")
            }),

            // Skipping socialMedia in query parameter serialization


            self.rating_category.as_ref().map(|rating_category| {
                [
                    "ratingCategory".to_string(),
                    rating_category.to_string(),
                ].join(",")
            }),


            self.rating.as_ref().map(|rating| {
                [
                    "rating".to_string(),
                    rating.to_string(),
                ].join(",")
            }),


            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),

            // Skipping lastUpdated in query parameter serialization


            self.data_source_version.as_ref().map(|data_source_version| {
                [
                    "dataSourceVersion".to_string(),
                    data_source_version.to_string(),
                ].join(",")
            }),


            self.scraping_session_id.as_ref().map(|scraping_session_id| {
                [
                    "scrapingSessionId".to_string(),
                    scraping_session_id.to_string(),
                ].join(",")
            }),


            self.alternate_phones.as_ref().map(|alternate_phones| {
                [
                    "alternatePhones".to_string(),
                    alternate_phones.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.contact_person_name.as_ref().map(|contact_person_name| {
                [
                    "contactPersonName".to_string(),
                    contact_person_name.to_string(),
                ].join(",")
            }),


            self.contact_person_title.as_ref().map(|contact_person_title| {
                [
                    "contactPersonTitle".to_string(),
                    contact_person_title.to_string(),
                ].join(",")
            }),


            self.contact_email.as_ref().map(|contact_email| {
                [
                    "contactEmail".to_string(),
                    contact_email.to_string(),
                ].join(",")
            }),


            self.founded_year.as_ref().map(|founded_year| {
                [
                    "foundedYear".to_string(),
                    founded_year.to_string(),
                ].join(",")
            }),


            self.business_type.as_ref().map(|business_type| {
                [
                    "businessType".to_string(),
                    business_type.to_string(),
                ].join(",")
            }),


            self.certifications.as_ref().map(|certifications| {
                [
                    "certifications".to_string(),
                    certifications.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.license_number.as_ref().map(|license_number| {
                [
                    "licenseNumber".to_string(),
                    license_number.to_string(),
                ].join(",")
            }),

            // Skipping revenueRange in query parameter serialization


            self.funding_stage.as_ref().map(|funding_stage| {
                [
                    "fundingStage".to_string(),
                    funding_stage.to_string(),
                ].join(",")
            }),


            self.is_public_company.as_ref().map(|is_public_company| {
                [
                    "isPublicCompany".to_string(),
                    is_public_company.to_string(),
                ].join(",")
            }),


            self.website_load_speed.as_ref().map(|website_load_speed| {
                [
                    "websiteLoadSpeed".to_string(),
                    website_load_speed.to_string(),
                ].join(",")
            }),


            self.has_ssl_certificate.as_ref().map(|has_ssl_certificate| {
                [
                    "hasSslCertificate".to_string(),
                    has_ssl_certificate.to_string(),
                ].join(",")
            }),


            self.cms_used.as_ref().map(|cms_used| {
                [
                    "cmsUsed".to_string(),
                    cms_used.to_string(),
                ].join(",")
            }),


            self.ecommerce_platforms.as_ref().map(|ecommerce_platforms| {
                [
                    "ecommercePlatforms".to_string(),
                    ecommerce_platforms.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.timezone.as_ref().map(|timezone| {
                [
                    "timezone".to_string(),
                    timezone.to_string(),
                ].join(",")
            }),


            self.neighborhood.as_ref().map(|neighborhood| {
                [
                    "neighborhood".to_string(),
                    neighborhood.to_string(),
                ].join(",")
            }),


            self.nearby_landmarks.as_ref().map(|nearby_landmarks| {
                [
                    "nearbyLandmarks".to_string(),
                    nearby_landmarks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.transportation_access.as_ref().map(|transportation_access| {
                [
                    "transportationAccess".to_string(),
                    transportation_access.to_string(),
                ].join(",")
            }),

            // Skipping employeeBenefits in query parameter serialization


            self.parent_company.as_ref().map(|parent_company| {
                [
                    "parentCompany".to_string(),
                    parent_company.to_string(),
                ].join(",")
            }),


            self.subsidiaries.as_ref().map(|subsidiaries| {
                [
                    "subsidiaries".to_string(),
                    subsidiaries.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.is_franchise.as_ref().map(|is_franchise| {
                [
                    "isFranchise".to_string(),
                    is_franchise.to_string(),
                ].join(",")
            }),


            self.seo_keywords.as_ref().map(|seo_keywords| {
                [
                    "seoKeywords".to_string(),
                    seo_keywords.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.uses_google_ads.as_ref().map(|uses_google_ads| {
                [
                    "usesGoogleAds".to_string(),
                    uses_google_ads.to_string(),
                ].join(",")
            }),


            self.google_my_business_category.as_ref().map(|google_my_business_category| {
                [
                    "googleMyBusinessCategory".to_string(),
                    google_my_business_category.to_string(),
                ].join(",")
            }),


            self.naics_code.as_ref().map(|naics_code| {
                [
                    "naicsCode".to_string(),
                    naics_code.to_string(),
                ].join(",")
            }),


            self.sic_code.as_ref().map(|sic_code| {
                [
                    "sicCode".to_string(),
                    sic_code.to_string(),
                ].join(",")
            }),


            self.unspsc_code.as_ref().map(|unspsc_code| {
                [
                    "unspscCode".to_string(),
                    unspsc_code.to_string(),
                ].join(",")
            }),


            self.is_green_certified.as_ref().map(|is_green_certified| {
                [
                    "isGreenCertified".to_string(),
                    is_green_certified.to_string(),
                ].join(",")
            }),


            self.energy_sources.as_ref().map(|energy_sources| {
                [
                    "energySources".to_string(),
                    energy_sources.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.sustainability_rating.as_ref().map(|sustainability_rating| {
                [
                    "sustainabilityRating".to_string(),
                    sustainability_rating.to_string(),
                ].join(",")
            }),


            self.recent_announcements.as_ref().map(|recent_announcements| {
                [
                    "recentAnnouncements".to_string(),
                    recent_announcements.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping lastProductLaunch in query parameter serialization


            self.has_litigation_history.as_ref().map(|has_litigation_history| {
                [
                    "hasLitigationHistory".to_string(),
                    has_litigation_history.to_string(),
                ].join(",")
            }),


            self.export_control_status.as_ref().map(|export_control_status| {
                [
                    "exportControlStatus".to_string(),
                    export_control_status.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Lead value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Lead {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub website: Vec<String>,
            pub phone: Vec<String>,
            pub address: Vec<String>,
            pub city: Vec<String>,
            pub state: Vec<String>,
            pub country: Vec<String>,
            pub latitude: Vec<f64>,
            pub longitude: Vec<f64>,
            pub google_rating: Vec<f32>,
            pub review_count: Vec<i32>,
            pub industry: Vec<String>,
            pub employee_count: Vec<i32>,
            pub estimated_revenue: Vec<String>,
            pub org_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub job: Vec<models::ScrapingJob>,
            pub workspace: Vec<models::Workspace>,
            pub place_id: Vec<String>,
            pub google_maps_url: Vec<String>,
            pub business_status: Vec<String>,
            pub regular_hours: Vec<Vec<models::BusinessHours>>,
            pub special_hours: Vec<Vec<models::BusinessHours>>,
            pub photo_references: Vec<Vec<String>>,
            pub main_photo_url: Vec<String>,
            pub reviews: Vec<Vec<models::Review>>,
            pub types: Vec<Vec<String>>,
            pub amenities: Vec<Vec<String>>,
            pub serves_vegetarian_food: Vec<bool>,
            pub outdoor_seating: Vec<bool>,
            pub payment_methods: Vec<Vec<String>>,
            pub wheelchair_accessible: Vec<bool>,
            pub parking_available: Vec<bool>,
            pub social_media: Vec<std::collections::HashMap<String, String>>,
            pub rating_category: Vec<String>,
            pub rating: Vec<f32>,
            pub count: Vec<i32>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
            pub data_source_version: Vec<String>,
            pub scraping_session_id: Vec<String>,
            pub alternate_phones: Vec<Vec<String>>,
            pub contact_person_name: Vec<String>,
            pub contact_person_title: Vec<String>,
            pub contact_email: Vec<String>,
            pub founded_year: Vec<i32>,
            pub business_type: Vec<String>,
            pub certifications: Vec<Vec<String>>,
            pub license_number: Vec<String>,
            pub revenue_range: Vec<models::RevenueRange>,
            pub funding_stage: Vec<String>,
            pub is_public_company: Vec<bool>,
            pub website_load_speed: Vec<f32>,
            pub has_ssl_certificate: Vec<bool>,
            pub cms_used: Vec<String>,
            pub ecommerce_platforms: Vec<Vec<String>>,
            pub timezone: Vec<String>,
            pub neighborhood: Vec<String>,
            pub nearby_landmarks: Vec<Vec<String>>,
            pub transportation_access: Vec<String>,
            pub employee_benefits: Vec<Vec<models::EmployeeBenefit>>,
            pub parent_company: Vec<String>,
            pub subsidiaries: Vec<Vec<String>>,
            pub is_franchise: Vec<bool>,
            pub seo_keywords: Vec<Vec<String>>,
            pub uses_google_ads: Vec<bool>,
            pub google_my_business_category: Vec<String>,
            pub naics_code: Vec<String>,
            pub sic_code: Vec<String>,
            pub unspsc_code: Vec<String>,
            pub is_green_certified: Vec<bool>,
            pub energy_sources: Vec<Vec<String>>,
            pub sustainability_rating: Vec<String>,
            pub recent_announcements: Vec<Vec<String>>,
            pub last_product_launch: Vec<chrono::DateTime::<chrono::Utc>>,
            pub has_litigation_history: Vec<bool>,
            pub export_control_status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Lead".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "website" => intermediate_rep.website.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "phone" => intermediate_rep.phone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "city" => intermediate_rep.city.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "state" => intermediate_rep.state.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "latitude" => intermediate_rep.latitude.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "longitude" => intermediate_rep.longitude.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "googleRating" => intermediate_rep.google_rating.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reviewCount" => intermediate_rep.review_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "industry" => intermediate_rep.industry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "employeeCount" => intermediate_rep.employee_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "estimatedRevenue" => intermediate_rep.estimated_revenue.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orgId" => intermediate_rep.org_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "job" => intermediate_rep.job.push(<models::ScrapingJob as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "placeId" => intermediate_rep.place_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "googleMapsUrl" => intermediate_rep.google_maps_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "businessStatus" => intermediate_rep.business_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "regularHours" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    "specialHours" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    "photoReferences" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mainPhotoUrl" => intermediate_rep.main_photo_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "reviews" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    "types" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    "amenities" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "servesVegetarianFood" => intermediate_rep.serves_vegetarian_food.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outdoorSeating" => intermediate_rep.outdoor_seating.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "paymentMethods" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "wheelchairAccessible" => intermediate_rep.wheelchair_accessible.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parkingAvailable" => intermediate_rep.parking_available.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "socialMedia" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ratingCategory" => intermediate_rep.rating_category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep.rating.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataSourceVersion" => intermediate_rep.data_source_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scrapingSessionId" => intermediate_rep.scraping_session_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "alternatePhones" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "contactPersonName" => intermediate_rep.contact_person_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contactPersonTitle" => intermediate_rep.contact_person_title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contactEmail" => intermediate_rep.contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "foundedYear" => intermediate_rep.founded_year.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "businessType" => intermediate_rep.business_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "certifications" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "licenseNumber" => intermediate_rep.license_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "revenueRange" => intermediate_rep.revenue_range.push(<models::RevenueRange as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fundingStage" => intermediate_rep.funding_stage.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isPublicCompany" => intermediate_rep.is_public_company.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "websiteLoadSpeed" => intermediate_rep.website_load_speed.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hasSslCertificate" => intermediate_rep.has_ssl_certificate.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cmsUsed" => intermediate_rep.cms_used.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ecommercePlatforms" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "timezone" => intermediate_rep.timezone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "neighborhood" => intermediate_rep.neighborhood.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "nearbyLandmarks" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "transportationAccess" => intermediate_rep.transportation_access.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "employeeBenefits" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "parentCompany" => intermediate_rep.parent_company.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subsidiaries" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isFranchise" => intermediate_rep.is_franchise.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "seoKeywords" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "usesGoogleAds" => intermediate_rep.uses_google_ads.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "googleMyBusinessCategory" => intermediate_rep.google_my_business_category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "naicsCode" => intermediate_rep.naics_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sicCode" => intermediate_rep.sic_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unspscCode" => intermediate_rep.unspsc_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isGreenCertified" => intermediate_rep.is_green_certified.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "energySources" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sustainabilityRating" => intermediate_rep.sustainability_rating.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "recentAnnouncements" => return std::result::Result::Err("Parsing a container in this style is not supported in Lead".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "lastProductLaunch" => intermediate_rep.last_product_launch.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hasLitigationHistory" => intermediate_rep.has_litigation_history.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exportControlStatus" => intermediate_rep.export_control_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Lead".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Lead {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            website: intermediate_rep.website.into_iter().next(),
            phone: intermediate_rep.phone.into_iter().next(),
            address: intermediate_rep.address.into_iter().next(),
            city: intermediate_rep.city.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
            country: intermediate_rep.country.into_iter().next(),
            latitude: intermediate_rep.latitude.into_iter().next(),
            longitude: intermediate_rep.longitude.into_iter().next(),
            google_rating: intermediate_rep.google_rating.into_iter().next(),
            review_count: intermediate_rep.review_count.into_iter().next(),
            industry: intermediate_rep.industry.into_iter().next(),
            employee_count: intermediate_rep.employee_count.into_iter().next(),
            estimated_revenue: intermediate_rep.estimated_revenue.into_iter().next(),
            org_id: intermediate_rep.org_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            job: intermediate_rep.job.into_iter().next(),
            workspace: intermediate_rep.workspace.into_iter().next(),
            place_id: intermediate_rep.place_id.into_iter().next(),
            google_maps_url: intermediate_rep.google_maps_url.into_iter().next(),
            business_status: intermediate_rep.business_status.into_iter().next(),
            regular_hours: intermediate_rep.regular_hours.into_iter().next(),
            special_hours: intermediate_rep.special_hours.into_iter().next(),
            photo_references: intermediate_rep.photo_references.into_iter().next(),
            main_photo_url: intermediate_rep.main_photo_url.into_iter().next(),
            reviews: intermediate_rep.reviews.into_iter().next(),
            types: intermediate_rep.types.into_iter().next(),
            amenities: intermediate_rep.amenities.into_iter().next(),
            serves_vegetarian_food: intermediate_rep.serves_vegetarian_food.into_iter().next(),
            outdoor_seating: intermediate_rep.outdoor_seating.into_iter().next(),
            payment_methods: intermediate_rep.payment_methods.into_iter().next(),
            wheelchair_accessible: intermediate_rep.wheelchair_accessible.into_iter().next(),
            parking_available: intermediate_rep.parking_available.into_iter().next(),
            social_media: intermediate_rep.social_media.into_iter().next(),
            rating_category: intermediate_rep.rating_category.into_iter().next(),
            rating: intermediate_rep.rating.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            last_updated: intermediate_rep.last_updated.into_iter().next(),
            data_source_version: intermediate_rep.data_source_version.into_iter().next(),
            scraping_session_id: intermediate_rep.scraping_session_id.into_iter().next(),
            alternate_phones: intermediate_rep.alternate_phones.into_iter().next(),
            contact_person_name: intermediate_rep.contact_person_name.into_iter().next(),
            contact_person_title: intermediate_rep.contact_person_title.into_iter().next(),
            contact_email: intermediate_rep.contact_email.into_iter().next(),
            founded_year: intermediate_rep.founded_year.into_iter().next(),
            business_type: intermediate_rep.business_type.into_iter().next(),
            certifications: intermediate_rep.certifications.into_iter().next(),
            license_number: intermediate_rep.license_number.into_iter().next(),
            revenue_range: intermediate_rep.revenue_range.into_iter().next(),
            funding_stage: intermediate_rep.funding_stage.into_iter().next(),
            is_public_company: intermediate_rep.is_public_company.into_iter().next(),
            website_load_speed: intermediate_rep.website_load_speed.into_iter().next(),
            has_ssl_certificate: intermediate_rep.has_ssl_certificate.into_iter().next(),
            cms_used: intermediate_rep.cms_used.into_iter().next(),
            ecommerce_platforms: intermediate_rep.ecommerce_platforms.into_iter().next(),
            timezone: intermediate_rep.timezone.into_iter().next(),
            neighborhood: intermediate_rep.neighborhood.into_iter().next(),
            nearby_landmarks: intermediate_rep.nearby_landmarks.into_iter().next(),
            transportation_access: intermediate_rep.transportation_access.into_iter().next(),
            employee_benefits: intermediate_rep.employee_benefits.into_iter().next(),
            parent_company: intermediate_rep.parent_company.into_iter().next(),
            subsidiaries: intermediate_rep.subsidiaries.into_iter().next(),
            is_franchise: intermediate_rep.is_franchise.into_iter().next(),
            seo_keywords: intermediate_rep.seo_keywords.into_iter().next(),
            uses_google_ads: intermediate_rep.uses_google_ads.into_iter().next(),
            google_my_business_category: intermediate_rep.google_my_business_category.into_iter().next(),
            naics_code: intermediate_rep.naics_code.into_iter().next(),
            sic_code: intermediate_rep.sic_code.into_iter().next(),
            unspsc_code: intermediate_rep.unspsc_code.into_iter().next(),
            is_green_certified: intermediate_rep.is_green_certified.into_iter().next(),
            energy_sources: intermediate_rep.energy_sources.into_iter().next(),
            sustainability_rating: intermediate_rep.sustainability_rating.into_iter().next(),
            recent_announcements: intermediate_rep.recent_announcements.into_iter().next(),
            last_product_launch: intermediate_rep.last_product_launch.into_iter().next(),
            has_litigation_history: intermediate_rep.has_litigation_history.into_iter().next(),
            export_control_status: intermediate_rep.export_control_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Lead> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Lead>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Lead>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Lead - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Lead> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Lead as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Lead - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LimitInfo {
    #[serde(rename = "current")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current: Option<i32>,

    #[serde(rename = "limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<i32>,

    #[serde(rename = "resetTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reset_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "windowSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub window_size: Option<String>,

}


impl LimitInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LimitInfo {
        LimitInfo {
            current: None,
            limit: None,
            reset_time: None,
            window_size: None,
        }
    }
}

/// Converts the LimitInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LimitInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.current.as_ref().map(|current| {
                [
                    "current".to_string(),
                    current.to_string(),
                ].join(",")
            }),


            self.limit.as_ref().map(|limit| {
                [
                    "limit".to_string(),
                    limit.to_string(),
                ].join(",")
            }),

            // Skipping resetTime in query parameter serialization


            self.window_size.as_ref().map(|window_size| {
                [
                    "windowSize".to_string(),
                    window_size.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LimitInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LimitInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current: Vec<i32>,
            pub limit: Vec<i32>,
            pub reset_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub window_size: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LimitInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "current" => intermediate_rep.current.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "limit" => intermediate_rep.limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resetTime" => intermediate_rep.reset_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "windowSize" => intermediate_rep.window_size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LimitInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LimitInfo {
            current: intermediate_rep.current.into_iter().next(),
            limit: intermediate_rep.limit.into_iter().next(),
            reset_time: intermediate_rep.reset_time.into_iter().next(),
            window_size: intermediate_rep.window_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LimitInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LimitInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LimitInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LimitInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LimitInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LimitInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LimitInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAccountsResponse {
    #[serde(rename = "accounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accounts: Option<Vec<models::Account>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

}


impl ListAccountsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListAccountsResponse {
        ListAccountsResponse {
            accounts: None,
            next_page_number: None,
        }
    }
}

/// Converts the ListAccountsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListAccountsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping accounts in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAccountsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAccountsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accounts: Vec<Vec<models::Account>>,
            pub next_page_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAccountsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "accounts" => return std::result::Result::Err("Parsing a container in this style is not supported in ListAccountsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAccountsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAccountsResponse {
            accounts: intermediate_rep.accounts.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAccountsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAccountsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAccountsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListAccountsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListAccountsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAccountsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListAccountsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAccountsResponse1 {
    #[serde(rename = "accounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accounts: Option<Vec<models::Account1>>,

    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_token: Option<String>,

    #[serde(rename = "totalSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_size: Option<i32>,

}


impl ListAccountsResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListAccountsResponse1 {
        ListAccountsResponse1 {
            accounts: None,
            next_page_token: None,
            total_size: None,
        }
    }
}

/// Converts the ListAccountsResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListAccountsResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping accounts in query parameter serialization


            self.next_page_token.as_ref().map(|next_page_token| {
                [
                    "nextPageToken".to_string(),
                    next_page_token.to_string(),
                ].join(",")
            }),


            self.total_size.as_ref().map(|total_size| {
                [
                    "totalSize".to_string(),
                    total_size.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAccountsResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAccountsResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accounts: Vec<Vec<models::Account1>>,
            pub next_page_token: Vec<String>,
            pub total_size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAccountsResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "accounts" => return std::result::Result::Err("Parsing a container in this style is not supported in ListAccountsResponse1".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageToken" => intermediate_rep.next_page_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalSize" => intermediate_rep.total_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAccountsResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAccountsResponse1 {
            accounts: intermediate_rep.accounts.into_iter().next(),
            next_page_token: intermediate_rep.next_page_token.into_iter().next(),
            total_size: intermediate_rep.total_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAccountsResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAccountsResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAccountsResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListAccountsResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListAccountsResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAccountsResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListAccountsResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListApiKeysResponse {
    #[serde(rename = "apiKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_keys: Option<Vec<models::ApiKey>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

    #[serde(rename = "totalCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i32>,

}


impl ListApiKeysResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListApiKeysResponse {
        ListApiKeysResponse {
            api_keys: None,
            next_page_number: None,
            total_count: None,
        }
    }
}

/// Converts the ListApiKeysResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListApiKeysResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKeys in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),


            self.total_count.as_ref().map(|total_count| {
                [
                    "totalCount".to_string(),
                    total_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListApiKeysResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListApiKeysResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_keys: Vec<Vec<models::ApiKey>>,
            pub next_page_number: Vec<i32>,
            pub total_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListApiKeysResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "apiKeys" => return std::result::Result::Err("Parsing a container in this style is not supported in ListApiKeysResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalCount" => intermediate_rep.total_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListApiKeysResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListApiKeysResponse {
            api_keys: intermediate_rep.api_keys.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
            total_count: intermediate_rep.total_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListApiKeysResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListApiKeysResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListApiKeysResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListApiKeysResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListApiKeysResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListApiKeysResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListApiKeysResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListLeadsResponse {
    #[serde(rename = "leads")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub leads: Option<Vec<models::Lead>>,

    #[serde(rename = "totalCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i32>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

}


impl ListLeadsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListLeadsResponse {
        ListLeadsResponse {
            leads: None,
            total_count: None,
            next_page_number: None,
        }
    }
}

/// Converts the ListLeadsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListLeadsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping leads in query parameter serialization


            self.total_count.as_ref().map(|total_count| {
                [
                    "totalCount".to_string(),
                    total_count.to_string(),
                ].join(",")
            }),


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListLeadsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListLeadsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub leads: Vec<Vec<models::Lead>>,
            pub total_count: Vec<i32>,
            pub next_page_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListLeadsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "leads" => return std::result::Result::Err("Parsing a container in this style is not supported in ListLeadsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "totalCount" => intermediate_rep.total_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListLeadsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListLeadsResponse {
            leads: intermediate_rep.leads.into_iter().next(),
            total_count: intermediate_rep.total_count.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListLeadsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListLeadsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListLeadsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListLeadsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListLeadsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListLeadsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListLeadsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListOrganizationsResponse {
    #[serde(rename = "organizations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations: Option<Vec<models::Organization>>,

    #[serde(rename = "totalCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i32>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

}


impl ListOrganizationsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListOrganizationsResponse {
        ListOrganizationsResponse {
            organizations: None,
            total_count: None,
            next_page_number: None,
        }
    }
}

/// Converts the ListOrganizationsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListOrganizationsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping organizations in query parameter serialization


            self.total_count.as_ref().map(|total_count| {
                [
                    "totalCount".to_string(),
                    total_count.to_string(),
                ].join(",")
            }),


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListOrganizationsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListOrganizationsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organizations: Vec<Vec<models::Organization>>,
            pub total_count: Vec<i32>,
            pub next_page_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListOrganizationsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "organizations" => return std::result::Result::Err("Parsing a container in this style is not supported in ListOrganizationsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "totalCount" => intermediate_rep.total_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListOrganizationsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListOrganizationsResponse {
            organizations: intermediate_rep.organizations.into_iter().next(),
            total_count: intermediate_rep.total_count.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListOrganizationsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListOrganizationsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListOrganizationsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListOrganizationsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListOrganizationsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListOrganizationsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListOrganizationsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListScrapingJobsResponse {
    #[serde(rename = "jobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs: Option<Vec<models::ScrapingJob>>,

}


impl ListScrapingJobsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListScrapingJobsResponse {
        ListScrapingJobsResponse {
            jobs: None,
        }
    }
}

/// Converts the ListScrapingJobsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListScrapingJobsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jobs in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListScrapingJobsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListScrapingJobsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub jobs: Vec<Vec<models::ScrapingJob>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListScrapingJobsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "jobs" => return std::result::Result::Err("Parsing a container in this style is not supported in ListScrapingJobsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListScrapingJobsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListScrapingJobsResponse {
            jobs: intermediate_rep.jobs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListScrapingJobsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListScrapingJobsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListScrapingJobsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListScrapingJobsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListScrapingJobsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListScrapingJobsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListScrapingJobsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListTenantApiKeysResponse {
    #[serde(rename = "apiKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_keys: Option<Vec<models::TenantApiKey>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

    #[serde(rename = "totalCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i32>,

}


impl ListTenantApiKeysResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListTenantApiKeysResponse {
        ListTenantApiKeysResponse {
            api_keys: None,
            next_page_number: None,
            total_count: None,
        }
    }
}

/// Converts the ListTenantApiKeysResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListTenantApiKeysResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKeys in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),


            self.total_count.as_ref().map(|total_count| {
                [
                    "totalCount".to_string(),
                    total_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListTenantApiKeysResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListTenantApiKeysResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_keys: Vec<Vec<models::TenantApiKey>>,
            pub next_page_number: Vec<i32>,
            pub total_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListTenantApiKeysResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "apiKeys" => return std::result::Result::Err("Parsing a container in this style is not supported in ListTenantApiKeysResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalCount" => intermediate_rep.total_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListTenantApiKeysResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListTenantApiKeysResponse {
            api_keys: intermediate_rep.api_keys.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
            total_count: intermediate_rep.total_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListTenantApiKeysResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListTenantApiKeysResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListTenantApiKeysResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListTenantApiKeysResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListTenantApiKeysResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListTenantApiKeysResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListTenantApiKeysResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListTenantsResponse {
    #[serde(rename = "tenants")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenants: Option<Vec<models::Tenant>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

}


impl ListTenantsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListTenantsResponse {
        ListTenantsResponse {
            tenants: None,
            next_page_number: None,
        }
    }
}

/// Converts the ListTenantsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListTenantsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tenants in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListTenantsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListTenantsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenants: Vec<Vec<models::Tenant>>,
            pub next_page_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListTenantsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tenants" => return std::result::Result::Err("Parsing a container in this style is not supported in ListTenantsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListTenantsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListTenantsResponse {
            tenants: intermediate_rep.tenants.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListTenantsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListTenantsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListTenantsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListTenantsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListTenantsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListTenantsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListTenantsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListWebhooksResponse {
    #[serde(rename = "webhooks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhooks: Option<Vec<models::WebhookConfig>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

    #[serde(rename = "totalCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i32>,

}


impl ListWebhooksResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListWebhooksResponse {
        ListWebhooksResponse {
            webhooks: None,
            next_page_number: None,
            total_count: None,
        }
    }
}

/// Converts the ListWebhooksResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListWebhooksResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping webhooks in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),


            self.total_count.as_ref().map(|total_count| {
                [
                    "totalCount".to_string(),
                    total_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListWebhooksResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListWebhooksResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub webhooks: Vec<Vec<models::WebhookConfig>>,
            pub next_page_number: Vec<i32>,
            pub total_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListWebhooksResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "webhooks" => return std::result::Result::Err("Parsing a container in this style is not supported in ListWebhooksResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalCount" => intermediate_rep.total_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListWebhooksResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListWebhooksResponse {
            webhooks: intermediate_rep.webhooks.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
            total_count: intermediate_rep.total_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListWebhooksResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListWebhooksResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListWebhooksResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListWebhooksResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListWebhooksResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListWebhooksResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListWebhooksResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListWorkflowsResponse {
    #[serde(rename = "workflows")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<Vec<models::ScrapingWorkflow>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

}


impl ListWorkflowsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListWorkflowsResponse {
        ListWorkflowsResponse {
            workflows: None,
            next_page_number: None,
        }
    }
}

/// Converts the ListWorkflowsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListWorkflowsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workflows in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListWorkflowsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListWorkflowsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflows: Vec<Vec<models::ScrapingWorkflow>>,
            pub next_page_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListWorkflowsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "workflows" => return std::result::Result::Err("Parsing a container in this style is not supported in ListWorkflowsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListWorkflowsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListWorkflowsResponse {
            workflows: intermediate_rep.workflows.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListWorkflowsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListWorkflowsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListWorkflowsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListWorkflowsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListWorkflowsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListWorkflowsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListWorkflowsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListWorkspaceSharingsResponse {
    #[serde(rename = "sharings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharings: Option<Vec<models::WorkspaceSharing>>,

    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_token: Option<String>,

    #[serde(rename = "totalSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_size: Option<i32>,

}


impl ListWorkspaceSharingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListWorkspaceSharingsResponse {
        ListWorkspaceSharingsResponse {
            sharings: None,
            next_page_token: None,
            total_size: None,
        }
    }
}

/// Converts the ListWorkspaceSharingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListWorkspaceSharingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sharings in query parameter serialization


            self.next_page_token.as_ref().map(|next_page_token| {
                [
                    "nextPageToken".to_string(),
                    next_page_token.to_string(),
                ].join(",")
            }),


            self.total_size.as_ref().map(|total_size| {
                [
                    "totalSize".to_string(),
                    total_size.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListWorkspaceSharingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListWorkspaceSharingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sharings: Vec<Vec<models::WorkspaceSharing>>,
            pub next_page_token: Vec<String>,
            pub total_size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListWorkspaceSharingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sharings" => return std::result::Result::Err("Parsing a container in this style is not supported in ListWorkspaceSharingsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageToken" => intermediate_rep.next_page_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalSize" => intermediate_rep.total_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListWorkspaceSharingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListWorkspaceSharingsResponse {
            sharings: intermediate_rep.sharings.into_iter().next(),
            next_page_token: intermediate_rep.next_page_token.into_iter().next(),
            total_size: intermediate_rep.total_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListWorkspaceSharingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListWorkspaceSharingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListWorkspaceSharingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListWorkspaceSharingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListWorkspaceSharingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListWorkspaceSharingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListWorkspaceSharingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListWorkspacesResponse {
    #[serde(rename = "workspaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspaces: Option<Vec<models::Workspace>>,

    #[serde(rename = "nextPageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_number: Option<i32>,

}


impl ListWorkspacesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListWorkspacesResponse {
        ListWorkspacesResponse {
            workspaces: None,
            next_page_number: None,
        }
    }
}

/// Converts the ListWorkspacesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListWorkspacesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspaces in query parameter serialization


            self.next_page_number.as_ref().map(|next_page_number| {
                [
                    "nextPageNumber".to_string(),
                    next_page_number.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListWorkspacesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListWorkspacesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspaces: Vec<Vec<models::Workspace>>,
            pub next_page_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListWorkspacesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "workspaces" => return std::result::Result::Err("Parsing a container in this style is not supported in ListWorkspacesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageNumber" => intermediate_rep.next_page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListWorkspacesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListWorkspacesResponse {
            workspaces: intermediate_rep.workspaces.into_iter().next(),
            next_page_number: intermediate_rep.next_page_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListWorkspacesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListWorkspacesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListWorkspacesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListWorkspacesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListWorkspacesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListWorkspacesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListWorkspacesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListWorkspacesResponse1 {
    #[serde(rename = "workspaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspaces: Option<Vec<models::Workspace1>>,

    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_token: Option<String>,

    #[serde(rename = "totalSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_size: Option<i32>,

}


impl ListWorkspacesResponse1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ListWorkspacesResponse1 {
        ListWorkspacesResponse1 {
            workspaces: None,
            next_page_token: None,
            total_size: None,
        }
    }
}

/// Converts the ListWorkspacesResponse1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ListWorkspacesResponse1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspaces in query parameter serialization


            self.next_page_token.as_ref().map(|next_page_token| {
                [
                    "nextPageToken".to_string(),
                    next_page_token.to_string(),
                ].join(",")
            }),


            self.total_size.as_ref().map(|total_size| {
                [
                    "totalSize".to_string(),
                    total_size.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListWorkspacesResponse1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListWorkspacesResponse1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspaces: Vec<Vec<models::Workspace1>>,
            pub next_page_token: Vec<String>,
            pub total_size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListWorkspacesResponse1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "workspaces" => return std::result::Result::Err("Parsing a container in this style is not supported in ListWorkspacesResponse1".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nextPageToken" => intermediate_rep.next_page_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalSize" => intermediate_rep.total_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListWorkspacesResponse1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListWorkspacesResponse1 {
            workspaces: intermediate_rep.workspaces.into_iter().next(),
            next_page_token: intermediate_rep.next_page_token.into_iter().next(),
            total_size: intermediate_rep.total_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListWorkspacesResponse1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ListWorkspacesResponse1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListWorkspacesResponse1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListWorkspacesResponse1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ListWorkspacesResponse1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListWorkspacesResponse1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListWorkspacesResponse1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MarketplaceApp {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "developerId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub developer_id: Option<String>,

    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<models::AppCategory>,

    #[serde(rename = "supportedContractTypes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_contract_types: Option<Vec<String>>,

    #[serde(rename = "features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub features: Option<Vec<String>>,

    #[serde(rename = "pricingModel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pricing_model: Option<models::PricingModel>,

    #[serde(rename = "pricingTiers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pricing_tiers: Option<std::collections::HashMap<String, f32>>,

    #[serde(rename = "supportedIntegrations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supported_integrations: Option<Vec<String>>,

    #[serde(rename = "isVerified")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_verified: Option<bool>,

    #[serde(rename = "rating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating: Option<f32>,

    #[serde(rename = "installationCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_count: Option<i32>,

    #[serde(rename = "requiredPermissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_permissions: Option<Vec<String>>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "documentationUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,

    #[serde(rename = "supportEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub support_email: Option<String>,

    #[serde(rename = "screenshots")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub screenshots: Option<Vec<String>>,

    #[serde(rename = "privacyPolicyUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy_policy_url: Option<String>,

    #[serde(rename = "termsUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub terms_url: Option<String>,

    #[serde(rename = "publishedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "versions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub versions: Option<Vec<models::AppVersion>>,

    #[serde(rename = "installations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub installations: Option<Vec<models::AppInstallation>>,

    #[serde(rename = "analytics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub analytics: Option<Vec<models::AppAnalytics>>,

    #[serde(rename = "reviews")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviews: Option<Vec<models::AppReview>>,

    #[serde(rename = "info")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub info: Option<models::AppDevelopmentInfo>,

    #[serde(rename = "webhooks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhooks: Option<Vec<models::AppWebhook>>,

    #[serde(rename = "permissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<Vec<models::AppPermission>>,

}


impl MarketplaceApp {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MarketplaceApp {
        MarketplaceApp {
            id: None,
            name: None,
            description: None,
            developer_id: None,
            category: None,
            supported_contract_types: None,
            features: None,
            pricing_model: None,
            pricing_tiers: None,
            supported_integrations: None,
            is_verified: None,
            rating: None,
            installation_count: None,
            required_permissions: None,
            metadata: None,
            documentation_url: None,
            support_email: None,
            screenshots: None,
            privacy_policy_url: None,
            terms_url: None,
            published_at: None,
            last_updated: None,
            versions: None,
            installations: None,
            analytics: None,
            reviews: None,
            info: None,
            webhooks: None,
            permissions: None,
        }
    }
}

/// Converts the MarketplaceApp value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MarketplaceApp {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.developer_id.as_ref().map(|developer_id| {
                [
                    "developerId".to_string(),
                    developer_id.to_string(),
                ].join(",")
            }),

            // Skipping category in query parameter serialization


            self.supported_contract_types.as_ref().map(|supported_contract_types| {
                [
                    "supportedContractTypes".to_string(),
                    supported_contract_types.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.features.as_ref().map(|features| {
                [
                    "features".to_string(),
                    features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping pricingModel in query parameter serialization

            // Skipping pricingTiers in query parameter serialization


            self.supported_integrations.as_ref().map(|supported_integrations| {
                [
                    "supportedIntegrations".to_string(),
                    supported_integrations.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.is_verified.as_ref().map(|is_verified| {
                [
                    "isVerified".to_string(),
                    is_verified.to_string(),
                ].join(",")
            }),


            self.rating.as_ref().map(|rating| {
                [
                    "rating".to_string(),
                    rating.to_string(),
                ].join(",")
            }),


            self.installation_count.as_ref().map(|installation_count| {
                [
                    "installationCount".to_string(),
                    installation_count.to_string(),
                ].join(",")
            }),


            self.required_permissions.as_ref().map(|required_permissions| {
                [
                    "requiredPermissions".to_string(),
                    required_permissions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.documentation_url.as_ref().map(|documentation_url| {
                [
                    "documentationUrl".to_string(),
                    documentation_url.to_string(),
                ].join(",")
            }),


            self.support_email.as_ref().map(|support_email| {
                [
                    "supportEmail".to_string(),
                    support_email.to_string(),
                ].join(",")
            }),


            self.screenshots.as_ref().map(|screenshots| {
                [
                    "screenshots".to_string(),
                    screenshots.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.privacy_policy_url.as_ref().map(|privacy_policy_url| {
                [
                    "privacyPolicyUrl".to_string(),
                    privacy_policy_url.to_string(),
                ].join(",")
            }),


            self.terms_url.as_ref().map(|terms_url| {
                [
                    "termsUrl".to_string(),
                    terms_url.to_string(),
                ].join(",")
            }),

            // Skipping publishedAt in query parameter serialization

            // Skipping lastUpdated in query parameter serialization

            // Skipping versions in query parameter serialization

            // Skipping installations in query parameter serialization

            // Skipping analytics in query parameter serialization

            // Skipping reviews in query parameter serialization

            // Skipping info in query parameter serialization

            // Skipping webhooks in query parameter serialization

            // Skipping permissions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MarketplaceApp value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MarketplaceApp {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub developer_id: Vec<String>,
            pub category: Vec<models::AppCategory>,
            pub supported_contract_types: Vec<Vec<String>>,
            pub features: Vec<Vec<String>>,
            pub pricing_model: Vec<models::PricingModel>,
            pub pricing_tiers: Vec<std::collections::HashMap<String, f32>>,
            pub supported_integrations: Vec<Vec<String>>,
            pub is_verified: Vec<bool>,
            pub rating: Vec<f32>,
            pub installation_count: Vec<i32>,
            pub required_permissions: Vec<Vec<String>>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub documentation_url: Vec<String>,
            pub support_email: Vec<String>,
            pub screenshots: Vec<Vec<String>>,
            pub privacy_policy_url: Vec<String>,
            pub terms_url: Vec<String>,
            pub published_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
            pub versions: Vec<Vec<models::AppVersion>>,
            pub installations: Vec<Vec<models::AppInstallation>>,
            pub analytics: Vec<Vec<models::AppAnalytics>>,
            pub reviews: Vec<Vec<models::AppReview>>,
            pub info: Vec<models::AppDevelopmentInfo>,
            pub webhooks: Vec<Vec<models::AppWebhook>>,
            pub permissions: Vec<Vec<models::AppPermission>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MarketplaceApp".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "developerId" => intermediate_rep.developer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<models::AppCategory as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supportedContractTypes" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "features" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pricingModel" => intermediate_rep.pricing_model.push(<models::PricingModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pricingTiers" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "supportedIntegrations" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "isVerified" => intermediate_rep.is_verified.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep.rating.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "installationCount" => intermediate_rep.installation_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "requiredPermissions" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "documentationUrl" => intermediate_rep.documentation_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportEmail" => intermediate_rep.support_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "screenshots" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "privacyPolicyUrl" => intermediate_rep.privacy_policy_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "termsUrl" => intermediate_rep.terms_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "publishedAt" => intermediate_rep.published_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "installations" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "analytics" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "reviews" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "info" => intermediate_rep.info.push(<models::AppDevelopmentInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "webhooks" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in MarketplaceApp".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MarketplaceApp".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MarketplaceApp {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            developer_id: intermediate_rep.developer_id.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            supported_contract_types: intermediate_rep.supported_contract_types.into_iter().next(),
            features: intermediate_rep.features.into_iter().next(),
            pricing_model: intermediate_rep.pricing_model.into_iter().next(),
            pricing_tiers: intermediate_rep.pricing_tiers.into_iter().next(),
            supported_integrations: intermediate_rep.supported_integrations.into_iter().next(),
            is_verified: intermediate_rep.is_verified.into_iter().next(),
            rating: intermediate_rep.rating.into_iter().next(),
            installation_count: intermediate_rep.installation_count.into_iter().next(),
            required_permissions: intermediate_rep.required_permissions.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            documentation_url: intermediate_rep.documentation_url.into_iter().next(),
            support_email: intermediate_rep.support_email.into_iter().next(),
            screenshots: intermediate_rep.screenshots.into_iter().next(),
            privacy_policy_url: intermediate_rep.privacy_policy_url.into_iter().next(),
            terms_url: intermediate_rep.terms_url.into_iter().next(),
            published_at: intermediate_rep.published_at.into_iter().next(),
            last_updated: intermediate_rep.last_updated.into_iter().next(),
            versions: intermediate_rep.versions.into_iter().next(),
            installations: intermediate_rep.installations.into_iter().next(),
            analytics: intermediate_rep.analytics.into_iter().next(),
            reviews: intermediate_rep.reviews.into_iter().next(),
            info: intermediate_rep.info.into_iter().next(),
            webhooks: intermediate_rep.webhooks.into_iter().next(),
            permissions: intermediate_rep.permissions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MarketplaceApp> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MarketplaceApp>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MarketplaceApp>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MarketplaceApp - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MarketplaceApp> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MarketplaceApp as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MarketplaceApp - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MergeRequest {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "sourceBranchId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_branch_id: Option<String>,

    #[serde(rename = "targetBranchId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_branch_id: Option<String>,

    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "authorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_id: Option<String>,

    #[serde(rename = "reviewers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,

    #[serde(rename = "hasConflicts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_conflicts: Option<bool>,

    #[serde(rename = "automatedCheckResults")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub automated_check_results: Option<Vec<String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl MergeRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MergeRequest {
        MergeRequest {
            id: None,
            source_branch_id: None,
            target_branch_id: None,
            title: None,
            description: None,
            author_id: None,
            reviewers: None,
            status: None,
            labels: None,
            has_conflicts: None,
            automated_check_results: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the MergeRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MergeRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.source_branch_id.as_ref().map(|source_branch_id| {
                [
                    "sourceBranchId".to_string(),
                    source_branch_id.to_string(),
                ].join(",")
            }),


            self.target_branch_id.as_ref().map(|target_branch_id| {
                [
                    "targetBranchId".to_string(),
                    target_branch_id.to_string(),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.author_id.as_ref().map(|author_id| {
                [
                    "authorId".to_string(),
                    author_id.to_string(),
                ].join(",")
            }),


            self.reviewers.as_ref().map(|reviewers| {
                [
                    "reviewers".to_string(),
                    reviewers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.labels.as_ref().map(|labels| {
                [
                    "labels".to_string(),
                    labels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.has_conflicts.as_ref().map(|has_conflicts| {
                [
                    "hasConflicts".to_string(),
                    has_conflicts.to_string(),
                ].join(",")
            }),


            self.automated_check_results.as_ref().map(|automated_check_results| {
                [
                    "automatedCheckResults".to_string(),
                    automated_check_results.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MergeRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MergeRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub source_branch_id: Vec<String>,
            pub target_branch_id: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub author_id: Vec<String>,
            pub reviewers: Vec<Vec<String>>,
            pub status: Vec<String>,
            pub labels: Vec<Vec<String>>,
            pub has_conflicts: Vec<bool>,
            pub automated_check_results: Vec<Vec<String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MergeRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sourceBranchId" => intermediate_rep.source_branch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetBranchId" => intermediate_rep.target_branch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authorId" => intermediate_rep.author_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "reviewers" => return std::result::Result::Err("Parsing a container in this style is not supported in MergeRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in MergeRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hasConflicts" => intermediate_rep.has_conflicts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "automatedCheckResults" => return std::result::Result::Err("Parsing a container in this style is not supported in MergeRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MergeRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MergeRequest {
            id: intermediate_rep.id.into_iter().next(),
            source_branch_id: intermediate_rep.source_branch_id.into_iter().next(),
            target_branch_id: intermediate_rep.target_branch_id.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            author_id: intermediate_rep.author_id.into_iter().next(),
            reviewers: intermediate_rep.reviewers.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            has_conflicts: intermediate_rep.has_conflicts.into_iter().next(),
            automated_check_results: intermediate_rep.automated_check_results.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MergeRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MergeRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MergeRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MergeRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MergeRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MergeRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MergeRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents errors when HTTP method is not allowed on the endpoint
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MethodNotAllowedErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "allowedMethods")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_methods: Option<Vec<String>>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl MethodNotAllowedErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MethodNotAllowedErrorMessageResponse {
        MethodNotAllowedErrorMessageResponse {
            code: None,
            message: None,
            allowed_methods: None,
            error_response: None,
        }
    }
}

/// Converts the MethodNotAllowedErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MethodNotAllowedErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.allowed_methods.as_ref().map(|allowed_methods| {
                [
                    "allowedMethods".to_string(),
                    allowed_methods.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MethodNotAllowedErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MethodNotAllowedErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub allowed_methods: Vec<Vec<String>>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MethodNotAllowedErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedMethods" => return std::result::Result::Err("Parsing a container in this style is not supported in MethodNotAllowedErrorMessageResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MethodNotAllowedErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MethodNotAllowedErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            allowed_methods: intermediate_rep.allowed_methods.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MethodNotAllowedErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MethodNotAllowedErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MethodNotAllowedErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MethodNotAllowedErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MethodNotAllowedErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MethodNotAllowedErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MethodNotAllowedErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MfaInfo {
    #[serde(rename = "mfaRequired")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mfa_required: Option<bool>,

    #[serde(rename = "allowedMethods")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_methods: Option<Vec<String>>,

    #[serde(rename = "failedReason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_reason: Option<String>,

}


impl MfaInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MfaInfo {
        MfaInfo {
            mfa_required: None,
            allowed_methods: None,
            failed_reason: None,
        }
    }
}

/// Converts the MfaInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MfaInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.mfa_required.as_ref().map(|mfa_required| {
                [
                    "mfaRequired".to_string(),
                    mfa_required.to_string(),
                ].join(",")
            }),


            self.allowed_methods.as_ref().map(|allowed_methods| {
                [
                    "allowedMethods".to_string(),
                    allowed_methods.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.failed_reason.as_ref().map(|failed_reason| {
                [
                    "failedReason".to_string(),
                    failed_reason.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MfaInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MfaInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mfa_required: Vec<bool>,
            pub allowed_methods: Vec<Vec<String>>,
            pub failed_reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MfaInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mfaRequired" => intermediate_rep.mfa_required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedMethods" => return std::result::Result::Err("Parsing a container in this style is not supported in MfaInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "failedReason" => intermediate_rep.failed_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MfaInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MfaInfo {
            mfa_required: intermediate_rep.mfa_required.into_iter().next(),
            allowed_methods: intermediate_rep.allowed_methods.into_iter().next(),
            failed_reason: intermediate_rep.failed_reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MfaInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MfaInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MfaInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MfaInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MfaInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MfaInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MfaInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NegotiationHistory {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "documentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub document_id: Option<String>,

    #[serde(rename = "rounds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rounds: Option<Vec<models::NegotiationRound>>,

    #[serde(rename = "currentStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_status: Option<String>,

    #[serde(rename = "startedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastUpdated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated: Option<chrono::DateTime::<chrono::Utc>>,

}


impl NegotiationHistory {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NegotiationHistory {
        NegotiationHistory {
            id: None,
            document_id: None,
            rounds: None,
            current_status: None,
            started_at: None,
            last_updated: None,
        }
    }
}

/// Converts the NegotiationHistory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NegotiationHistory {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.document_id.as_ref().map(|document_id| {
                [
                    "documentId".to_string(),
                    document_id.to_string(),
                ].join(",")
            }),

            // Skipping rounds in query parameter serialization


            self.current_status.as_ref().map(|current_status| {
                [
                    "currentStatus".to_string(),
                    current_status.to_string(),
                ].join(",")
            }),

            // Skipping startedAt in query parameter serialization

            // Skipping lastUpdated in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NegotiationHistory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NegotiationHistory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub document_id: Vec<String>,
            pub rounds: Vec<Vec<models::NegotiationRound>>,
            pub current_status: Vec<String>,
            pub started_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_updated: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NegotiationHistory".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "documentId" => intermediate_rep.document_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "rounds" => return std::result::Result::Err("Parsing a container in this style is not supported in NegotiationHistory".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currentStatus" => intermediate_rep.current_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startedAt" => intermediate_rep.started_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastUpdated" => intermediate_rep.last_updated.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NegotiationHistory".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NegotiationHistory {
            id: intermediate_rep.id.into_iter().next(),
            document_id: intermediate_rep.document_id.into_iter().next(),
            rounds: intermediate_rep.rounds.into_iter().next(),
            current_status: intermediate_rep.current_status.into_iter().next(),
            started_at: intermediate_rep.started_at.into_iter().next(),
            last_updated: intermediate_rep.last_updated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NegotiationHistory> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NegotiationHistory>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NegotiationHistory>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NegotiationHistory - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NegotiationHistory> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NegotiationHistory as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NegotiationHistory - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NegotiationRound {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "historyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub history_id: Option<String>,

    #[serde(rename = "roundNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub round_number: Option<i32>,

    #[serde(rename = "proposerId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub proposer_id: Option<String>,

    #[serde(rename = "proposalContent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub proposal_content: Option<String>,

    #[serde(rename = "responseContent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_content: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl NegotiationRound {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NegotiationRound {
        NegotiationRound {
            id: None,
            history_id: None,
            round_number: None,
            proposer_id: None,
            proposal_content: None,
            response_content: None,
            status: None,
            created_at: None,
        }
    }
}

/// Converts the NegotiationRound value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NegotiationRound {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.history_id.as_ref().map(|history_id| {
                [
                    "historyId".to_string(),
                    history_id.to_string(),
                ].join(",")
            }),


            self.round_number.as_ref().map(|round_number| {
                [
                    "roundNumber".to_string(),
                    round_number.to_string(),
                ].join(",")
            }),


            self.proposer_id.as_ref().map(|proposer_id| {
                [
                    "proposerId".to_string(),
                    proposer_id.to_string(),
                ].join(",")
            }),


            self.proposal_content.as_ref().map(|proposal_content| {
                [
                    "proposalContent".to_string(),
                    proposal_content.to_string(),
                ].join(",")
            }),


            self.response_content.as_ref().map(|response_content| {
                [
                    "responseContent".to_string(),
                    response_content.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NegotiationRound value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NegotiationRound {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub history_id: Vec<String>,
            pub round_number: Vec<i32>,
            pub proposer_id: Vec<String>,
            pub proposal_content: Vec<String>,
            pub response_content: Vec<String>,
            pub status: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NegotiationRound".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "historyId" => intermediate_rep.history_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "roundNumber" => intermediate_rep.round_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "proposerId" => intermediate_rep.proposer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "proposalContent" => intermediate_rep.proposal_content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "responseContent" => intermediate_rep.response_content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NegotiationRound".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NegotiationRound {
            id: intermediate_rep.id.into_iter().next(),
            history_id: intermediate_rep.history_id.into_iter().next(),
            round_number: intermediate_rep.round_number.into_iter().next(),
            proposer_id: intermediate_rep.proposer_id.into_iter().next(),
            proposal_content: intermediate_rep.proposal_content.into_iter().next(),
            response_content: intermediate_rep.response_content.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NegotiationRound> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NegotiationRound>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NegotiationRound>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NegotiationRound - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NegotiationRound> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NegotiationRound as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NegotiationRound - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// - NO_NOT_FOUND_ERROR: Default value as per proto3 convention  - UNDEFINED_ENDPOINT: Endpoint errors  Requested endpoint doesn't exist  - UNIMPLEMENTED: Endpoint not implemented  - STORE_ID_NOT_FOUND: Resource errors  Requested store ID doesn't exist  - USER_NOT_FOUND: Requested user doesn't exist  - RESOURCE_NOT_FOUND: Generic resource not found  - TENANT_NOT_FOUND: Requested tenant doesn't exist
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NotFoundErrorCode {
    #[serde(rename = "NO_NOT_FOUND_ERROR")]
    NoNotFoundError,
    #[serde(rename = "UNDEFINED_ENDPOINT")]
    UndefinedEndpoint,
    #[serde(rename = "UNIMPLEMENTED")]
    Unimplemented,
    #[serde(rename = "STORE_ID_NOT_FOUND")]
    StoreIdNotFound,
    #[serde(rename = "USER_NOT_FOUND")]
    UserNotFound,
    #[serde(rename = "RESOURCE_NOT_FOUND")]
    ResourceNotFound,
    #[serde(rename = "TENANT_NOT_FOUND")]
    TenantNotFound,
}

impl std::fmt::Display for NotFoundErrorCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NotFoundErrorCode::NoNotFoundError => write!(f, "NO_NOT_FOUND_ERROR"),
            NotFoundErrorCode::UndefinedEndpoint => write!(f, "UNDEFINED_ENDPOINT"),
            NotFoundErrorCode::Unimplemented => write!(f, "UNIMPLEMENTED"),
            NotFoundErrorCode::StoreIdNotFound => write!(f, "STORE_ID_NOT_FOUND"),
            NotFoundErrorCode::UserNotFound => write!(f, "USER_NOT_FOUND"),
            NotFoundErrorCode::ResourceNotFound => write!(f, "RESOURCE_NOT_FOUND"),
            NotFoundErrorCode::TenantNotFound => write!(f, "TENANT_NOT_FOUND"),
        }
    }
}

impl std::str::FromStr for NotFoundErrorCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NO_NOT_FOUND_ERROR" => std::result::Result::Ok(NotFoundErrorCode::NoNotFoundError),
            "UNDEFINED_ENDPOINT" => std::result::Result::Ok(NotFoundErrorCode::UndefinedEndpoint),
            "UNIMPLEMENTED" => std::result::Result::Ok(NotFoundErrorCode::Unimplemented),
            "STORE_ID_NOT_FOUND" => std::result::Result::Ok(NotFoundErrorCode::StoreIdNotFound),
            "USER_NOT_FOUND" => std::result::Result::Ok(NotFoundErrorCode::UserNotFound),
            "RESOURCE_NOT_FOUND" => std::result::Result::Ok(NotFoundErrorCode::ResourceNotFound),
            "TENANT_NOT_FOUND" => std::result::Result::Ok(NotFoundErrorCode::TenantNotFound),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents resource not found errors
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotFoundErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::NotFoundErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "resourceInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_info: Option<models::ResourceInfo>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub suggestions: Option<models::Suggestions>,

    #[serde(rename = "apiInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_info: Option<models::ApiInfo>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl NotFoundErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NotFoundErrorMessageResponse {
        NotFoundErrorMessageResponse {
            code: None,
            message: None,
            resource_info: None,
            suggestions: None,
            api_info: None,
            error_response: None,
        }
    }
}

/// Converts the NotFoundErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotFoundErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping resourceInfo in query parameter serialization

            // Skipping suggestions in query parameter serialization

            // Skipping apiInfo in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotFoundErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotFoundErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::NotFoundErrorCode>,
            pub message: Vec<String>,
            pub resource_info: Vec<models::ResourceInfo>,
            pub suggestions: Vec<models::Suggestions>,
            pub api_info: Vec<models::ApiInfo>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NotFoundErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::NotFoundErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resourceInfo" => intermediate_rep.resource_info.push(<models::ResourceInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "suggestions" => intermediate_rep.suggestions.push(<models::Suggestions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apiInfo" => intermediate_rep.api_info.push(<models::ApiInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NotFoundErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotFoundErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            resource_info: intermediate_rep.resource_info.into_iter().next(),
            suggestions: intermediate_rep.suggestions.into_iter().next(),
            api_info: intermediate_rep.api_info.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NotFoundErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotFoundErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NotFoundErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NotFoundErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NotFoundErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NotFoundErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NotFoundErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents errors when the requested functionality is not implemented
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotImplementedErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "feature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feature: Option<String>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl NotImplementedErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NotImplementedErrorMessageResponse {
        NotImplementedErrorMessageResponse {
            code: None,
            message: None,
            feature: None,
            error_response: None,
        }
    }
}

/// Converts the NotImplementedErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotImplementedErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.feature.as_ref().map(|feature| {
                [
                    "feature".to_string(),
                    feature.to_string(),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotImplementedErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotImplementedErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub feature: Vec<String>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NotImplementedErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feature" => intermediate_rep.feature.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NotImplementedErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotImplementedErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            feature: intermediate_rep.feature.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NotImplementedErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotImplementedErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NotImplementedErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NotImplementedErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NotImplementedErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NotImplementedErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NotImplementedErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NullValue {
    #[serde(rename = "NULL_VALUE")]
    NullValue,
}

impl std::fmt::Display for NullValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NullValue::NullValue => write!(f, "NULL_VALUE"),
        }
    }
}

impl std::str::FromStr for NullValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NULL_VALUE" => std::result::Result::Ok(NullValue::NullValue),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OperationDetails {
    #[serde(rename = "operationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operation_id: Option<String>,

    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "endTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "stackTrace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stack_trace: Option<Vec<String>>,

    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<std::collections::HashMap<String, String>>,

}


impl OperationDetails {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OperationDetails {
        OperationDetails {
            operation_id: None,
            start_time: None,
            end_time: None,
            stack_trace: None,
            parameters: None,
        }
    }
}

/// Converts the OperationDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OperationDetails {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.operation_id.as_ref().map(|operation_id| {
                [
                    "operationId".to_string(),
                    operation_id.to_string(),
                ].join(",")
            }),

            // Skipping startTime in query parameter serialization

            // Skipping endTime in query parameter serialization


            self.stack_trace.as_ref().map(|stack_trace| {
                [
                    "stackTrace".to_string(),
                    stack_trace.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping parameters in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OperationDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OperationDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub operation_id: Vec<String>,
            pub start_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub end_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub stack_trace: Vec<Vec<String>>,
            pub parameters: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OperationDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "operationId" => intermediate_rep.operation_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startTime" => intermediate_rep.start_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endTime" => intermediate_rep.end_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "stackTrace" => return std::result::Result::Err("Parsing a container in this style is not supported in OperationDetails".to_string()),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in OperationDetails".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OperationDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OperationDetails {
            operation_id: intermediate_rep.operation_id.into_iter().next(),
            start_time: intermediate_rep.start_time.into_iter().next(),
            end_time: intermediate_rep.end_time.into_iter().next(),
            stack_trace: intermediate_rep.stack_trace.into_iter().next(),
            parameters: intermediate_rep.parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OperationDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OperationDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OperationDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OperationDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OperationDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OperationDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OperationDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Key features: - Multi-tenant support - Hierarchical structure - Enterprise features - Billing management  Use cases: - Company creates multiple apps/tenants - Enterprise manages business units - Usage tracking across tenants
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Organization {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "displayName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,

    #[serde(rename = "website")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "billingEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_email: Option<String>,

    #[serde(rename = "technicalEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub technical_email: Option<String>,

    #[serde(rename = "phone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub phone: Option<String>,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<String>,

    #[serde(rename = "ssoEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sso_enabled: Option<bool>,

    #[serde(rename = "ssoProvider")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sso_provider: Option<String>,

    #[serde(rename = "ssoDomain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sso_domain: Option<String>,

    #[serde(rename = "allowedDomains")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_domains: Option<Vec<String>>,

    #[serde(rename = "enforce2fa")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce2fa: Option<bool>,

    #[serde(rename = "billingPlan")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_plan: Option<models::BillingPlan>,

    #[serde(rename = "billingCurrency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_currency: Option<String>,

    #[serde(rename = "autoBilling")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_billing: Option<bool>,

    #[serde(rename = "taxId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax_id: Option<String>,

    /// SOC2, GDPR, etc
    #[serde(rename = "complianceFrameworks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_frameworks: Option<Vec<String>>,

    #[serde(rename = "dataProcessingAgreement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_processing_agreement: Option<bool>,

    #[serde(rename = "dataRegion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_region: Option<String>,

    #[serde(rename = "maxTenants")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tenants: Option<i32>,

    #[serde(rename = "totalStorageLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_storage_limit: Option<String>,

    #[serde(rename = "maxApiKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_api_keys: Option<i32>,

    #[serde(rename = "maxUsers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_users: Option<i32>,

    #[serde(rename = "tenants")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenants: Option<Vec<models::Tenant>>,

    #[serde(rename = "subscriptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions: Option<models::Subscription>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdBy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_by: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::V1PeriodStatus>,

}


impl Organization {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Organization {
        Organization {
            id: None,
            name: None,
            display_name: None,
            website: None,
            description: None,
            billing_email: None,
            technical_email: None,
            phone: None,
            address: None,
            sso_enabled: None,
            sso_provider: None,
            sso_domain: None,
            allowed_domains: None,
            enforce2fa: None,
            billing_plan: None,
            billing_currency: None,
            auto_billing: None,
            tax_id: None,
            compliance_frameworks: None,
            data_processing_agreement: None,
            data_region: None,
            max_tenants: None,
            total_storage_limit: None,
            max_api_keys: None,
            max_users: None,
            tenants: None,
            subscriptions: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            created_by: None,
            status: None,
        }
    }
}

/// Converts the Organization value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Organization {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.display_name.as_ref().map(|display_name| {
                [
                    "displayName".to_string(),
                    display_name.to_string(),
                ].join(",")
            }),


            self.website.as_ref().map(|website| {
                [
                    "website".to_string(),
                    website.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.billing_email.as_ref().map(|billing_email| {
                [
                    "billingEmail".to_string(),
                    billing_email.to_string(),
                ].join(",")
            }),


            self.technical_email.as_ref().map(|technical_email| {
                [
                    "technicalEmail".to_string(),
                    technical_email.to_string(),
                ].join(",")
            }),


            self.phone.as_ref().map(|phone| {
                [
                    "phone".to_string(),
                    phone.to_string(),
                ].join(",")
            }),


            self.address.as_ref().map(|address| {
                [
                    "address".to_string(),
                    address.to_string(),
                ].join(",")
            }),


            self.sso_enabled.as_ref().map(|sso_enabled| {
                [
                    "ssoEnabled".to_string(),
                    sso_enabled.to_string(),
                ].join(",")
            }),


            self.sso_provider.as_ref().map(|sso_provider| {
                [
                    "ssoProvider".to_string(),
                    sso_provider.to_string(),
                ].join(",")
            }),


            self.sso_domain.as_ref().map(|sso_domain| {
                [
                    "ssoDomain".to_string(),
                    sso_domain.to_string(),
                ].join(",")
            }),


            self.allowed_domains.as_ref().map(|allowed_domains| {
                [
                    "allowedDomains".to_string(),
                    allowed_domains.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.enforce2fa.as_ref().map(|enforce2fa| {
                [
                    "enforce2fa".to_string(),
                    enforce2fa.to_string(),
                ].join(",")
            }),

            // Skipping billingPlan in query parameter serialization


            self.billing_currency.as_ref().map(|billing_currency| {
                [
                    "billingCurrency".to_string(),
                    billing_currency.to_string(),
                ].join(",")
            }),


            self.auto_billing.as_ref().map(|auto_billing| {
                [
                    "autoBilling".to_string(),
                    auto_billing.to_string(),
                ].join(",")
            }),


            self.tax_id.as_ref().map(|tax_id| {
                [
                    "taxId".to_string(),
                    tax_id.to_string(),
                ].join(",")
            }),


            self.compliance_frameworks.as_ref().map(|compliance_frameworks| {
                [
                    "complianceFrameworks".to_string(),
                    compliance_frameworks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.data_processing_agreement.as_ref().map(|data_processing_agreement| {
                [
                    "dataProcessingAgreement".to_string(),
                    data_processing_agreement.to_string(),
                ].join(",")
            }),


            self.data_region.as_ref().map(|data_region| {
                [
                    "dataRegion".to_string(),
                    data_region.to_string(),
                ].join(",")
            }),


            self.max_tenants.as_ref().map(|max_tenants| {
                [
                    "maxTenants".to_string(),
                    max_tenants.to_string(),
                ].join(",")
            }),


            self.total_storage_limit.as_ref().map(|total_storage_limit| {
                [
                    "totalStorageLimit".to_string(),
                    total_storage_limit.to_string(),
                ].join(",")
            }),


            self.max_api_keys.as_ref().map(|max_api_keys| {
                [
                    "maxApiKeys".to_string(),
                    max_api_keys.to_string(),
                ].join(",")
            }),


            self.max_users.as_ref().map(|max_users| {
                [
                    "maxUsers".to_string(),
                    max_users.to_string(),
                ].join(",")
            }),

            // Skipping tenants in query parameter serialization

            // Skipping subscriptions in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization


            self.created_by.as_ref().map(|created_by| {
                [
                    "createdBy".to_string(),
                    created_by.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Organization value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Organization {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub display_name: Vec<String>,
            pub website: Vec<String>,
            pub description: Vec<String>,
            pub billing_email: Vec<String>,
            pub technical_email: Vec<String>,
            pub phone: Vec<String>,
            pub address: Vec<String>,
            pub sso_enabled: Vec<bool>,
            pub sso_provider: Vec<String>,
            pub sso_domain: Vec<String>,
            pub allowed_domains: Vec<Vec<String>>,
            pub enforce2fa: Vec<bool>,
            pub billing_plan: Vec<models::BillingPlan>,
            pub billing_currency: Vec<String>,
            pub auto_billing: Vec<bool>,
            pub tax_id: Vec<String>,
            pub compliance_frameworks: Vec<Vec<String>>,
            pub data_processing_agreement: Vec<bool>,
            pub data_region: Vec<String>,
            pub max_tenants: Vec<i32>,
            pub total_storage_limit: Vec<String>,
            pub max_api_keys: Vec<i32>,
            pub max_users: Vec<i32>,
            pub tenants: Vec<Vec<models::Tenant>>,
            pub subscriptions: Vec<models::Subscription>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_by: Vec<String>,
            pub status: Vec<models::V1PeriodStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Organization".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "displayName" => intermediate_rep.display_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "website" => intermediate_rep.website.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billingEmail" => intermediate_rep.billing_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "technicalEmail" => intermediate_rep.technical_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "phone" => intermediate_rep.phone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ssoEnabled" => intermediate_rep.sso_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ssoProvider" => intermediate_rep.sso_provider.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ssoDomain" => intermediate_rep.sso_domain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedDomains" => return std::result::Result::Err("Parsing a container in this style is not supported in Organization".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "enforce2fa" => intermediate_rep.enforce2fa.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billingPlan" => intermediate_rep.billing_plan.push(<models::BillingPlan as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billingCurrency" => intermediate_rep.billing_currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "autoBilling" => intermediate_rep.auto_billing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "taxId" => intermediate_rep.tax_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "complianceFrameworks" => return std::result::Result::Err("Parsing a container in this style is not supported in Organization".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "dataProcessingAgreement" => intermediate_rep.data_processing_agreement.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataRegion" => intermediate_rep.data_region.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxTenants" => intermediate_rep.max_tenants.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalStorageLimit" => intermediate_rep.total_storage_limit.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxApiKeys" => intermediate_rep.max_api_keys.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxUsers" => intermediate_rep.max_users.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tenants" => return std::result::Result::Err("Parsing a container in this style is not supported in Organization".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "subscriptions" => intermediate_rep.subscriptions.push(<models::Subscription as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdBy" => intermediate_rep.created_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::V1PeriodStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Organization".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Organization {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            display_name: intermediate_rep.display_name.into_iter().next(),
            website: intermediate_rep.website.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            billing_email: intermediate_rep.billing_email.into_iter().next(),
            technical_email: intermediate_rep.technical_email.into_iter().next(),
            phone: intermediate_rep.phone.into_iter().next(),
            address: intermediate_rep.address.into_iter().next(),
            sso_enabled: intermediate_rep.sso_enabled.into_iter().next(),
            sso_provider: intermediate_rep.sso_provider.into_iter().next(),
            sso_domain: intermediate_rep.sso_domain.into_iter().next(),
            allowed_domains: intermediate_rep.allowed_domains.into_iter().next(),
            enforce2fa: intermediate_rep.enforce2fa.into_iter().next(),
            billing_plan: intermediate_rep.billing_plan.into_iter().next(),
            billing_currency: intermediate_rep.billing_currency.into_iter().next(),
            auto_billing: intermediate_rep.auto_billing.into_iter().next(),
            tax_id: intermediate_rep.tax_id.into_iter().next(),
            compliance_frameworks: intermediate_rep.compliance_frameworks.into_iter().next(),
            data_processing_agreement: intermediate_rep.data_processing_agreement.into_iter().next(),
            data_region: intermediate_rep.data_region.into_iter().next(),
            max_tenants: intermediate_rep.max_tenants.into_iter().next(),
            total_storage_limit: intermediate_rep.total_storage_limit.into_iter().next(),
            max_api_keys: intermediate_rep.max_api_keys.into_iter().next(),
            max_users: intermediate_rep.max_users.into_iter().next(),
            tenants: intermediate_rep.tenants.into_iter().next(),
            subscriptions: intermediate_rep.subscriptions.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            created_by: intermediate_rep.created_by.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Organization> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Organization>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Organization>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Organization - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Organization> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Organization as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Organization - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OutputFormat {
    #[serde(rename = "OUTPUT_FORMAT_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "OUTPUT_FORMAT_JSON")]
    Json,
    #[serde(rename = "OUTPUT_FORMAT_CSV")]
    Csv,
    #[serde(rename = "OUTPUT_FORMAT_BIGQUERY")]
    Bigquery,
    #[serde(rename = "OUTPUT_FORMAT_POSTGRES")]
    Postgres,
}

impl std::fmt::Display for OutputFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OutputFormat::Unspecified => write!(f, "OUTPUT_FORMAT_UNSPECIFIED"),
            OutputFormat::Json => write!(f, "OUTPUT_FORMAT_JSON"),
            OutputFormat::Csv => write!(f, "OUTPUT_FORMAT_CSV"),
            OutputFormat::Bigquery => write!(f, "OUTPUT_FORMAT_BIGQUERY"),
            OutputFormat::Postgres => write!(f, "OUTPUT_FORMAT_POSTGRES"),
        }
    }
}

impl std::str::FromStr for OutputFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OUTPUT_FORMAT_UNSPECIFIED" => std::result::Result::Ok(OutputFormat::Unspecified),
            "OUTPUT_FORMAT_JSON" => std::result::Result::Ok(OutputFormat::Json),
            "OUTPUT_FORMAT_CSV" => std::result::Result::Ok(OutputFormat::Csv),
            "OUTPUT_FORMAT_BIGQUERY" => std::result::Result::Ok(OutputFormat::Bigquery),
            "OUTPUT_FORMAT_POSTGRES" => std::result::Result::Ok(OutputFormat::Postgres),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PauseWorkflowBody {
    #[serde(rename = "pause")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pause: Option<bool>,

}


impl PauseWorkflowBody {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PauseWorkflowBody {
        PauseWorkflowBody {
            pause: None,
        }
    }
}

/// Converts the PauseWorkflowBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PauseWorkflowBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.pause.as_ref().map(|pause| {
                [
                    "pause".to_string(),
                    pause.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PauseWorkflowBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PauseWorkflowBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pause: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PauseWorkflowBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pause" => intermediate_rep.pause.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PauseWorkflowBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PauseWorkflowBody {
            pause: intermediate_rep.pause.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PauseWorkflowBody> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PauseWorkflowBody>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PauseWorkflowBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PauseWorkflowBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PauseWorkflowBody> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PauseWorkflowBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PauseWorkflowBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PauseWorkflowResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::ScrapingWorkflow>,

}


impl PauseWorkflowResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PauseWorkflowResponse {
        PauseWorkflowResponse {
            success: None,
            workflow: None,
        }
    }
}

/// Converts the PauseWorkflowResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PauseWorkflowResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PauseWorkflowResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PauseWorkflowResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
            pub workflow: Vec<models::ScrapingWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PauseWorkflowResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::ScrapingWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PauseWorkflowResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PauseWorkflowResponse {
            success: intermediate_rep.success.into_iter().next(),
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PauseWorkflowResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PauseWorkflowResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PauseWorkflowResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PauseWorkflowResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PauseWorkflowResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PauseWorkflowResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PauseWorkflowResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PayloadFormat {
    #[serde(rename = "PAYLOAD_FORMAT_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PAYLOAD_FORMAT_JSON")]
    Json,
    #[serde(rename = "PAYLOAD_FORMAT_XML")]
    Xml,
    #[serde(rename = "PAYLOAD_FORMAT_FORM_DATA")]
    FormData,
    #[serde(rename = "PAYLOAD_FORMAT_PROTOBUF")]
    Protobuf,
    #[serde(rename = "PAYLOAD_FORMAT_YAML")]
    Yaml,
}

impl std::fmt::Display for PayloadFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PayloadFormat::Unspecified => write!(f, "PAYLOAD_FORMAT_UNSPECIFIED"),
            PayloadFormat::Json => write!(f, "PAYLOAD_FORMAT_JSON"),
            PayloadFormat::Xml => write!(f, "PAYLOAD_FORMAT_XML"),
            PayloadFormat::FormData => write!(f, "PAYLOAD_FORMAT_FORM_DATA"),
            PayloadFormat::Protobuf => write!(f, "PAYLOAD_FORMAT_PROTOBUF"),
            PayloadFormat::Yaml => write!(f, "PAYLOAD_FORMAT_YAML"),
        }
    }
}

impl std::str::FromStr for PayloadFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PAYLOAD_FORMAT_UNSPECIFIED" => std::result::Result::Ok(PayloadFormat::Unspecified),
            "PAYLOAD_FORMAT_JSON" => std::result::Result::Ok(PayloadFormat::Json),
            "PAYLOAD_FORMAT_XML" => std::result::Result::Ok(PayloadFormat::Xml),
            "PAYLOAD_FORMAT_FORM_DATA" => std::result::Result::Ok(PayloadFormat::FormData),
            "PAYLOAD_FORMAT_PROTOBUF" => std::result::Result::Ok(PayloadFormat::Protobuf),
            "PAYLOAD_FORMAT_YAML" => std::result::Result::Ok(PayloadFormat::Yaml),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaymentInfo {
    #[serde(rename = "amountDue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub amount_due: Option<f64>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<String>,

    #[serde(rename = "dueDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_date: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "paymentUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_url: Option<String>,

}


impl PaymentInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PaymentInfo {
        PaymentInfo {
            amount_due: None,
            currency: None,
            due_date: None,
            payment_url: None,
        }
    }
}

/// Converts the PaymentInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PaymentInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.amount_due.as_ref().map(|amount_due| {
                [
                    "amountDue".to_string(),
                    amount_due.to_string(),
                ].join(",")
            }),


            self.currency.as_ref().map(|currency| {
                [
                    "currency".to_string(),
                    currency.to_string(),
                ].join(",")
            }),

            // Skipping dueDate in query parameter serialization


            self.payment_url.as_ref().map(|payment_url| {
                [
                    "paymentUrl".to_string(),
                    payment_url.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaymentInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaymentInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub amount_due: Vec<f64>,
            pub currency: Vec<String>,
            pub due_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub payment_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaymentInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "amountDue" => intermediate_rep.amount_due.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dueDate" => intermediate_rep.due_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentUrl" => intermediate_rep.payment_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaymentInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaymentInfo {
            amount_due: intermediate_rep.amount_due.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            due_date: intermediate_rep.due_date.into_iter().next(),
            payment_url: intermediate_rep.payment_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaymentInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PaymentInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaymentInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PaymentInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PaymentInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaymentInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PaymentInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Indicates that payment is required to proceed
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaymentRequiredErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "paymentInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_info: Option<models::PaymentInfo>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl PaymentRequiredErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PaymentRequiredErrorMessageResponse {
        PaymentRequiredErrorMessageResponse {
            code: None,
            message: None,
            payment_info: None,
            error_response: None,
        }
    }
}

/// Converts the PaymentRequiredErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PaymentRequiredErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping paymentInfo in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaymentRequiredErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaymentRequiredErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub payment_info: Vec<models::PaymentInfo>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaymentRequiredErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentInfo" => intermediate_rep.payment_info.push(<models::PaymentInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaymentRequiredErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaymentRequiredErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            payment_info: intermediate_rep.payment_info.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaymentRequiredErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PaymentRequiredErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaymentRequiredErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PaymentRequiredErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PaymentRequiredErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaymentRequiredErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PaymentRequiredErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PaymentStatus {
    #[serde(rename = "PAYMENT_STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PAYMENT_STATUS_PAID")]
    Paid,
    #[serde(rename = "PAYMENT_STATUS_PAST_DUE")]
    PastDue,
    #[serde(rename = "PAYMENT_STATUS_FAILED")]
    Failed,
    #[serde(rename = "PAYMENT_STATUS_CANCELED")]
    Canceled,
}

impl std::fmt::Display for PaymentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PaymentStatus::Unspecified => write!(f, "PAYMENT_STATUS_UNSPECIFIED"),
            PaymentStatus::Paid => write!(f, "PAYMENT_STATUS_PAID"),
            PaymentStatus::PastDue => write!(f, "PAYMENT_STATUS_PAST_DUE"),
            PaymentStatus::Failed => write!(f, "PAYMENT_STATUS_FAILED"),
            PaymentStatus::Canceled => write!(f, "PAYMENT_STATUS_CANCELED"),
        }
    }
}

impl std::str::FromStr for PaymentStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PAYMENT_STATUS_UNSPECIFIED" => std::result::Result::Ok(PaymentStatus::Unspecified),
            "PAYMENT_STATUS_PAID" => std::result::Result::Ok(PaymentStatus::Paid),
            "PAYMENT_STATUS_PAST_DUE" => std::result::Result::Ok(PaymentStatus::PastDue),
            "PAYMENT_STATUS_FAILED" => std::result::Result::Ok(PaymentStatus::Failed),
            "PAYMENT_STATUS_CANCELED" => std::result::Result::Ok(PaymentStatus::Canceled),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Permission {
    #[serde(rename = "PERMISSION_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PERMISSION_READ")]
    Read,
    #[serde(rename = "PERMISSION_WRITE")]
    Write,
    #[serde(rename = "PERMISSION_DELETE")]
    Delete,
    #[serde(rename = "PERMISSION_MANAGE_USERS")]
    ManageUsers,
    #[serde(rename = "PERMISSION_MANAGE_BILLING")]
    ManageBilling,
    #[serde(rename = "PERMISSION_VIEW_ANALYTICS")]
    ViewAnalytics,
    #[serde(rename = "PERMISSION_MANAGE_WORKFLOWS")]
    ManageWorkflows,
}

impl std::fmt::Display for Permission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Permission::Unspecified => write!(f, "PERMISSION_UNSPECIFIED"),
            Permission::Read => write!(f, "PERMISSION_READ"),
            Permission::Write => write!(f, "PERMISSION_WRITE"),
            Permission::Delete => write!(f, "PERMISSION_DELETE"),
            Permission::ManageUsers => write!(f, "PERMISSION_MANAGE_USERS"),
            Permission::ManageBilling => write!(f, "PERMISSION_MANAGE_BILLING"),
            Permission::ViewAnalytics => write!(f, "PERMISSION_VIEW_ANALYTICS"),
            Permission::ManageWorkflows => write!(f, "PERMISSION_MANAGE_WORKFLOWS"),
        }
    }
}

impl std::str::FromStr for Permission {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PERMISSION_UNSPECIFIED" => std::result::Result::Ok(Permission::Unspecified),
            "PERMISSION_READ" => std::result::Result::Ok(Permission::Read),
            "PERMISSION_WRITE" => std::result::Result::Ok(Permission::Write),
            "PERMISSION_DELETE" => std::result::Result::Ok(Permission::Delete),
            "PERMISSION_MANAGE_USERS" => std::result::Result::Ok(Permission::ManageUsers),
            "PERMISSION_MANAGE_BILLING" => std::result::Result::Ok(Permission::ManageBilling),
            "PERMISSION_VIEW_ANALYTICS" => std::result::Result::Ok(Permission::ViewAnalytics),
            "PERMISSION_MANAGE_WORKFLOWS" => std::result::Result::Ok(Permission::ManageWorkflows),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PlanTier {
    #[serde(rename = "PLAN_TIER_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PLAN_TIER_FREE")]
    Free,
    #[serde(rename = "PLAN_TIER_STARTER")]
    Starter,
    #[serde(rename = "PLAN_TIER_PROFESSIONAL")]
    Professional,
    #[serde(rename = "PLAN_TIER_ENTERPRISE")]
    Enterprise,
}

impl std::fmt::Display for PlanTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PlanTier::Unspecified => write!(f, "PLAN_TIER_UNSPECIFIED"),
            PlanTier::Free => write!(f, "PLAN_TIER_FREE"),
            PlanTier::Starter => write!(f, "PLAN_TIER_STARTER"),
            PlanTier::Professional => write!(f, "PLAN_TIER_PROFESSIONAL"),
            PlanTier::Enterprise => write!(f, "PLAN_TIER_ENTERPRISE"),
        }
    }
}

impl std::str::FromStr for PlanTier {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PLAN_TIER_UNSPECIFIED" => std::result::Result::Ok(PlanTier::Unspecified),
            "PLAN_TIER_FREE" => std::result::Result::Ok(PlanTier::Free),
            "PLAN_TIER_STARTER" => std::result::Result::Ok(PlanTier::Starter),
            "PLAN_TIER_PROFESSIONAL" => std::result::Result::Ok(PlanTier::Professional),
            "PLAN_TIER_ENTERPRISE" => std::result::Result::Ok(PlanTier::Enterprise),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents errors when a precondition provided in the request fails
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreconditionFailedErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "failedConditions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_conditions: Option<Vec<String>>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl PreconditionFailedErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PreconditionFailedErrorMessageResponse {
        PreconditionFailedErrorMessageResponse {
            code: None,
            message: None,
            failed_conditions: None,
            error_response: None,
        }
    }
}

/// Converts the PreconditionFailedErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreconditionFailedErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.failed_conditions.as_ref().map(|failed_conditions| {
                [
                    "failedConditions".to_string(),
                    failed_conditions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreconditionFailedErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreconditionFailedErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub failed_conditions: Vec<Vec<String>>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PreconditionFailedErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "failedConditions" => return std::result::Result::Err("Parsing a container in this style is not supported in PreconditionFailedErrorMessageResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PreconditionFailedErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PreconditionFailedErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            failed_conditions: intermediate_rep.failed_conditions.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PreconditionFailedErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PreconditionFailedErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PreconditionFailedErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PreconditionFailedErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PreconditionFailedErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PreconditionFailedErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PreconditionFailedErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PricingModel {
    #[serde(rename = "PRICING_MODEL_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PRICING_MODEL_FREE")]
    Free,
    #[serde(rename = "PRICING_MODEL_SUBSCRIPTION")]
    Subscription,
    #[serde(rename = "PRICING_MODEL_USAGE_BASED")]
    UsageBased,
    #[serde(rename = "PRICING_MODEL_ENTERPRISE")]
    Enterprise,
}

impl std::fmt::Display for PricingModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PricingModel::Unspecified => write!(f, "PRICING_MODEL_UNSPECIFIED"),
            PricingModel::Free => write!(f, "PRICING_MODEL_FREE"),
            PricingModel::Subscription => write!(f, "PRICING_MODEL_SUBSCRIPTION"),
            PricingModel::UsageBased => write!(f, "PRICING_MODEL_USAGE_BASED"),
            PricingModel::Enterprise => write!(f, "PRICING_MODEL_ENTERPRISE"),
        }
    }
}

impl std::str::FromStr for PricingModel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PRICING_MODEL_UNSPECIFIED" => std::result::Result::Ok(PricingModel::Unspecified),
            "PRICING_MODEL_FREE" => std::result::Result::Ok(PricingModel::Free),
            "PRICING_MODEL_SUBSCRIPTION" => std::result::Result::Ok(PricingModel::Subscription),
            "PRICING_MODEL_USAGE_BASED" => std::result::Result::Ok(PricingModel::UsageBased),
            "PRICING_MODEL_ENTERPRISE" => std::result::Result::Ok(PricingModel::Enterprise),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuotaInfo {
    #[serde(rename = "resource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource: Option<String>,

    #[serde(rename = "used")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub used: Option<String>,

    #[serde(rename = "limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<String>,

    #[serde(rename = "resetTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reset_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "resourceUsage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_usage: Option<std::collections::HashMap<String, String>>,

}


impl QuotaInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QuotaInfo {
        QuotaInfo {
            resource: None,
            used: None,
            limit: None,
            reset_time: None,
            resource_usage: None,
        }
    }
}

/// Converts the QuotaInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QuotaInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.resource.as_ref().map(|resource| {
                [
                    "resource".to_string(),
                    resource.to_string(),
                ].join(",")
            }),


            self.used.as_ref().map(|used| {
                [
                    "used".to_string(),
                    used.to_string(),
                ].join(",")
            }),


            self.limit.as_ref().map(|limit| {
                [
                    "limit".to_string(),
                    limit.to_string(),
                ].join(",")
            }),

            // Skipping resetTime in query parameter serialization

            // Skipping resourceUsage in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuotaInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuotaInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resource: Vec<String>,
            pub used: Vec<String>,
            pub limit: Vec<String>,
            pub reset_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub resource_usage: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuotaInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "resource" => intermediate_rep.resource.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "used" => intermediate_rep.used.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "limit" => intermediate_rep.limit.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resetTime" => intermediate_rep.reset_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "resourceUsage" => return std::result::Result::Err("Parsing a container in this style is not supported in QuotaInfo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuotaInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuotaInfo {
            resource: intermediate_rep.resource.into_iter().next(),
            used: intermediate_rep.used.into_iter().next(),
            limit: intermediate_rep.limit.into_iter().next(),
            reset_time: intermediate_rep.reset_time.into_iter().next(),
            resource_usage: intermediate_rep.resource_usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuotaInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QuotaInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuotaInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuotaInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QuotaInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuotaInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuotaInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RateLimitContext {
    #[serde(rename = "userId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<String>,

    #[serde(rename = "ipAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

    #[serde(rename = "affectedEndpoints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_endpoints: Option<Vec<String>>,

    #[serde(rename = "headers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub headers: Option<std::collections::HashMap<String, String>>,

}


impl RateLimitContext {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RateLimitContext {
        RateLimitContext {
            user_id: None,
            ip_address: None,
            affected_endpoints: None,
            headers: None,
        }
    }
}

/// Converts the RateLimitContext value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RateLimitContext {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.user_id.as_ref().map(|user_id| {
                [
                    "userId".to_string(),
                    user_id.to_string(),
                ].join(",")
            }),


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "ipAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),


            self.affected_endpoints.as_ref().map(|affected_endpoints| {
                [
                    "affectedEndpoints".to_string(),
                    affected_endpoints.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping headers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RateLimitContext value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RateLimitContext {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_id: Vec<String>,
            pub ip_address: Vec<String>,
            pub affected_endpoints: Vec<Vec<String>>,
            pub headers: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RateLimitContext".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "affectedEndpoints" => return std::result::Result::Err("Parsing a container in this style is not supported in RateLimitContext".to_string()),
                    "headers" => return std::result::Result::Err("Parsing a container in this style is not supported in RateLimitContext".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RateLimitContext".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RateLimitContext {
            user_id: intermediate_rep.user_id.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
            affected_endpoints: intermediate_rep.affected_endpoints.into_iter().next(),
            headers: intermediate_rep.headers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RateLimitContext> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RateLimitContext>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RateLimitContext>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RateLimitContext - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RateLimitContext> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RateLimitContext as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RateLimitContext - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents rate limiting and quota exceeded errors
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RateLimitErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::InternalErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "limitInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit_info: Option<models::LimitInfo>,

    #[serde(rename = "quotaInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quota_info: Option<models::QuotaInfo>,

    #[serde(rename = "context")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<models::RateLimitContext>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl RateLimitErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RateLimitErrorMessageResponse {
        RateLimitErrorMessageResponse {
            code: None,
            message: None,
            limit_info: None,
            quota_info: None,
            context: None,
            error_response: None,
        }
    }
}

/// Converts the RateLimitErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RateLimitErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping limitInfo in query parameter serialization

            // Skipping quotaInfo in query parameter serialization

            // Skipping context in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RateLimitErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RateLimitErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::InternalErrorCode>,
            pub message: Vec<String>,
            pub limit_info: Vec<models::LimitInfo>,
            pub quota_info: Vec<models::QuotaInfo>,
            pub context: Vec<models::RateLimitContext>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RateLimitErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::InternalErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "limitInfo" => intermediate_rep.limit_info.push(<models::LimitInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quotaInfo" => intermediate_rep.quota_info.push(<models::QuotaInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "context" => intermediate_rep.context.push(<models::RateLimitContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RateLimitErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RateLimitErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            limit_info: intermediate_rep.limit_info.into_iter().next(),
            quota_info: intermediate_rep.quota_info.into_iter().next(),
            context: intermediate_rep.context.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RateLimitErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RateLimitErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RateLimitErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RateLimitErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RateLimitErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RateLimitErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RateLimitErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RemoveWorkspaceSharingResponse {
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

}


impl RemoveWorkspaceSharingResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RemoveWorkspaceSharingResponse {
        RemoveWorkspaceSharingResponse {
            success: None,
        }
    }
}

/// Converts the RemoveWorkspaceSharingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RemoveWorkspaceSharingResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RemoveWorkspaceSharingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RemoveWorkspaceSharingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RemoveWorkspaceSharingResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RemoveWorkspaceSharingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RemoveWorkspaceSharingResponse {
            success: intermediate_rep.success.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RemoveWorkspaceSharingResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RemoveWorkspaceSharingResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RemoveWorkspaceSharingResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RemoveWorkspaceSharingResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RemoveWorkspaceSharingResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RemoveWorkspaceSharingResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RemoveWorkspaceSharingResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceInfo {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<String>>,

}


impl ResourceInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ResourceInfo {
        ResourceInfo {
            r#type: None,
            id: None,
            path: None,
            tenant_id: None,
            scopes: None,
        }
    }
}

/// Converts the ResourceInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub id: Vec<String>,
            pub path: Vec<String>,
            pub tenant_id: Vec<String>,
            pub scopes: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourceInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "scopes" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceInfo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourceInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceInfo {
            r#type: intermediate_rep.r#type.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourceInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourceInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ResourceInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourceInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourceInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceUtilization {
    #[serde(rename = "cpuUsage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_usage: Option<f64>,

    #[serde(rename = "memoryUsage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_usage: Option<f64>,

    #[serde(rename = "activeConnections")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_connections: Option<i32>,

    #[serde(rename = "quotas")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quotas: Option<std::collections::HashMap<String, f64>>,

}


impl ResourceUtilization {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ResourceUtilization {
        ResourceUtilization {
            cpu_usage: None,
            memory_usage: None,
            active_connections: None,
            quotas: None,
        }
    }
}

/// Converts the ResourceUtilization value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceUtilization {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.cpu_usage.as_ref().map(|cpu_usage| {
                [
                    "cpuUsage".to_string(),
                    cpu_usage.to_string(),
                ].join(",")
            }),


            self.memory_usage.as_ref().map(|memory_usage| {
                [
                    "memoryUsage".to_string(),
                    memory_usage.to_string(),
                ].join(",")
            }),


            self.active_connections.as_ref().map(|active_connections| {
                [
                    "activeConnections".to_string(),
                    active_connections.to_string(),
                ].join(",")
            }),

            // Skipping quotas in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceUtilization value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceUtilization {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cpu_usage: Vec<f64>,
            pub memory_usage: Vec<f64>,
            pub active_connections: Vec<i32>,
            pub quotas: Vec<std::collections::HashMap<String, f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourceUtilization".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cpuUsage" => intermediate_rep.cpu_usage.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "memoryUsage" => intermediate_rep.memory_usage.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "activeConnections" => intermediate_rep.active_connections.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "quotas" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceUtilization".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourceUtilization".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceUtilization {
            cpu_usage: intermediate_rep.cpu_usage.into_iter().next(),
            memory_usage: intermediate_rep.memory_usage.into_iter().next(),
            active_connections: intermediate_rep.active_connections.into_iter().next(),
            quotas: intermediate_rep.quotas.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceUtilization> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceUtilization>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourceUtilization>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourceUtilization - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ResourceUtilization> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourceUtilization as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourceUtilization - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceValidation {
    #[serde(rename = "missingResources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub missing_resources: Option<Vec<String>>,

    #[serde(rename = "invalidReferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invalid_references: Option<Vec<String>>,

    #[serde(rename = "idViolations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id_violations: Option<std::collections::HashMap<String, String>>,

}


impl ResourceValidation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ResourceValidation {
        ResourceValidation {
            missing_resources: None,
            invalid_references: None,
            id_violations: None,
        }
    }
}

/// Converts the ResourceValidation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceValidation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.missing_resources.as_ref().map(|missing_resources| {
                [
                    "missingResources".to_string(),
                    missing_resources.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.invalid_references.as_ref().map(|invalid_references| {
                [
                    "invalidReferences".to_string(),
                    invalid_references.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping idViolations in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceValidation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceValidation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub missing_resources: Vec<Vec<String>>,
            pub invalid_references: Vec<Vec<String>>,
            pub id_violations: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourceValidation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "missingResources" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceValidation".to_string()),
                    "invalidReferences" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceValidation".to_string()),
                    "idViolations" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceValidation".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourceValidation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceValidation {
            missing_resources: intermediate_rep.missing_resources.into_iter().next(),
            invalid_references: intermediate_rep.invalid_references.into_iter().next(),
            id_violations: intermediate_rep.id_violations.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceValidation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceValidation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourceValidation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourceValidation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ResourceValidation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourceValidation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourceValidation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RevenueRange {
    #[serde(rename = "REVENUE_RANGE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "REVENUE_RANGE_UNDER_100K")]
    Under100K,
    #[serde(rename = "REVENUE_RANGE_100K_TO_1M")]
    Variant100Kto1M,
    #[serde(rename = "REVENUE_RANGE_1M_TO_10M")]
    Variant1Mto10M,
    #[serde(rename = "REVENUE_RANGE_10M_TO_50M")]
    Variant10Mto50M,
    #[serde(rename = "REVENUE_RANGE_OVER_50M")]
    Over50M,
}

impl std::fmt::Display for RevenueRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RevenueRange::Unspecified => write!(f, "REVENUE_RANGE_UNSPECIFIED"),
            RevenueRange::Under100K => write!(f, "REVENUE_RANGE_UNDER_100K"),
            RevenueRange::Variant100Kto1M => write!(f, "REVENUE_RANGE_100K_TO_1M"),
            RevenueRange::Variant1Mto10M => write!(f, "REVENUE_RANGE_1M_TO_10M"),
            RevenueRange::Variant10Mto50M => write!(f, "REVENUE_RANGE_10M_TO_50M"),
            RevenueRange::Over50M => write!(f, "REVENUE_RANGE_OVER_50M"),
        }
    }
}

impl std::str::FromStr for RevenueRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REVENUE_RANGE_UNSPECIFIED" => std::result::Result::Ok(RevenueRange::Unspecified),
            "REVENUE_RANGE_UNDER_100K" => std::result::Result::Ok(RevenueRange::Under100K),
            "REVENUE_RANGE_100K_TO_1M" => std::result::Result::Ok(RevenueRange::Variant100Kto1M),
            "REVENUE_RANGE_1M_TO_10M" => std::result::Result::Ok(RevenueRange::Variant1Mto10M),
            "REVENUE_RANGE_10M_TO_50M" => std::result::Result::Ok(RevenueRange::Variant10Mto50M),
            "REVENUE_RANGE_OVER_50M" => std::result::Result::Ok(RevenueRange::Over50M),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Review {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<String>,

    #[serde(rename = "rating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating: Option<f32>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    #[serde(rename = "time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "language")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,

    #[serde(rename = "profilePhotoUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub profile_photo_url: Option<String>,

    #[serde(rename = "reviewCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_count: Option<i32>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl Review {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Review {
        Review {
            id: None,
            author: None,
            rating: None,
            text: None,
            time: None,
            language: None,
            profile_photo_url: None,
            review_count: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
        }
    }
}

/// Converts the Review value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Review {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.author.as_ref().map(|author| {
                [
                    "author".to_string(),
                    author.to_string(),
                ].join(",")
            }),


            self.rating.as_ref().map(|rating| {
                [
                    "rating".to_string(),
                    rating.to_string(),
                ].join(",")
            }),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

            // Skipping time in query parameter serialization


            self.language.as_ref().map(|language| {
                [
                    "language".to_string(),
                    language.to_string(),
                ].join(",")
            }),


            self.profile_photo_url.as_ref().map(|profile_photo_url| {
                [
                    "profilePhotoUrl".to_string(),
                    profile_photo_url.to_string(),
                ].join(",")
            }),


            self.review_count.as_ref().map(|review_count| {
                [
                    "reviewCount".to_string(),
                    review_count.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Review value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Review {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub author: Vec<String>,
            pub rating: Vec<f32>,
            pub text: Vec<String>,
            pub time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub language: Vec<String>,
            pub profile_photo_url: Vec<String>,
            pub review_count: Vec<i32>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Review".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "author" => intermediate_rep.author.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep.rating.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "time" => intermediate_rep.time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "profilePhotoUrl" => intermediate_rep.profile_photo_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reviewCount" => intermediate_rep.review_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Review".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Review {
            id: intermediate_rep.id.into_iter().next(),
            author: intermediate_rep.author.into_iter().next(),
            rating: intermediate_rep.rating.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
            time: intermediate_rep.time.into_iter().next(),
            language: intermediate_rep.language.into_iter().next(),
            profile_photo_url: intermediate_rep.profile_photo_url.into_iter().next(),
            review_count: intermediate_rep.review_count.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Review> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Review>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Review>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Review - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Review> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Review as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Review - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RiskAssessment {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "intelligenceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub intelligence_id: Option<String>,

    #[serde(rename = "riskType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub risk_type: Option<String>,

    #[serde(rename = "riskScore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub risk_score: Option<f32>,

    #[serde(rename = "assessmentDetails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub assessment_details: Option<String>,

    #[serde(rename = "mitigationSuggestions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mitigation_suggestions: Option<Vec<String>>,

    #[serde(rename = "assessorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub assessor_id: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl RiskAssessment {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RiskAssessment {
        RiskAssessment {
            id: None,
            intelligence_id: None,
            risk_type: None,
            risk_score: None,
            assessment_details: None,
            mitigation_suggestions: None,
            assessor_id: None,
            created_at: None,
        }
    }
}

/// Converts the RiskAssessment value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RiskAssessment {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.intelligence_id.as_ref().map(|intelligence_id| {
                [
                    "intelligenceId".to_string(),
                    intelligence_id.to_string(),
                ].join(",")
            }),


            self.risk_type.as_ref().map(|risk_type| {
                [
                    "riskType".to_string(),
                    risk_type.to_string(),
                ].join(",")
            }),


            self.risk_score.as_ref().map(|risk_score| {
                [
                    "riskScore".to_string(),
                    risk_score.to_string(),
                ].join(",")
            }),


            self.assessment_details.as_ref().map(|assessment_details| {
                [
                    "assessmentDetails".to_string(),
                    assessment_details.to_string(),
                ].join(",")
            }),


            self.mitigation_suggestions.as_ref().map(|mitigation_suggestions| {
                [
                    "mitigationSuggestions".to_string(),
                    mitigation_suggestions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.assessor_id.as_ref().map(|assessor_id| {
                [
                    "assessorId".to_string(),
                    assessor_id.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RiskAssessment value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RiskAssessment {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub intelligence_id: Vec<String>,
            pub risk_type: Vec<String>,
            pub risk_score: Vec<f32>,
            pub assessment_details: Vec<String>,
            pub mitigation_suggestions: Vec<Vec<String>>,
            pub assessor_id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RiskAssessment".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "intelligenceId" => intermediate_rep.intelligence_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "riskType" => intermediate_rep.risk_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "riskScore" => intermediate_rep.risk_score.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assessmentDetails" => intermediate_rep.assessment_details.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "mitigationSuggestions" => return std::result::Result::Err("Parsing a container in this style is not supported in RiskAssessment".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "assessorId" => intermediate_rep.assessor_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RiskAssessment".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RiskAssessment {
            id: intermediate_rep.id.into_iter().next(),
            intelligence_id: intermediate_rep.intelligence_id.into_iter().next(),
            risk_type: intermediate_rep.risk_type.into_iter().next(),
            risk_score: intermediate_rep.risk_score.into_iter().next(),
            assessment_details: intermediate_rep.assessment_details.into_iter().next(),
            mitigation_suggestions: intermediate_rep.mitigation_suggestions.into_iter().next(),
            assessor_id: intermediate_rep.assessor_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RiskAssessment> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RiskAssessment>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RiskAssessment>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RiskAssessment - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RiskAssessment> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RiskAssessment as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RiskAssessment - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Role {
    #[serde(rename = "ROLE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "ROLE_ADMIN")]
    Admin,
    #[serde(rename = "ROLE_USER")]
    User,
    #[serde(rename = "ROLE_VIEWER")]
    Viewer,
    #[serde(rename = "ROLE_MANAGER")]
    Manager,
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Role::Unspecified => write!(f, "ROLE_UNSPECIFIED"),
            Role::Admin => write!(f, "ROLE_ADMIN"),
            Role::User => write!(f, "ROLE_USER"),
            Role::Viewer => write!(f, "ROLE_VIEWER"),
            Role::Manager => write!(f, "ROLE_MANAGER"),
        }
    }
}

impl std::str::FromStr for Role {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ROLE_UNSPECIFIED" => std::result::Result::Ok(Role::Unspecified),
            "ROLE_ADMIN" => std::result::Result::Ok(Role::Admin),
            "ROLE_USER" => std::result::Result::Ok(Role::User),
            "ROLE_VIEWER" => std::result::Result::Ok(Role::Viewer),
            "ROLE_MANAGER" => std::result::Result::Ok(Role::Manager),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RotateApiKeyRequest {
    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "accountId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,

    #[serde(rename = "workspaceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace_id: Option<String>,

    #[serde(rename = "keyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,

}


impl RotateApiKeyRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RotateApiKeyRequest {
        RotateApiKeyRequest {
            organization_id: None,
            tenant_id: None,
            account_id: None,
            workspace_id: None,
            key_id: None,
        }
    }
}

/// Converts the RotateApiKeyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RotateApiKeyRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.account_id.as_ref().map(|account_id| {
                [
                    "accountId".to_string(),
                    account_id.to_string(),
                ].join(",")
            }),


            self.workspace_id.as_ref().map(|workspace_id| {
                [
                    "workspaceId".to_string(),
                    workspace_id.to_string(),
                ].join(",")
            }),


            self.key_id.as_ref().map(|key_id| {
                [
                    "keyId".to_string(),
                    key_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RotateApiKeyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RotateApiKeyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub account_id: Vec<String>,
            pub workspace_id: Vec<String>,
            pub key_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RotateApiKeyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accountId" => intermediate_rep.account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspaceId" => intermediate_rep.workspace_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyId" => intermediate_rep.key_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RotateApiKeyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RotateApiKeyRequest {
            organization_id: intermediate_rep.organization_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            account_id: intermediate_rep.account_id.into_iter().next(),
            workspace_id: intermediate_rep.workspace_id.into_iter().next(),
            key_id: intermediate_rep.key_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RotateApiKeyRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RotateApiKeyRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RotateApiKeyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RotateApiKeyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RotateApiKeyRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RotateApiKeyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RotateApiKeyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RotateApiKeyResponse {
    #[serde(rename = "newApiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_api_key: Option<models::ApiKey>,

    #[serde(rename = "newKeyValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_key_value: Option<String>,

    #[serde(rename = "oldKeyExpiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_key_expiry: Option<chrono::DateTime::<chrono::Utc>>,

}


impl RotateApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RotateApiKeyResponse {
        RotateApiKeyResponse {
            new_api_key: None,
            new_key_value: None,
            old_key_expiry: None,
        }
    }
}

/// Converts the RotateApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RotateApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping newApiKey in query parameter serialization


            self.new_key_value.as_ref().map(|new_key_value| {
                [
                    "newKeyValue".to_string(),
                    new_key_value.to_string(),
                ].join(",")
            }),

            // Skipping oldKeyExpiry in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RotateApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RotateApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub new_api_key: Vec<models::ApiKey>,
            pub new_key_value: Vec<String>,
            pub old_key_expiry: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RotateApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "newApiKey" => intermediate_rep.new_api_key.push(<models::ApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "newKeyValue" => intermediate_rep.new_key_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldKeyExpiry" => intermediate_rep.old_key_expiry.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RotateApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RotateApiKeyResponse {
            new_api_key: intermediate_rep.new_api_key.into_iter().next(),
            new_key_value: intermediate_rep.new_key_value.into_iter().next(),
            old_key_expiry: intermediate_rep.old_key_expiry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RotateApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RotateApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RotateApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RotateApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RotateApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RotateApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RotateApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RotateTenantApiKeyRequest {
    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "keyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,

}


impl RotateTenantApiKeyRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RotateTenantApiKeyRequest {
        RotateTenantApiKeyRequest {
            organization_id: None,
            tenant_id: None,
            key_id: None,
        }
    }
}

/// Converts the RotateTenantApiKeyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RotateTenantApiKeyRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.key_id.as_ref().map(|key_id| {
                [
                    "keyId".to_string(),
                    key_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RotateTenantApiKeyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RotateTenantApiKeyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization_id: Vec<String>,
            pub tenant_id: Vec<String>,
            pub key_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RotateTenantApiKeyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyId" => intermediate_rep.key_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RotateTenantApiKeyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RotateTenantApiKeyRequest {
            organization_id: intermediate_rep.organization_id.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            key_id: intermediate_rep.key_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RotateTenantApiKeyRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RotateTenantApiKeyRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RotateTenantApiKeyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RotateTenantApiKeyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RotateTenantApiKeyRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RotateTenantApiKeyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RotateTenantApiKeyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RotateTenantApiKeyResponse {
    #[serde(rename = "newApiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_api_key: Option<models::TenantApiKey>,

    #[serde(rename = "newKeyValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_key_value: Option<String>,

    #[serde(rename = "oldKeyExpiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_key_expiry: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "tenantId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant_id: Option<String>,

    #[serde(rename = "organizationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_id: Option<String>,

}


impl RotateTenantApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RotateTenantApiKeyResponse {
        RotateTenantApiKeyResponse {
            new_api_key: None,
            new_key_value: None,
            old_key_expiry: None,
            tenant_id: None,
            organization_id: None,
        }
    }
}

/// Converts the RotateTenantApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RotateTenantApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping newApiKey in query parameter serialization


            self.new_key_value.as_ref().map(|new_key_value| {
                [
                    "newKeyValue".to_string(),
                    new_key_value.to_string(),
                ].join(",")
            }),

            // Skipping oldKeyExpiry in query parameter serialization


            self.tenant_id.as_ref().map(|tenant_id| {
                [
                    "tenantId".to_string(),
                    tenant_id.to_string(),
                ].join(",")
            }),


            self.organization_id.as_ref().map(|organization_id| {
                [
                    "organizationId".to_string(),
                    organization_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RotateTenantApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RotateTenantApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub new_api_key: Vec<models::TenantApiKey>,
            pub new_key_value: Vec<String>,
            pub old_key_expiry: Vec<chrono::DateTime::<chrono::Utc>>,
            pub tenant_id: Vec<String>,
            pub organization_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RotateTenantApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "newApiKey" => intermediate_rep.new_api_key.push(<models::TenantApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "newKeyValue" => intermediate_rep.new_key_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldKeyExpiry" => intermediate_rep.old_key_expiry.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenantId" => intermediate_rep.tenant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organizationId" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RotateTenantApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RotateTenantApiKeyResponse {
            new_api_key: intermediate_rep.new_api_key.into_iter().next(),
            new_key_value: intermediate_rep.new_key_value.into_iter().next(),
            old_key_expiry: intermediate_rep.old_key_expiry.into_iter().next(),
            tenant_id: intermediate_rep.tenant_id.into_iter().next(),
            organization_id: intermediate_rep.organization_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RotateTenantApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RotateTenantApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RotateTenantApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RotateTenantApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RotateTenantApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RotateTenantApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RotateTenantApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RpcPeriodStatus {
    /// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    /// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    /// A list of messages that carry the error details.  There is a common set of message types for APIs to use.
    #[serde(rename = "details")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<Vec<models::Any>>,

}


impl RpcPeriodStatus {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RpcPeriodStatus {
        RpcPeriodStatus {
            code: None,
            message: None,
            details: None,
        }
    }
}

/// Converts the RpcPeriodStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RpcPeriodStatus {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping details in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RpcPeriodStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RpcPeriodStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub details: Vec<Vec<models::Any>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RpcPeriodStatus".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "details" => return std::result::Result::Err("Parsing a container in this style is not supported in RpcPeriodStatus".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RpcPeriodStatus".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RpcPeriodStatus {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            details: intermediate_rep.details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RpcPeriodStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RpcPeriodStatus>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RpcPeriodStatus>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RpcPeriodStatus - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RpcPeriodStatus> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RpcPeriodStatus as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RpcPeriodStatus - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SchemaValidation {
    #[serde(rename = "schemaVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub schema_version: Option<String>,

    #[serde(rename = "invalidPatterns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invalid_patterns: Option<Vec<String>>,

    #[serde(rename = "typeMismatches")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_mismatches: Option<Vec<String>>,

}


impl SchemaValidation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SchemaValidation {
        SchemaValidation {
            schema_version: None,
            invalid_patterns: None,
            type_mismatches: None,
        }
    }
}

/// Converts the SchemaValidation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SchemaValidation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.schema_version.as_ref().map(|schema_version| {
                [
                    "schemaVersion".to_string(),
                    schema_version.to_string(),
                ].join(",")
            }),


            self.invalid_patterns.as_ref().map(|invalid_patterns| {
                [
                    "invalidPatterns".to_string(),
                    invalid_patterns.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.type_mismatches.as_ref().map(|type_mismatches| {
                [
                    "typeMismatches".to_string(),
                    type_mismatches.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SchemaValidation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SchemaValidation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub schema_version: Vec<String>,
            pub invalid_patterns: Vec<Vec<String>>,
            pub type_mismatches: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SchemaValidation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "schemaVersion" => intermediate_rep.schema_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "invalidPatterns" => return std::result::Result::Err("Parsing a container in this style is not supported in SchemaValidation".to_string()),
                    "typeMismatches" => return std::result::Result::Err("Parsing a container in this style is not supported in SchemaValidation".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SchemaValidation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SchemaValidation {
            schema_version: intermediate_rep.schema_version.into_iter().next(),
            invalid_patterns: intermediate_rep.invalid_patterns.into_iter().next(),
            type_mismatches: intermediate_rep.type_mismatches.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SchemaValidation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SchemaValidation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SchemaValidation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SchemaValidation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SchemaValidation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SchemaValidation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SchemaValidation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// ScrapingJob represents a Google Maps scraping task. This message defines both the configuration and current state of a scraping operation.  Key components: - Basic metadata (id, name, timestamps) - Job status tracking - Search configuration parameters - Geographic settings - Performance options - Multi-tenant context  Database considerations: - Stored in \"gmaps_jobs\" table - Uses GORM for ORM mapping - Includes foreign key to Account - Supports soft deletes  Usage example: ```go job := &ScrapingJob{     Name: \"Athens Cafes\",     Status: BackgroundJobStatus_BACKGROUND_JOB_STATUS_QUEUED,     Keywords: []string{\"cafe\", \"coffee\"},     Lang: \"el\",     Zoom: 15,     FastMode: true,     MaxTime: 3600, } ```
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScrapingJob {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "priority")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<i32>,

    #[serde(rename = "payloadType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload_type: Option<String>,

    #[serde(rename = "payload")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<swagger::ByteArray>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BackgroundJobStatus>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "keywords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<String>>,

    #[serde(rename = "lang")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lang: Option<models::Language>,

    #[serde(rename = "zoom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub zoom: Option<i32>,

    #[serde(rename = "lat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lat: Option<String>,

    #[serde(rename = "lon")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lon: Option<String>,

    #[serde(rename = "fastMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fast_mode: Option<bool>,

    #[serde(rename = "radius")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub radius: Option<i32>,

    #[serde(rename = "depth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub depth: Option<i32>,

    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<bool>,

    #[serde(rename = "maxTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_time: Option<i32>,

    #[serde(rename = "proxies")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub proxies: Option<Vec<String>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "leads")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub leads: Option<Vec<models::Lead>>,

}


impl ScrapingJob {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScrapingJob {
        ScrapingJob {
            id: None,
            priority: None,
            payload_type: None,
            payload: None,
            created_at: None,
            status: None,
            name: None,
            keywords: None,
            lang: None,
            zoom: None,
            lat: None,
            lon: None,
            fast_mode: None,
            radius: None,
            depth: None,
            email: None,
            max_time: None,
            proxies: None,
            updated_at: None,
            deleted_at: None,
            leads: None,
        }
    }
}

/// Converts the ScrapingJob value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScrapingJob {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.priority.as_ref().map(|priority| {
                [
                    "priority".to_string(),
                    priority.to_string(),
                ].join(",")
            }),


            self.payload_type.as_ref().map(|payload_type| {
                [
                    "payloadType".to_string(),
                    payload_type.to_string(),
                ].join(",")
            }),

            // Skipping payload in query parameter serialization
            // Skipping payload in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping status in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.keywords.as_ref().map(|keywords| {
                [
                    "keywords".to_string(),
                    keywords.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping lang in query parameter serialization


            self.zoom.as_ref().map(|zoom| {
                [
                    "zoom".to_string(),
                    zoom.to_string(),
                ].join(",")
            }),


            self.lat.as_ref().map(|lat| {
                [
                    "lat".to_string(),
                    lat.to_string(),
                ].join(",")
            }),


            self.lon.as_ref().map(|lon| {
                [
                    "lon".to_string(),
                    lon.to_string(),
                ].join(",")
            }),


            self.fast_mode.as_ref().map(|fast_mode| {
                [
                    "fastMode".to_string(),
                    fast_mode.to_string(),
                ].join(",")
            }),


            self.radius.as_ref().map(|radius| {
                [
                    "radius".to_string(),
                    radius.to_string(),
                ].join(",")
            }),


            self.depth.as_ref().map(|depth| {
                [
                    "depth".to_string(),
                    depth.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.max_time.as_ref().map(|max_time| {
                [
                    "maxTime".to_string(),
                    max_time.to_string(),
                ].join(",")
            }),


            self.proxies.as_ref().map(|proxies| {
                [
                    "proxies".to_string(),
                    proxies.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping leads in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScrapingJob value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScrapingJob {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub priority: Vec<i32>,
            pub payload_type: Vec<String>,
            pub payload: Vec<swagger::ByteArray>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::BackgroundJobStatus>,
            pub name: Vec<String>,
            pub keywords: Vec<Vec<String>>,
            pub lang: Vec<models::Language>,
            pub zoom: Vec<i32>,
            pub lat: Vec<String>,
            pub lon: Vec<String>,
            pub fast_mode: Vec<bool>,
            pub radius: Vec<i32>,
            pub depth: Vec<i32>,
            pub email: Vec<bool>,
            pub max_time: Vec<i32>,
            pub proxies: Vec<Vec<String>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub leads: Vec<Vec<models::Lead>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ScrapingJob".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "payloadType" => intermediate_rep.payload_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "payload" => return std::result::Result::Err("Parsing binary data in this style is not supported in ScrapingJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::BackgroundJobStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in ScrapingJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "lang" => intermediate_rep.lang.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "zoom" => intermediate_rep.zoom.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lat" => intermediate_rep.lat.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lon" => intermediate_rep.lon.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fastMode" => intermediate_rep.fast_mode.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "radius" => intermediate_rep.radius.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "depth" => intermediate_rep.depth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxTime" => intermediate_rep.max_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "proxies" => return std::result::Result::Err("Parsing a container in this style is not supported in ScrapingJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "leads" => return std::result::Result::Err("Parsing a container in this style is not supported in ScrapingJob".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScrapingJob".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScrapingJob {
            id: intermediate_rep.id.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            payload_type: intermediate_rep.payload_type.into_iter().next(),
            payload: intermediate_rep.payload.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            keywords: intermediate_rep.keywords.into_iter().next(),
            lang: intermediate_rep.lang.into_iter().next(),
            zoom: intermediate_rep.zoom.into_iter().next(),
            lat: intermediate_rep.lat.into_iter().next(),
            lon: intermediate_rep.lon.into_iter().next(),
            fast_mode: intermediate_rep.fast_mode.into_iter().next(),
            radius: intermediate_rep.radius.into_iter().next(),
            depth: intermediate_rep.depth.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            max_time: intermediate_rep.max_time.into_iter().next(),
            proxies: intermediate_rep.proxies.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            leads: intermediate_rep.leads.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScrapingJob> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScrapingJob>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ScrapingJob>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScrapingJob - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ScrapingJob> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScrapingJob as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScrapingJob - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScrapingWorkflow {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "cronExpression")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cron_expression: Option<String>,

    #[serde(rename = "nextRunTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_run_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastRunTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_run_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::WorkflowStatus>,

    #[serde(rename = "retryCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retry_count: Option<i32>,

    #[serde(rename = "maxRetries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_retries: Option<i32>,

    #[serde(rename = "alertEmails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_emails: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "jobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs: Option<Vec<models::ScrapingJob>>,

    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace>,

    #[serde(rename = "geoFencingRadius")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo_fencing_radius: Option<f32>,

    #[serde(rename = "geoFencingLat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo_fencing_lat: Option<f64>,

    #[serde(rename = "geoFencingLon")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo_fencing_lon: Option<f64>,

    #[serde(rename = "geoFencingZoomMin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo_fencing_zoom_min: Option<i32>,

    #[serde(rename = "geoFencingZoomMax")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo_fencing_zoom_max: Option<i32>,

    #[serde(rename = "includeReviews")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_reviews: Option<bool>,

    #[serde(rename = "includePhotos")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_photos: Option<bool>,

    #[serde(rename = "includeBusinessHours")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_business_hours: Option<bool>,

    #[serde(rename = "maxReviewsPerBusiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_reviews_per_business: Option<i32>,

    #[serde(rename = "outputFormat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_format: Option<models::OutputFormat>,

    #[serde(rename = "outputDestination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_destination: Option<String>,

    #[serde(rename = "dataRetention")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_retention: Option<String>,

    #[serde(rename = "anonymizePii")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub anonymize_pii: Option<bool>,

    #[serde(rename = "notificationSlackChannel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_slack_channel: Option<String>,

    #[serde(rename = "notificationEmailGroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_email_group: Option<String>,

    #[serde(rename = "notificationNotifyOnStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_notify_on_start: Option<bool>,

    #[serde(rename = "notificationNotifyOnComplete")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_notify_on_complete: Option<bool>,

    #[serde(rename = "notificationNotifyOnFailure")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_notify_on_failure: Option<bool>,

    #[serde(rename = "contentFilterAllowedCountries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_filter_allowed_countries: Option<Vec<String>>,

    #[serde(rename = "contentFilterExcludedTypes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_filter_excluded_types: Option<Vec<String>>,

    #[serde(rename = "contentFilterMinimumRating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_filter_minimum_rating: Option<f32>,

    #[serde(rename = "contentFilterMinimumReviews")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_filter_minimum_reviews: Option<i32>,

    #[serde(rename = "qosMaxConcurrentRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub qos_max_concurrent_requests: Option<i32>,

    #[serde(rename = "qosMaxRetries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub qos_max_retries: Option<i32>,

    #[serde(rename = "qosRequestTimeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub qos_request_timeout: Option<String>,

    #[serde(rename = "qosEnableJavascript")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub qos_enable_javascript: Option<bool>,

    #[serde(rename = "respectRobotsTxt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub respect_robots_txt: Option<bool>,

    #[serde(rename = "acceptTermsOfService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accept_terms_of_service: Option<bool>,

    #[serde(rename = "userAgent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_agent: Option<String>,

}


impl ScrapingWorkflow {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScrapingWorkflow {
        ScrapingWorkflow {
            id: None,
            name: None,
            cron_expression: None,
            next_run_time: None,
            last_run_time: None,
            status: None,
            retry_count: None,
            max_retries: None,
            alert_emails: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            jobs: None,
            workspace: None,
            geo_fencing_radius: None,
            geo_fencing_lat: None,
            geo_fencing_lon: None,
            geo_fencing_zoom_min: None,
            geo_fencing_zoom_max: None,
            include_reviews: None,
            include_photos: None,
            include_business_hours: None,
            max_reviews_per_business: None,
            output_format: None,
            output_destination: None,
            data_retention: None,
            anonymize_pii: None,
            notification_slack_channel: None,
            notification_email_group: None,
            notification_notify_on_start: None,
            notification_notify_on_complete: None,
            notification_notify_on_failure: None,
            content_filter_allowed_countries: None,
            content_filter_excluded_types: None,
            content_filter_minimum_rating: None,
            content_filter_minimum_reviews: None,
            qos_max_concurrent_requests: None,
            qos_max_retries: None,
            qos_request_timeout: None,
            qos_enable_javascript: None,
            respect_robots_txt: None,
            accept_terms_of_service: None,
            user_agent: None,
        }
    }
}

/// Converts the ScrapingWorkflow value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScrapingWorkflow {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.cron_expression.as_ref().map(|cron_expression| {
                [
                    "cronExpression".to_string(),
                    cron_expression.to_string(),
                ].join(",")
            }),

            // Skipping nextRunTime in query parameter serialization

            // Skipping lastRunTime in query parameter serialization

            // Skipping status in query parameter serialization


            self.retry_count.as_ref().map(|retry_count| {
                [
                    "retryCount".to_string(),
                    retry_count.to_string(),
                ].join(",")
            }),


            self.max_retries.as_ref().map(|max_retries| {
                [
                    "maxRetries".to_string(),
                    max_retries.to_string(),
                ].join(",")
            }),


            self.alert_emails.as_ref().map(|alert_emails| {
                [
                    "alertEmails".to_string(),
                    alert_emails.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping jobs in query parameter serialization

            // Skipping workspace in query parameter serialization


            self.geo_fencing_radius.as_ref().map(|geo_fencing_radius| {
                [
                    "geoFencingRadius".to_string(),
                    geo_fencing_radius.to_string(),
                ].join(",")
            }),


            self.geo_fencing_lat.as_ref().map(|geo_fencing_lat| {
                [
                    "geoFencingLat".to_string(),
                    geo_fencing_lat.to_string(),
                ].join(",")
            }),


            self.geo_fencing_lon.as_ref().map(|geo_fencing_lon| {
                [
                    "geoFencingLon".to_string(),
                    geo_fencing_lon.to_string(),
                ].join(",")
            }),


            self.geo_fencing_zoom_min.as_ref().map(|geo_fencing_zoom_min| {
                [
                    "geoFencingZoomMin".to_string(),
                    geo_fencing_zoom_min.to_string(),
                ].join(",")
            }),


            self.geo_fencing_zoom_max.as_ref().map(|geo_fencing_zoom_max| {
                [
                    "geoFencingZoomMax".to_string(),
                    geo_fencing_zoom_max.to_string(),
                ].join(",")
            }),


            self.include_reviews.as_ref().map(|include_reviews| {
                [
                    "includeReviews".to_string(),
                    include_reviews.to_string(),
                ].join(",")
            }),


            self.include_photos.as_ref().map(|include_photos| {
                [
                    "includePhotos".to_string(),
                    include_photos.to_string(),
                ].join(",")
            }),


            self.include_business_hours.as_ref().map(|include_business_hours| {
                [
                    "includeBusinessHours".to_string(),
                    include_business_hours.to_string(),
                ].join(",")
            }),


            self.max_reviews_per_business.as_ref().map(|max_reviews_per_business| {
                [
                    "maxReviewsPerBusiness".to_string(),
                    max_reviews_per_business.to_string(),
                ].join(",")
            }),

            // Skipping outputFormat in query parameter serialization


            self.output_destination.as_ref().map(|output_destination| {
                [
                    "outputDestination".to_string(),
                    output_destination.to_string(),
                ].join(",")
            }),


            self.data_retention.as_ref().map(|data_retention| {
                [
                    "dataRetention".to_string(),
                    data_retention.to_string(),
                ].join(",")
            }),


            self.anonymize_pii.as_ref().map(|anonymize_pii| {
                [
                    "anonymizePii".to_string(),
                    anonymize_pii.to_string(),
                ].join(",")
            }),


            self.notification_slack_channel.as_ref().map(|notification_slack_channel| {
                [
                    "notificationSlackChannel".to_string(),
                    notification_slack_channel.to_string(),
                ].join(",")
            }),


            self.notification_email_group.as_ref().map(|notification_email_group| {
                [
                    "notificationEmailGroup".to_string(),
                    notification_email_group.to_string(),
                ].join(",")
            }),


            self.notification_notify_on_start.as_ref().map(|notification_notify_on_start| {
                [
                    "notificationNotifyOnStart".to_string(),
                    notification_notify_on_start.to_string(),
                ].join(",")
            }),


            self.notification_notify_on_complete.as_ref().map(|notification_notify_on_complete| {
                [
                    "notificationNotifyOnComplete".to_string(),
                    notification_notify_on_complete.to_string(),
                ].join(",")
            }),


            self.notification_notify_on_failure.as_ref().map(|notification_notify_on_failure| {
                [
                    "notificationNotifyOnFailure".to_string(),
                    notification_notify_on_failure.to_string(),
                ].join(",")
            }),


            self.content_filter_allowed_countries.as_ref().map(|content_filter_allowed_countries| {
                [
                    "contentFilterAllowedCountries".to_string(),
                    content_filter_allowed_countries.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.content_filter_excluded_types.as_ref().map(|content_filter_excluded_types| {
                [
                    "contentFilterExcludedTypes".to_string(),
                    content_filter_excluded_types.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.content_filter_minimum_rating.as_ref().map(|content_filter_minimum_rating| {
                [
                    "contentFilterMinimumRating".to_string(),
                    content_filter_minimum_rating.to_string(),
                ].join(",")
            }),


            self.content_filter_minimum_reviews.as_ref().map(|content_filter_minimum_reviews| {
                [
                    "contentFilterMinimumReviews".to_string(),
                    content_filter_minimum_reviews.to_string(),
                ].join(",")
            }),


            self.qos_max_concurrent_requests.as_ref().map(|qos_max_concurrent_requests| {
                [
                    "qosMaxConcurrentRequests".to_string(),
                    qos_max_concurrent_requests.to_string(),
                ].join(",")
            }),


            self.qos_max_retries.as_ref().map(|qos_max_retries| {
                [
                    "qosMaxRetries".to_string(),
                    qos_max_retries.to_string(),
                ].join(",")
            }),


            self.qos_request_timeout.as_ref().map(|qos_request_timeout| {
                [
                    "qosRequestTimeout".to_string(),
                    qos_request_timeout.to_string(),
                ].join(",")
            }),


            self.qos_enable_javascript.as_ref().map(|qos_enable_javascript| {
                [
                    "qosEnableJavascript".to_string(),
                    qos_enable_javascript.to_string(),
                ].join(",")
            }),


            self.respect_robots_txt.as_ref().map(|respect_robots_txt| {
                [
                    "respectRobotsTxt".to_string(),
                    respect_robots_txt.to_string(),
                ].join(",")
            }),


            self.accept_terms_of_service.as_ref().map(|accept_terms_of_service| {
                [
                    "acceptTermsOfService".to_string(),
                    accept_terms_of_service.to_string(),
                ].join(",")
            }),


            self.user_agent.as_ref().map(|user_agent| {
                [
                    "userAgent".to_string(),
                    user_agent.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScrapingWorkflow value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScrapingWorkflow {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub cron_expression: Vec<String>,
            pub next_run_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_run_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::WorkflowStatus>,
            pub retry_count: Vec<i32>,
            pub max_retries: Vec<i32>,
            pub alert_emails: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub jobs: Vec<Vec<models::ScrapingJob>>,
            pub workspace: Vec<models::Workspace>,
            pub geo_fencing_radius: Vec<f32>,
            pub geo_fencing_lat: Vec<f64>,
            pub geo_fencing_lon: Vec<f64>,
            pub geo_fencing_zoom_min: Vec<i32>,
            pub geo_fencing_zoom_max: Vec<i32>,
            pub include_reviews: Vec<bool>,
            pub include_photos: Vec<bool>,
            pub include_business_hours: Vec<bool>,
            pub max_reviews_per_business: Vec<i32>,
            pub output_format: Vec<models::OutputFormat>,
            pub output_destination: Vec<String>,
            pub data_retention: Vec<String>,
            pub anonymize_pii: Vec<bool>,
            pub notification_slack_channel: Vec<String>,
            pub notification_email_group: Vec<String>,
            pub notification_notify_on_start: Vec<bool>,
            pub notification_notify_on_complete: Vec<bool>,
            pub notification_notify_on_failure: Vec<bool>,
            pub content_filter_allowed_countries: Vec<Vec<String>>,
            pub content_filter_excluded_types: Vec<Vec<String>>,
            pub content_filter_minimum_rating: Vec<f32>,
            pub content_filter_minimum_reviews: Vec<i32>,
            pub qos_max_concurrent_requests: Vec<i32>,
            pub qos_max_retries: Vec<i32>,
            pub qos_request_timeout: Vec<String>,
            pub qos_enable_javascript: Vec<bool>,
            pub respect_robots_txt: Vec<bool>,
            pub accept_terms_of_service: Vec<bool>,
            pub user_agent: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ScrapingWorkflow".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cronExpression" => intermediate_rep.cron_expression.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nextRunTime" => intermediate_rep.next_run_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastRunTime" => intermediate_rep.last_run_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::WorkflowStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retryCount" => intermediate_rep.retry_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxRetries" => intermediate_rep.max_retries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "alertEmails" => intermediate_rep.alert_emails.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "jobs" => return std::result::Result::Err("Parsing a container in this style is not supported in ScrapingWorkflow".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "geoFencingRadius" => intermediate_rep.geo_fencing_radius.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "geoFencingLat" => intermediate_rep.geo_fencing_lat.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "geoFencingLon" => intermediate_rep.geo_fencing_lon.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "geoFencingZoomMin" => intermediate_rep.geo_fencing_zoom_min.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "geoFencingZoomMax" => intermediate_rep.geo_fencing_zoom_max.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "includeReviews" => intermediate_rep.include_reviews.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "includePhotos" => intermediate_rep.include_photos.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "includeBusinessHours" => intermediate_rep.include_business_hours.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxReviewsPerBusiness" => intermediate_rep.max_reviews_per_business.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outputFormat" => intermediate_rep.output_format.push(<models::OutputFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outputDestination" => intermediate_rep.output_destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataRetention" => intermediate_rep.data_retention.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anonymizePii" => intermediate_rep.anonymize_pii.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notificationSlackChannel" => intermediate_rep.notification_slack_channel.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notificationEmailGroup" => intermediate_rep.notification_email_group.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notificationNotifyOnStart" => intermediate_rep.notification_notify_on_start.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notificationNotifyOnComplete" => intermediate_rep.notification_notify_on_complete.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notificationNotifyOnFailure" => intermediate_rep.notification_notify_on_failure.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "contentFilterAllowedCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in ScrapingWorkflow".to_string()),
                    "contentFilterExcludedTypes" => return std::result::Result::Err("Parsing a container in this style is not supported in ScrapingWorkflow".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "contentFilterMinimumRating" => intermediate_rep.content_filter_minimum_rating.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contentFilterMinimumReviews" => intermediate_rep.content_filter_minimum_reviews.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "qosMaxConcurrentRequests" => intermediate_rep.qos_max_concurrent_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "qosMaxRetries" => intermediate_rep.qos_max_retries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "qosRequestTimeout" => intermediate_rep.qos_request_timeout.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "qosEnableJavascript" => intermediate_rep.qos_enable_javascript.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "respectRobotsTxt" => intermediate_rep.respect_robots_txt.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "acceptTermsOfService" => intermediate_rep.accept_terms_of_service.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userAgent" => intermediate_rep.user_agent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScrapingWorkflow".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScrapingWorkflow {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            cron_expression: intermediate_rep.cron_expression.into_iter().next(),
            next_run_time: intermediate_rep.next_run_time.into_iter().next(),
            last_run_time: intermediate_rep.last_run_time.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            retry_count: intermediate_rep.retry_count.into_iter().next(),
            max_retries: intermediate_rep.max_retries.into_iter().next(),
            alert_emails: intermediate_rep.alert_emails.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            jobs: intermediate_rep.jobs.into_iter().next(),
            workspace: intermediate_rep.workspace.into_iter().next(),
            geo_fencing_radius: intermediate_rep.geo_fencing_radius.into_iter().next(),
            geo_fencing_lat: intermediate_rep.geo_fencing_lat.into_iter().next(),
            geo_fencing_lon: intermediate_rep.geo_fencing_lon.into_iter().next(),
            geo_fencing_zoom_min: intermediate_rep.geo_fencing_zoom_min.into_iter().next(),
            geo_fencing_zoom_max: intermediate_rep.geo_fencing_zoom_max.into_iter().next(),
            include_reviews: intermediate_rep.include_reviews.into_iter().next(),
            include_photos: intermediate_rep.include_photos.into_iter().next(),
            include_business_hours: intermediate_rep.include_business_hours.into_iter().next(),
            max_reviews_per_business: intermediate_rep.max_reviews_per_business.into_iter().next(),
            output_format: intermediate_rep.output_format.into_iter().next(),
            output_destination: intermediate_rep.output_destination.into_iter().next(),
            data_retention: intermediate_rep.data_retention.into_iter().next(),
            anonymize_pii: intermediate_rep.anonymize_pii.into_iter().next(),
            notification_slack_channel: intermediate_rep.notification_slack_channel.into_iter().next(),
            notification_email_group: intermediate_rep.notification_email_group.into_iter().next(),
            notification_notify_on_start: intermediate_rep.notification_notify_on_start.into_iter().next(),
            notification_notify_on_complete: intermediate_rep.notification_notify_on_complete.into_iter().next(),
            notification_notify_on_failure: intermediate_rep.notification_notify_on_failure.into_iter().next(),
            content_filter_allowed_countries: intermediate_rep.content_filter_allowed_countries.into_iter().next(),
            content_filter_excluded_types: intermediate_rep.content_filter_excluded_types.into_iter().next(),
            content_filter_minimum_rating: intermediate_rep.content_filter_minimum_rating.into_iter().next(),
            content_filter_minimum_reviews: intermediate_rep.content_filter_minimum_reviews.into_iter().next(),
            qos_max_concurrent_requests: intermediate_rep.qos_max_concurrent_requests.into_iter().next(),
            qos_max_retries: intermediate_rep.qos_max_retries.into_iter().next(),
            qos_request_timeout: intermediate_rep.qos_request_timeout.into_iter().next(),
            qos_enable_javascript: intermediate_rep.qos_enable_javascript.into_iter().next(),
            respect_robots_txt: intermediate_rep.respect_robots_txt.into_iter().next(),
            accept_terms_of_service: intermediate_rep.accept_terms_of_service.into_iter().next(),
            user_agent: intermediate_rep.user_agent.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScrapingWorkflow> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScrapingWorkflow>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ScrapingWorkflow>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScrapingWorkflow - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ScrapingWorkflow> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScrapingWorkflow as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScrapingWorkflow - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceStatus {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "dependencies")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependencies: Option<Vec<models::Dependency>>,

}


impl ServiceStatus {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ServiceStatus {
        ServiceStatus {
            name: None,
            status: None,
            metrics: None,
            dependencies: None,
        }
    }
}

/// Converts the ServiceStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceStatus {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

            // Skipping metrics in query parameter serialization

            // Skipping dependencies in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<String>,
            pub metrics: Vec<std::collections::HashMap<String, String>>,
            pub dependencies: Vec<Vec<models::Dependency>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceStatus".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceStatus".to_string()),
                    "dependencies" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceStatus".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceStatus".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceStatus {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            metrics: intermediate_rep.metrics.into_iter().next(),
            dependencies: intermediate_rep.dependencies.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceStatus>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceStatus>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceStatus - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ServiceStatus> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceStatus as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceStatus - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents service availability errors
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceUnavailableErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::InternalErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "availabilityInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_info: Option<models::AvailabilityInfo>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl ServiceUnavailableErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ServiceUnavailableErrorMessageResponse {
        ServiceUnavailableErrorMessageResponse {
            code: None,
            message: None,
            availability_info: None,
            error_response: None,
        }
    }
}

/// Converts the ServiceUnavailableErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceUnavailableErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping availabilityInfo in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceUnavailableErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceUnavailableErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::InternalErrorCode>,
            pub message: Vec<String>,
            pub availability_info: Vec<models::AvailabilityInfo>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceUnavailableErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::InternalErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "availabilityInfo" => intermediate_rep.availability_info.push(<models::AvailabilityInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceUnavailableErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceUnavailableErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            availability_info: intermediate_rep.availability_info.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceUnavailableErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceUnavailableErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceUnavailableErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceUnavailableErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ServiceUnavailableErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceUnavailableErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceUnavailableErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SessionInfo {
    #[serde(rename = "sessionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub session_id: Option<String>,

    #[serde(rename = "lastActive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_active: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deviceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_id: Option<String>,

    #[serde(rename = "ipAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

}


impl SessionInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SessionInfo {
        SessionInfo {
            session_id: None,
            last_active: None,
            device_id: None,
            ip_address: None,
        }
    }
}

/// Converts the SessionInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SessionInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.session_id.as_ref().map(|session_id| {
                [
                    "sessionId".to_string(),
                    session_id.to_string(),
                ].join(",")
            }),

            // Skipping lastActive in query parameter serialization


            self.device_id.as_ref().map(|device_id| {
                [
                    "deviceId".to_string(),
                    device_id.to_string(),
                ].join(",")
            }),


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "ipAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SessionInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SessionInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub session_id: Vec<String>,
            pub last_active: Vec<chrono::DateTime::<chrono::Utc>>,
            pub device_id: Vec<String>,
            pub ip_address: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SessionInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sessionId" => intermediate_rep.session_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastActive" => intermediate_rep.last_active.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deviceId" => intermediate_rep.device_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SessionInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SessionInfo {
            session_id: intermediate_rep.session_id.into_iter().next(),
            last_active: intermediate_rep.last_active.into_iter().next(),
            device_id: intermediate_rep.device_id.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SessionInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SessionInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SessionInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SessionInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SessionInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SessionInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SessionInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShareWorkspaceBody {
    #[serde(rename = "sharedWithEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_with_email: Option<String>,

    #[serde(rename = "permissionLevel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission_level: Option<String>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ShareWorkspaceBody {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ShareWorkspaceBody {
        ShareWorkspaceBody {
            shared_with_email: None,
            permission_level: None,
            expires_at: None,
        }
    }
}

/// Converts the ShareWorkspaceBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ShareWorkspaceBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.shared_with_email.as_ref().map(|shared_with_email| {
                [
                    "sharedWithEmail".to_string(),
                    shared_with_email.to_string(),
                ].join(",")
            }),


            self.permission_level.as_ref().map(|permission_level| {
                [
                    "permissionLevel".to_string(),
                    permission_level.to_string(),
                ].join(",")
            }),

            // Skipping expiresAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ShareWorkspaceBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ShareWorkspaceBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shared_with_email: Vec<String>,
            pub permission_level: Vec<String>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ShareWorkspaceBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sharedWithEmail" => intermediate_rep.shared_with_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "permissionLevel" => intermediate_rep.permission_level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ShareWorkspaceBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ShareWorkspaceBody {
            shared_with_email: intermediate_rep.shared_with_email.into_iter().next(),
            permission_level: intermediate_rep.permission_level.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ShareWorkspaceBody> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ShareWorkspaceBody>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ShareWorkspaceBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ShareWorkspaceBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ShareWorkspaceBody> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ShareWorkspaceBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ShareWorkspaceBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShareWorkspaceResponse {
    #[serde(rename = "sharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharing: Option<models::WorkspaceSharing>,

}


impl ShareWorkspaceResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ShareWorkspaceResponse {
        ShareWorkspaceResponse {
            sharing: None,
        }
    }
}

/// Converts the ShareWorkspaceResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ShareWorkspaceResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sharing in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ShareWorkspaceResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ShareWorkspaceResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sharing: Vec<models::WorkspaceSharing>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ShareWorkspaceResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sharing" => intermediate_rep.sharing.push(<models::WorkspaceSharing as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ShareWorkspaceResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ShareWorkspaceResponse {
            sharing: intermediate_rep.sharing.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ShareWorkspaceResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ShareWorkspaceResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ShareWorkspaceResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ShareWorkspaceResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ShareWorkspaceResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ShareWorkspaceResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ShareWorkspaceResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SignatureBlock {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "requestId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_id: Option<String>,

    #[serde(rename = "blockType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_type: Option<String>,

    #[serde(rename = "pageNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_number: Option<i32>,

    #[serde(rename = "xPosition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_position: Option<f32>,

    #[serde(rename = "yPosition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub y_position: Option<f32>,

    #[serde(rename = "width")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub width: Option<f32>,

    #[serde(rename = "height")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub height: Option<f32>,

    #[serde(rename = "isRequired")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_required: Option<bool>,

    #[serde(rename = "signatureData")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature_data: Option<String>,

    #[serde(rename = "signedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signed_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl SignatureBlock {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SignatureBlock {
        SignatureBlock {
            id: None,
            request_id: None,
            block_type: None,
            page_number: None,
            x_position: None,
            y_position: None,
            width: None,
            height: None,
            is_required: None,
            signature_data: None,
            signed_at: None,
        }
    }
}

/// Converts the SignatureBlock value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SignatureBlock {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.request_id.as_ref().map(|request_id| {
                [
                    "requestId".to_string(),
                    request_id.to_string(),
                ].join(",")
            }),


            self.block_type.as_ref().map(|block_type| {
                [
                    "blockType".to_string(),
                    block_type.to_string(),
                ].join(",")
            }),


            self.page_number.as_ref().map(|page_number| {
                [
                    "pageNumber".to_string(),
                    page_number.to_string(),
                ].join(",")
            }),


            self.x_position.as_ref().map(|x_position| {
                [
                    "xPosition".to_string(),
                    x_position.to_string(),
                ].join(",")
            }),


            self.y_position.as_ref().map(|y_position| {
                [
                    "yPosition".to_string(),
                    y_position.to_string(),
                ].join(",")
            }),


            self.width.as_ref().map(|width| {
                [
                    "width".to_string(),
                    width.to_string(),
                ].join(",")
            }),


            self.height.as_ref().map(|height| {
                [
                    "height".to_string(),
                    height.to_string(),
                ].join(",")
            }),


            self.is_required.as_ref().map(|is_required| {
                [
                    "isRequired".to_string(),
                    is_required.to_string(),
                ].join(",")
            }),


            self.signature_data.as_ref().map(|signature_data| {
                [
                    "signatureData".to_string(),
                    signature_data.to_string(),
                ].join(",")
            }),

            // Skipping signedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SignatureBlock value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SignatureBlock {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub request_id: Vec<String>,
            pub block_type: Vec<String>,
            pub page_number: Vec<i32>,
            pub x_position: Vec<f32>,
            pub y_position: Vec<f32>,
            pub width: Vec<f32>,
            pub height: Vec<f32>,
            pub is_required: Vec<bool>,
            pub signature_data: Vec<String>,
            pub signed_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SignatureBlock".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requestId" => intermediate_rep.request_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "blockType" => intermediate_rep.block_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pageNumber" => intermediate_rep.page_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "xPosition" => intermediate_rep.x_position.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "yPosition" => intermediate_rep.y_position.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "height" => intermediate_rep.height.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isRequired" => intermediate_rep.is_required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signatureData" => intermediate_rep.signature_data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signedAt" => intermediate_rep.signed_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SignatureBlock".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SignatureBlock {
            id: intermediate_rep.id.into_iter().next(),
            request_id: intermediate_rep.request_id.into_iter().next(),
            block_type: intermediate_rep.block_type.into_iter().next(),
            page_number: intermediate_rep.page_number.into_iter().next(),
            x_position: intermediate_rep.x_position.into_iter().next(),
            y_position: intermediate_rep.y_position.into_iter().next(),
            width: intermediate_rep.width.into_iter().next(),
            height: intermediate_rep.height.into_iter().next(),
            is_required: intermediate_rep.is_required.into_iter().next(),
            signature_data: intermediate_rep.signature_data.into_iter().next(),
            signed_at: intermediate_rep.signed_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SignatureBlock> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SignatureBlock>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SignatureBlock>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SignatureBlock - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SignatureBlock> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SignatureBlock as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SignatureBlock - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SignatureRequest {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::SignatureStatus>,

    #[serde(rename = "signerEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signer_email: Option<String>,

    #[serde(rename = "signerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signer_name: Option<String>,

    #[serde(rename = "role")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

    #[serde(rename = "authenticationMethod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authentication_method: Option<String>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "requiresMfa")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requires_mfa: Option<bool>,

    #[serde(rename = "signatureType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature_type: Option<String>,

    #[serde(rename = "reminderSchedule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reminder_schedule: Option<Vec<String>>,

    #[serde(rename = "documentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub document_id: Option<String>,

    #[serde(rename = "signatureBlocks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature_blocks: Option<Vec<models::SignatureBlock>>,

    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::SignatureWorkflow>,

}


impl SignatureRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SignatureRequest {
        SignatureRequest {
            id: None,
            status: None,
            signer_email: None,
            signer_name: None,
            role: None,
            authentication_method: None,
            expires_at: None,
            requires_mfa: None,
            signature_type: None,
            reminder_schedule: None,
            document_id: None,
            signature_blocks: None,
            workflow: None,
        }
    }
}

/// Converts the SignatureRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SignatureRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.signer_email.as_ref().map(|signer_email| {
                [
                    "signerEmail".to_string(),
                    signer_email.to_string(),
                ].join(",")
            }),


            self.signer_name.as_ref().map(|signer_name| {
                [
                    "signerName".to_string(),
                    signer_name.to_string(),
                ].join(",")
            }),


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),


            self.authentication_method.as_ref().map(|authentication_method| {
                [
                    "authenticationMethod".to_string(),
                    authentication_method.to_string(),
                ].join(",")
            }),

            // Skipping expiresAt in query parameter serialization


            self.requires_mfa.as_ref().map(|requires_mfa| {
                [
                    "requiresMfa".to_string(),
                    requires_mfa.to_string(),
                ].join(",")
            }),


            self.signature_type.as_ref().map(|signature_type| {
                [
                    "signatureType".to_string(),
                    signature_type.to_string(),
                ].join(",")
            }),


            self.reminder_schedule.as_ref().map(|reminder_schedule| {
                [
                    "reminderSchedule".to_string(),
                    reminder_schedule.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.document_id.as_ref().map(|document_id| {
                [
                    "documentId".to_string(),
                    document_id.to_string(),
                ].join(",")
            }),

            // Skipping signatureBlocks in query parameter serialization

            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SignatureRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SignatureRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub status: Vec<models::SignatureStatus>,
            pub signer_email: Vec<String>,
            pub signer_name: Vec<String>,
            pub role: Vec<String>,
            pub authentication_method: Vec<String>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub requires_mfa: Vec<bool>,
            pub signature_type: Vec<String>,
            pub reminder_schedule: Vec<Vec<String>>,
            pub document_id: Vec<String>,
            pub signature_blocks: Vec<Vec<models::SignatureBlock>>,
            pub workflow: Vec<models::SignatureWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SignatureRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::SignatureStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signerEmail" => intermediate_rep.signer_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signerName" => intermediate_rep.signer_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authenticationMethod" => intermediate_rep.authentication_method.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requiresMfa" => intermediate_rep.requires_mfa.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signatureType" => intermediate_rep.signature_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "reminderSchedule" => return std::result::Result::Err("Parsing a container in this style is not supported in SignatureRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "documentId" => intermediate_rep.document_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "signatureBlocks" => return std::result::Result::Err("Parsing a container in this style is not supported in SignatureRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::SignatureWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SignatureRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SignatureRequest {
            id: intermediate_rep.id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            signer_email: intermediate_rep.signer_email.into_iter().next(),
            signer_name: intermediate_rep.signer_name.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
            authentication_method: intermediate_rep.authentication_method.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            requires_mfa: intermediate_rep.requires_mfa.into_iter().next(),
            signature_type: intermediate_rep.signature_type.into_iter().next(),
            reminder_schedule: intermediate_rep.reminder_schedule.into_iter().next(),
            document_id: intermediate_rep.document_id.into_iter().next(),
            signature_blocks: intermediate_rep.signature_blocks.into_iter().next(),
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SignatureRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SignatureRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SignatureRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SignatureRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SignatureRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SignatureRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SignatureRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SignatureStatus {
    #[serde(rename = "SIGNATURE_STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "SIGNATURE_STATUS_PENDING")]
    Pending,
    #[serde(rename = "SIGNATURE_STATUS_SIGNED")]
    Signed,
    #[serde(rename = "SIGNATURE_STATUS_REJECTED")]
    Rejected,
    #[serde(rename = "SIGNATURE_STATUS_EXPIRED")]
    Expired,
    #[serde(rename = "SIGNATURE_STATUS_REVOKED")]
    Revoked,
}

impl std::fmt::Display for SignatureStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SignatureStatus::Unspecified => write!(f, "SIGNATURE_STATUS_UNSPECIFIED"),
            SignatureStatus::Pending => write!(f, "SIGNATURE_STATUS_PENDING"),
            SignatureStatus::Signed => write!(f, "SIGNATURE_STATUS_SIGNED"),
            SignatureStatus::Rejected => write!(f, "SIGNATURE_STATUS_REJECTED"),
            SignatureStatus::Expired => write!(f, "SIGNATURE_STATUS_EXPIRED"),
            SignatureStatus::Revoked => write!(f, "SIGNATURE_STATUS_REVOKED"),
        }
    }
}

impl std::str::FromStr for SignatureStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SIGNATURE_STATUS_UNSPECIFIED" => std::result::Result::Ok(SignatureStatus::Unspecified),
            "SIGNATURE_STATUS_PENDING" => std::result::Result::Ok(SignatureStatus::Pending),
            "SIGNATURE_STATUS_SIGNED" => std::result::Result::Ok(SignatureStatus::Signed),
            "SIGNATURE_STATUS_REJECTED" => std::result::Result::Ok(SignatureStatus::Rejected),
            "SIGNATURE_STATUS_EXPIRED" => std::result::Result::Ok(SignatureStatus::Expired),
            "SIGNATURE_STATUS_REVOKED" => std::result::Result::Ok(SignatureStatus::Revoked),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SignatureWorkflow {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "requestId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_id: Option<String>,

    #[serde(rename = "signingOrder")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signing_order: Option<Vec<String>>,

    #[serde(rename = "currentSigner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_signer: Option<String>,

    #[serde(rename = "workflowStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_status: Option<String>,

    #[serde(rename = "parallelSigning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parallel_signing: Option<bool>,

    #[serde(rename = "requireAllSignatures")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_all_signatures: Option<bool>,

    #[serde(rename = "deadline")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deadline: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl SignatureWorkflow {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SignatureWorkflow {
        SignatureWorkflow {
            id: None,
            request_id: None,
            signing_order: None,
            current_signer: None,
            workflow_status: None,
            parallel_signing: None,
            require_all_signatures: None,
            deadline: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the SignatureWorkflow value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SignatureWorkflow {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.request_id.as_ref().map(|request_id| {
                [
                    "requestId".to_string(),
                    request_id.to_string(),
                ].join(",")
            }),


            self.signing_order.as_ref().map(|signing_order| {
                [
                    "signingOrder".to_string(),
                    signing_order.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.current_signer.as_ref().map(|current_signer| {
                [
                    "currentSigner".to_string(),
                    current_signer.to_string(),
                ].join(",")
            }),


            self.workflow_status.as_ref().map(|workflow_status| {
                [
                    "workflowStatus".to_string(),
                    workflow_status.to_string(),
                ].join(",")
            }),


            self.parallel_signing.as_ref().map(|parallel_signing| {
                [
                    "parallelSigning".to_string(),
                    parallel_signing.to_string(),
                ].join(",")
            }),


            self.require_all_signatures.as_ref().map(|require_all_signatures| {
                [
                    "requireAllSignatures".to_string(),
                    require_all_signatures.to_string(),
                ].join(",")
            }),

            // Skipping deadline in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SignatureWorkflow value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SignatureWorkflow {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub request_id: Vec<String>,
            pub signing_order: Vec<Vec<String>>,
            pub current_signer: Vec<String>,
            pub workflow_status: Vec<String>,
            pub parallel_signing: Vec<bool>,
            pub require_all_signatures: Vec<bool>,
            pub deadline: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SignatureWorkflow".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requestId" => intermediate_rep.request_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "signingOrder" => return std::result::Result::Err("Parsing a container in this style is not supported in SignatureWorkflow".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currentSigner" => intermediate_rep.current_signer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workflowStatus" => intermediate_rep.workflow_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parallelSigning" => intermediate_rep.parallel_signing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requireAllSignatures" => intermediate_rep.require_all_signatures.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deadline" => intermediate_rep.deadline.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SignatureWorkflow".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SignatureWorkflow {
            id: intermediate_rep.id.into_iter().next(),
            request_id: intermediate_rep.request_id.into_iter().next(),
            signing_order: intermediate_rep.signing_order.into_iter().next(),
            current_signer: intermediate_rep.current_signer.into_iter().next(),
            workflow_status: intermediate_rep.workflow_status.into_iter().next(),
            parallel_signing: intermediate_rep.parallel_signing.into_iter().next(),
            require_all_signatures: intermediate_rep.require_all_signatures.into_iter().next(),
            deadline: intermediate_rep.deadline.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SignatureWorkflow> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SignatureWorkflow>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SignatureWorkflow>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SignatureWorkflow - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SignatureWorkflow> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SignatureWorkflow as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SignatureWorkflow - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Status {
    /// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    /// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    /// A list of messages that carry the error details.  There is a common set of message types for APIs to use.
    #[serde(rename = "details")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<Vec<models::Any>>,

}


impl Status {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Status {
        Status {
            code: None,
            message: None,
            details: None,
        }
    }
}

/// Converts the Status value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Status {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping details in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Status value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Status {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub details: Vec<Vec<models::Any>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Status".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "details" => return std::result::Result::Err("Parsing a container in this style is not supported in Status".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Status".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Status {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            details: intermediate_rep.details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Status> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Status>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Status>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Status - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Status> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Status as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Status - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StorageBreakdown {
    #[serde(rename = "fileType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_type: Option<String>,

    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<String>,

    #[serde(rename = "fileCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_count: Option<i32>,

}


impl StorageBreakdown {
    #[allow(clippy::new_without_default)]
    pub fn new() -> StorageBreakdown {
        StorageBreakdown {
            file_type: None,
            size: None,
            file_count: None,
        }
    }
}

/// Converts the StorageBreakdown value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StorageBreakdown {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.file_type.as_ref().map(|file_type| {
                [
                    "fileType".to_string(),
                    file_type.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.file_count.as_ref().map(|file_count| {
                [
                    "fileCount".to_string(),
                    file_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StorageBreakdown value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StorageBreakdown {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_type: Vec<String>,
            pub size: Vec<String>,
            pub file_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StorageBreakdown".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fileType" => intermediate_rep.file_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fileCount" => intermediate_rep.file_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StorageBreakdown".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StorageBreakdown {
            file_type: intermediate_rep.file_type.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            file_count: intermediate_rep.file_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StorageBreakdown> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<StorageBreakdown>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StorageBreakdown>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for StorageBreakdown - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<StorageBreakdown> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StorageBreakdown as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into StorageBreakdown - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Key features: - Stripe integration - Usage-based billing - Metered pricing - Feature flags  Database considerations: - Syncs with Stripe webhooks - Tracks usage for metered billing - Maintains subscription lifecycle
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Subscription {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "stripeCustomerId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stripe_customer_id: Option<String>,

    #[serde(rename = "stripeSubscriptionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stripe_subscription_id: Option<String>,

    #[serde(rename = "stripePriceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stripe_price_id: Option<String>,

    #[serde(rename = "stripeProductId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stripe_product_id: Option<String>,

    #[serde(rename = "planTier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_tier: Option<models::PlanTier>,

    #[serde(rename = "billingMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_mode: Option<models::BillingMode>,

    /// Jobs included in base price
    #[serde(rename = "includedJobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub included_jobs: Option<i32>,

    #[serde(rename = "perJobRate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub per_job_rate: Option<f32>,

    #[serde(rename = "maxConcurrentJobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_concurrent_jobs: Option<i32>,

    #[serde(rename = "includedStorage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub included_storage: Option<String>,

    #[serde(rename = "perGbRate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub per_gb_rate: Option<f32>,

    #[serde(rename = "advancedFilteringEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_filtering_enabled: Option<bool>,

    #[serde(rename = "prioritySupportEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_support_enabled: Option<bool>,

    #[serde(rename = "customExportsEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_exports_enabled: Option<bool>,

    #[serde(rename = "apiAccessEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_access_enabled: Option<bool>,

    #[serde(rename = "customProxiesEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_proxies_enabled: Option<bool>,

    #[serde(rename = "advancedAnalyticsEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_analytics_enabled: Option<bool>,

    #[serde(rename = "retentionDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_days: Option<i32>,

    #[serde(rename = "maxResultsPerJob")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_results_per_job: Option<i32>,

    #[serde(rename = "currentPeriodStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_period_start: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "currentPeriodEnd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_period_end: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "currentPeriodUsage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_period_usage: Option<f32>,

    /// e.g., \"usd\"
    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<String>,

    #[serde(rename = "basePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_price: Option<f32>,

    #[serde(rename = "billingInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_interval: Option<models::Interval>,

    #[serde(rename = "autoRenew")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_renew: Option<bool>,

    #[serde(rename = "paymentStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_status: Option<models::PaymentStatus>,

    #[serde(rename = "isTrial")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_trial: Option<bool>,

    #[serde(rename = "trialStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub trial_start: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "trialEnd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub trial_end: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "canceledAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub canceled_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "endedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ended_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl Subscription {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Subscription {
        Subscription {
            id: None,
            stripe_customer_id: None,
            stripe_subscription_id: None,
            stripe_price_id: None,
            stripe_product_id: None,
            plan_tier: None,
            billing_mode: None,
            included_jobs: None,
            per_job_rate: None,
            max_concurrent_jobs: None,
            included_storage: None,
            per_gb_rate: None,
            advanced_filtering_enabled: None,
            priority_support_enabled: None,
            custom_exports_enabled: None,
            api_access_enabled: None,
            custom_proxies_enabled: None,
            advanced_analytics_enabled: None,
            retention_days: None,
            max_results_per_job: None,
            current_period_start: None,
            current_period_end: None,
            current_period_usage: None,
            currency: None,
            base_price: None,
            billing_interval: None,
            auto_renew: None,
            payment_status: None,
            is_trial: None,
            trial_start: None,
            trial_end: None,
            created_at: None,
            updated_at: None,
            canceled_at: None,
            ended_at: None,
        }
    }
}

/// Converts the Subscription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Subscription {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.stripe_customer_id.as_ref().map(|stripe_customer_id| {
                [
                    "stripeCustomerId".to_string(),
                    stripe_customer_id.to_string(),
                ].join(",")
            }),


            self.stripe_subscription_id.as_ref().map(|stripe_subscription_id| {
                [
                    "stripeSubscriptionId".to_string(),
                    stripe_subscription_id.to_string(),
                ].join(",")
            }),


            self.stripe_price_id.as_ref().map(|stripe_price_id| {
                [
                    "stripePriceId".to_string(),
                    stripe_price_id.to_string(),
                ].join(",")
            }),


            self.stripe_product_id.as_ref().map(|stripe_product_id| {
                [
                    "stripeProductId".to_string(),
                    stripe_product_id.to_string(),
                ].join(",")
            }),

            // Skipping planTier in query parameter serialization

            // Skipping billingMode in query parameter serialization


            self.included_jobs.as_ref().map(|included_jobs| {
                [
                    "includedJobs".to_string(),
                    included_jobs.to_string(),
                ].join(",")
            }),


            self.per_job_rate.as_ref().map(|per_job_rate| {
                [
                    "perJobRate".to_string(),
                    per_job_rate.to_string(),
                ].join(",")
            }),


            self.max_concurrent_jobs.as_ref().map(|max_concurrent_jobs| {
                [
                    "maxConcurrentJobs".to_string(),
                    max_concurrent_jobs.to_string(),
                ].join(",")
            }),


            self.included_storage.as_ref().map(|included_storage| {
                [
                    "includedStorage".to_string(),
                    included_storage.to_string(),
                ].join(",")
            }),


            self.per_gb_rate.as_ref().map(|per_gb_rate| {
                [
                    "perGbRate".to_string(),
                    per_gb_rate.to_string(),
                ].join(",")
            }),


            self.advanced_filtering_enabled.as_ref().map(|advanced_filtering_enabled| {
                [
                    "advancedFilteringEnabled".to_string(),
                    advanced_filtering_enabled.to_string(),
                ].join(",")
            }),


            self.priority_support_enabled.as_ref().map(|priority_support_enabled| {
                [
                    "prioritySupportEnabled".to_string(),
                    priority_support_enabled.to_string(),
                ].join(",")
            }),


            self.custom_exports_enabled.as_ref().map(|custom_exports_enabled| {
                [
                    "customExportsEnabled".to_string(),
                    custom_exports_enabled.to_string(),
                ].join(",")
            }),


            self.api_access_enabled.as_ref().map(|api_access_enabled| {
                [
                    "apiAccessEnabled".to_string(),
                    api_access_enabled.to_string(),
                ].join(",")
            }),


            self.custom_proxies_enabled.as_ref().map(|custom_proxies_enabled| {
                [
                    "customProxiesEnabled".to_string(),
                    custom_proxies_enabled.to_string(),
                ].join(",")
            }),


            self.advanced_analytics_enabled.as_ref().map(|advanced_analytics_enabled| {
                [
                    "advancedAnalyticsEnabled".to_string(),
                    advanced_analytics_enabled.to_string(),
                ].join(",")
            }),


            self.retention_days.as_ref().map(|retention_days| {
                [
                    "retentionDays".to_string(),
                    retention_days.to_string(),
                ].join(",")
            }),


            self.max_results_per_job.as_ref().map(|max_results_per_job| {
                [
                    "maxResultsPerJob".to_string(),
                    max_results_per_job.to_string(),
                ].join(",")
            }),

            // Skipping currentPeriodStart in query parameter serialization

            // Skipping currentPeriodEnd in query parameter serialization


            self.current_period_usage.as_ref().map(|current_period_usage| {
                [
                    "currentPeriodUsage".to_string(),
                    current_period_usage.to_string(),
                ].join(",")
            }),


            self.currency.as_ref().map(|currency| {
                [
                    "currency".to_string(),
                    currency.to_string(),
                ].join(",")
            }),


            self.base_price.as_ref().map(|base_price| {
                [
                    "basePrice".to_string(),
                    base_price.to_string(),
                ].join(",")
            }),

            // Skipping billingInterval in query parameter serialization


            self.auto_renew.as_ref().map(|auto_renew| {
                [
                    "autoRenew".to_string(),
                    auto_renew.to_string(),
                ].join(",")
            }),

            // Skipping paymentStatus in query parameter serialization


            self.is_trial.as_ref().map(|is_trial| {
                [
                    "isTrial".to_string(),
                    is_trial.to_string(),
                ].join(",")
            }),

            // Skipping trialStart in query parameter serialization

            // Skipping trialEnd in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping canceledAt in query parameter serialization

            // Skipping endedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Subscription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Subscription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub stripe_customer_id: Vec<String>,
            pub stripe_subscription_id: Vec<String>,
            pub stripe_price_id: Vec<String>,
            pub stripe_product_id: Vec<String>,
            pub plan_tier: Vec<models::PlanTier>,
            pub billing_mode: Vec<models::BillingMode>,
            pub included_jobs: Vec<i32>,
            pub per_job_rate: Vec<f32>,
            pub max_concurrent_jobs: Vec<i32>,
            pub included_storage: Vec<String>,
            pub per_gb_rate: Vec<f32>,
            pub advanced_filtering_enabled: Vec<bool>,
            pub priority_support_enabled: Vec<bool>,
            pub custom_exports_enabled: Vec<bool>,
            pub api_access_enabled: Vec<bool>,
            pub custom_proxies_enabled: Vec<bool>,
            pub advanced_analytics_enabled: Vec<bool>,
            pub retention_days: Vec<i32>,
            pub max_results_per_job: Vec<i32>,
            pub current_period_start: Vec<chrono::DateTime::<chrono::Utc>>,
            pub current_period_end: Vec<chrono::DateTime::<chrono::Utc>>,
            pub current_period_usage: Vec<f32>,
            pub currency: Vec<String>,
            pub base_price: Vec<f32>,
            pub billing_interval: Vec<models::Interval>,
            pub auto_renew: Vec<bool>,
            pub payment_status: Vec<models::PaymentStatus>,
            pub is_trial: Vec<bool>,
            pub trial_start: Vec<chrono::DateTime::<chrono::Utc>>,
            pub trial_end: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub canceled_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub ended_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Subscription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stripeCustomerId" => intermediate_rep.stripe_customer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stripeSubscriptionId" => intermediate_rep.stripe_subscription_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stripePriceId" => intermediate_rep.stripe_price_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stripeProductId" => intermediate_rep.stripe_product_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planTier" => intermediate_rep.plan_tier.push(<models::PlanTier as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billingMode" => intermediate_rep.billing_mode.push(<models::BillingMode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "includedJobs" => intermediate_rep.included_jobs.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "perJobRate" => intermediate_rep.per_job_rate.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxConcurrentJobs" => intermediate_rep.max_concurrent_jobs.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "includedStorage" => intermediate_rep.included_storage.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "perGbRate" => intermediate_rep.per_gb_rate.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "advancedFilteringEnabled" => intermediate_rep.advanced_filtering_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prioritySupportEnabled" => intermediate_rep.priority_support_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "customExportsEnabled" => intermediate_rep.custom_exports_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apiAccessEnabled" => intermediate_rep.api_access_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "customProxiesEnabled" => intermediate_rep.custom_proxies_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "advancedAnalyticsEnabled" => intermediate_rep.advanced_analytics_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retentionDays" => intermediate_rep.retention_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxResultsPerJob" => intermediate_rep.max_results_per_job.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentPeriodStart" => intermediate_rep.current_period_start.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentPeriodEnd" => intermediate_rep.current_period_end.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentPeriodUsage" => intermediate_rep.current_period_usage.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "basePrice" => intermediate_rep.base_price.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billingInterval" => intermediate_rep.billing_interval.push(<models::Interval as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "autoRenew" => intermediate_rep.auto_renew.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentStatus" => intermediate_rep.payment_status.push(<models::PaymentStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isTrial" => intermediate_rep.is_trial.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "trialStart" => intermediate_rep.trial_start.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "trialEnd" => intermediate_rep.trial_end.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "canceledAt" => intermediate_rep.canceled_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endedAt" => intermediate_rep.ended_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Subscription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Subscription {
            id: intermediate_rep.id.into_iter().next(),
            stripe_customer_id: intermediate_rep.stripe_customer_id.into_iter().next(),
            stripe_subscription_id: intermediate_rep.stripe_subscription_id.into_iter().next(),
            stripe_price_id: intermediate_rep.stripe_price_id.into_iter().next(),
            stripe_product_id: intermediate_rep.stripe_product_id.into_iter().next(),
            plan_tier: intermediate_rep.plan_tier.into_iter().next(),
            billing_mode: intermediate_rep.billing_mode.into_iter().next(),
            included_jobs: intermediate_rep.included_jobs.into_iter().next(),
            per_job_rate: intermediate_rep.per_job_rate.into_iter().next(),
            max_concurrent_jobs: intermediate_rep.max_concurrent_jobs.into_iter().next(),
            included_storage: intermediate_rep.included_storage.into_iter().next(),
            per_gb_rate: intermediate_rep.per_gb_rate.into_iter().next(),
            advanced_filtering_enabled: intermediate_rep.advanced_filtering_enabled.into_iter().next(),
            priority_support_enabled: intermediate_rep.priority_support_enabled.into_iter().next(),
            custom_exports_enabled: intermediate_rep.custom_exports_enabled.into_iter().next(),
            api_access_enabled: intermediate_rep.api_access_enabled.into_iter().next(),
            custom_proxies_enabled: intermediate_rep.custom_proxies_enabled.into_iter().next(),
            advanced_analytics_enabled: intermediate_rep.advanced_analytics_enabled.into_iter().next(),
            retention_days: intermediate_rep.retention_days.into_iter().next(),
            max_results_per_job: intermediate_rep.max_results_per_job.into_iter().next(),
            current_period_start: intermediate_rep.current_period_start.into_iter().next(),
            current_period_end: intermediate_rep.current_period_end.into_iter().next(),
            current_period_usage: intermediate_rep.current_period_usage.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            base_price: intermediate_rep.base_price.into_iter().next(),
            billing_interval: intermediate_rep.billing_interval.into_iter().next(),
            auto_renew: intermediate_rep.auto_renew.into_iter().next(),
            payment_status: intermediate_rep.payment_status.into_iter().next(),
            is_trial: intermediate_rep.is_trial.into_iter().next(),
            trial_start: intermediate_rep.trial_start.into_iter().next(),
            trial_end: intermediate_rep.trial_end.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            canceled_at: intermediate_rep.canceled_at.into_iter().next(),
            ended_at: intermediate_rep.ended_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Subscription> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Subscription>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Subscription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Subscription - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Subscription> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Subscription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Subscription - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Suggestions {
    #[serde(rename = "similarResources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub similar_resources: Option<Vec<String>>,

    #[serde(rename = "alternativePaths")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alternative_paths: Option<Vec<String>>,

    #[serde(rename = "documentationUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,

    #[serde(rename = "hints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hints: Option<std::collections::HashMap<String, String>>,

}


impl Suggestions {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Suggestions {
        Suggestions {
            similar_resources: None,
            alternative_paths: None,
            documentation_url: None,
            hints: None,
        }
    }
}

/// Converts the Suggestions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Suggestions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.similar_resources.as_ref().map(|similar_resources| {
                [
                    "similarResources".to_string(),
                    similar_resources.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.alternative_paths.as_ref().map(|alternative_paths| {
                [
                    "alternativePaths".to_string(),
                    alternative_paths.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.documentation_url.as_ref().map(|documentation_url| {
                [
                    "documentationUrl".to_string(),
                    documentation_url.to_string(),
                ].join(",")
            }),

            // Skipping hints in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Suggestions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Suggestions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub similar_resources: Vec<Vec<String>>,
            pub alternative_paths: Vec<Vec<String>>,
            pub documentation_url: Vec<String>,
            pub hints: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Suggestions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "similarResources" => return std::result::Result::Err("Parsing a container in this style is not supported in Suggestions".to_string()),
                    "alternativePaths" => return std::result::Result::Err("Parsing a container in this style is not supported in Suggestions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "documentationUrl" => intermediate_rep.documentation_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hints" => return std::result::Result::Err("Parsing a container in this style is not supported in Suggestions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Suggestions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Suggestions {
            similar_resources: intermediate_rep.similar_resources.into_iter().next(),
            alternative_paths: intermediate_rep.alternative_paths.into_iter().next(),
            documentation_url: intermediate_rep.documentation_url.into_iter().next(),
            hints: intermediate_rep.hints.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Suggestions> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Suggestions>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Suggestions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Suggestions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Suggestions> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Suggestions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Suggestions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TemplateType {
    #[serde(rename = "TEMPLATE_TYPE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "TEMPLATE_TYPE_STANDARD")]
    Standard,
    #[serde(rename = "TEMPLATE_TYPE_SMART")]
    Smart,
    #[serde(rename = "TEMPLATE_TYPE_ADAPTIVE")]
    Adaptive,
    #[serde(rename = "TEMPLATE_TYPE_AI_GENERATED")]
    AiGenerated,
}

impl std::fmt::Display for TemplateType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TemplateType::Unspecified => write!(f, "TEMPLATE_TYPE_UNSPECIFIED"),
            TemplateType::Standard => write!(f, "TEMPLATE_TYPE_STANDARD"),
            TemplateType::Smart => write!(f, "TEMPLATE_TYPE_SMART"),
            TemplateType::Adaptive => write!(f, "TEMPLATE_TYPE_ADAPTIVE"),
            TemplateType::AiGenerated => write!(f, "TEMPLATE_TYPE_AI_GENERATED"),
        }
    }
}

impl std::str::FromStr for TemplateType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TEMPLATE_TYPE_UNSPECIFIED" => std::result::Result::Ok(TemplateType::Unspecified),
            "TEMPLATE_TYPE_STANDARD" => std::result::Result::Ok(TemplateType::Standard),
            "TEMPLATE_TYPE_SMART" => std::result::Result::Ok(TemplateType::Smart),
            "TEMPLATE_TYPE_ADAPTIVE" => std::result::Result::Ok(TemplateType::Adaptive),
            "TEMPLATE_TYPE_AI_GENERATED" => std::result::Result::Ok(TemplateType::AiGenerated),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateVariable {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "variableType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variable_type: Option<String>,

    #[serde(rename = "defaultValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_value: Option<String>,

    #[serde(rename = "isRequired")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_required: Option<bool>,

    #[serde(rename = "validationRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub validation_rules: Option<String>,

    #[serde(rename = "dataSource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_source: Option<String>,

    #[serde(rename = "aiExtractionRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ai_extraction_rules: Option<String>,

    #[serde(rename = "alternatives")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alternatives: Option<Vec<String>>,

    #[serde(rename = "templateId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_id: Option<String>,

}


impl TemplateVariable {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TemplateVariable {
        TemplateVariable {
            id: None,
            name: None,
            description: None,
            variable_type: None,
            default_value: None,
            is_required: None,
            validation_rules: None,
            data_source: None,
            ai_extraction_rules: None,
            alternatives: None,
            template_id: None,
        }
    }
}

/// Converts the TemplateVariable value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TemplateVariable {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.variable_type.as_ref().map(|variable_type| {
                [
                    "variableType".to_string(),
                    variable_type.to_string(),
                ].join(",")
            }),


            self.default_value.as_ref().map(|default_value| {
                [
                    "defaultValue".to_string(),
                    default_value.to_string(),
                ].join(",")
            }),


            self.is_required.as_ref().map(|is_required| {
                [
                    "isRequired".to_string(),
                    is_required.to_string(),
                ].join(",")
            }),


            self.validation_rules.as_ref().map(|validation_rules| {
                [
                    "validationRules".to_string(),
                    validation_rules.to_string(),
                ].join(",")
            }),


            self.data_source.as_ref().map(|data_source| {
                [
                    "dataSource".to_string(),
                    data_source.to_string(),
                ].join(",")
            }),


            self.ai_extraction_rules.as_ref().map(|ai_extraction_rules| {
                [
                    "aiExtractionRules".to_string(),
                    ai_extraction_rules.to_string(),
                ].join(",")
            }),


            self.alternatives.as_ref().map(|alternatives| {
                [
                    "alternatives".to_string(),
                    alternatives.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.template_id.as_ref().map(|template_id| {
                [
                    "templateId".to_string(),
                    template_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateVariable value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateVariable {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub variable_type: Vec<String>,
            pub default_value: Vec<String>,
            pub is_required: Vec<bool>,
            pub validation_rules: Vec<String>,
            pub data_source: Vec<String>,
            pub ai_extraction_rules: Vec<String>,
            pub alternatives: Vec<Vec<String>>,
            pub template_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateVariable".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variableType" => intermediate_rep.variable_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "defaultValue" => intermediate_rep.default_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isRequired" => intermediate_rep.is_required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validationRules" => intermediate_rep.validation_rules.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataSource" => intermediate_rep.data_source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "aiExtractionRules" => intermediate_rep.ai_extraction_rules.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "alternatives" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplateVariable".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "templateId" => intermediate_rep.template_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateVariable".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateVariable {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            variable_type: intermediate_rep.variable_type.into_iter().next(),
            default_value: intermediate_rep.default_value.into_iter().next(),
            is_required: intermediate_rep.is_required.into_iter().next(),
            validation_rules: intermediate_rep.validation_rules.into_iter().next(),
            data_source: intermediate_rep.data_source.into_iter().next(),
            ai_extraction_rules: intermediate_rep.ai_extraction_rules.into_iter().next(),
            alternatives: intermediate_rep.alternatives.into_iter().next(),
            template_id: intermediate_rep.template_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateVariable> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateVariable>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateVariable>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateVariable - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TemplateVariable> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateVariable as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateVariable - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateVersion {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "templateId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_id: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

    #[serde(rename = "baseContent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_content: Option<String>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "authorId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_id: Option<String>,

    #[serde(rename = "changeDescription")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_description: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl TemplateVersion {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TemplateVersion {
        TemplateVersion {
            id: None,
            template_id: None,
            version: None,
            base_content: None,
            metadata: None,
            author_id: None,
            change_description: None,
            created_at: None,
        }
    }
}

/// Converts the TemplateVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TemplateVersion {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.template_id.as_ref().map(|template_id| {
                [
                    "templateId".to_string(),
                    template_id.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),


            self.base_content.as_ref().map(|base_content| {
                [
                    "baseContent".to_string(),
                    base_content.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.author_id.as_ref().map(|author_id| {
                [
                    "authorId".to_string(),
                    author_id.to_string(),
                ].join(",")
            }),


            self.change_description.as_ref().map(|change_description| {
                [
                    "changeDescription".to_string(),
                    change_description.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub template_id: Vec<String>,
            pub version: Vec<String>,
            pub base_content: Vec<String>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub author_id: Vec<String>,
            pub change_description: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "templateId" => intermediate_rep.template_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baseContent" => intermediate_rep.base_content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplateVersion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "authorId" => intermediate_rep.author_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changeDescription" => intermediate_rep.change_description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateVersion {
            id: intermediate_rep.id.into_iter().next(),
            template_id: intermediate_rep.template_id.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
            base_content: intermediate_rep.base_content.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            author_id: intermediate_rep.author_id.into_iter().next(),
            change_description: intermediate_rep.change_description.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateVersion> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateVersion>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TemplateVersion> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Key features: - Resource isolation - Independent configuration - Usage tracking - Service subscriptions
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tenant {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "displayName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "organization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<models::Organization>,

    #[serde(rename = "apiBaseUrl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_base_url: Option<String>,

    #[serde(rename = "environmentVariables")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_variables: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "allowedOrigins")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_origins: Option<Vec<String>>,

    #[serde(rename = "storageQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_quota: Option<String>,

    #[serde(rename = "monthlyRequestLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_request_limit: Option<String>,

    #[serde(rename = "maxConcurrentJobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_concurrent_jobs: Option<i32>,

    #[serde(rename = "enableCaching")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_caching: Option<bool>,

    #[serde(rename = "enableRateLimiting")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_rate_limiting: Option<bool>,

    #[serde(rename = "enableRequestLogging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_request_logging: Option<bool>,

    #[serde(rename = "accounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accounts: Option<Vec<models::Account>>,

    #[serde(rename = "apiKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_keys: Option<Vec<models::TenantApiKey>>,

    #[serde(rename = "totalRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_requests: Option<String>,

    #[serde(rename = "totalStorageUsed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_storage_used: Option<String>,

    #[serde(rename = "averageResponseTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average_response_time: Option<f32>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::V1PeriodStatus>,

}


impl Tenant {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Tenant {
        Tenant {
            id: None,
            name: None,
            display_name: None,
            description: None,
            organization: None,
            api_base_url: None,
            environment_variables: None,
            allowed_origins: None,
            storage_quota: None,
            monthly_request_limit: None,
            max_concurrent_jobs: None,
            enable_caching: None,
            enable_rate_limiting: None,
            enable_request_logging: None,
            accounts: None,
            api_keys: None,
            total_requests: None,
            total_storage_used: None,
            average_response_time: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            status: None,
        }
    }
}

/// Converts the Tenant value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tenant {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.display_name.as_ref().map(|display_name| {
                [
                    "displayName".to_string(),
                    display_name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping organization in query parameter serialization


            self.api_base_url.as_ref().map(|api_base_url| {
                [
                    "apiBaseUrl".to_string(),
                    api_base_url.to_string(),
                ].join(",")
            }),

            // Skipping environmentVariables in query parameter serialization


            self.allowed_origins.as_ref().map(|allowed_origins| {
                [
                    "allowedOrigins".to_string(),
                    allowed_origins.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.storage_quota.as_ref().map(|storage_quota| {
                [
                    "storageQuota".to_string(),
                    storage_quota.to_string(),
                ].join(",")
            }),


            self.monthly_request_limit.as_ref().map(|monthly_request_limit| {
                [
                    "monthlyRequestLimit".to_string(),
                    monthly_request_limit.to_string(),
                ].join(",")
            }),


            self.max_concurrent_jobs.as_ref().map(|max_concurrent_jobs| {
                [
                    "maxConcurrentJobs".to_string(),
                    max_concurrent_jobs.to_string(),
                ].join(",")
            }),


            self.enable_caching.as_ref().map(|enable_caching| {
                [
                    "enableCaching".to_string(),
                    enable_caching.to_string(),
                ].join(",")
            }),


            self.enable_rate_limiting.as_ref().map(|enable_rate_limiting| {
                [
                    "enableRateLimiting".to_string(),
                    enable_rate_limiting.to_string(),
                ].join(",")
            }),


            self.enable_request_logging.as_ref().map(|enable_request_logging| {
                [
                    "enableRequestLogging".to_string(),
                    enable_request_logging.to_string(),
                ].join(",")
            }),

            // Skipping accounts in query parameter serialization

            // Skipping apiKeys in query parameter serialization


            self.total_requests.as_ref().map(|total_requests| {
                [
                    "totalRequests".to_string(),
                    total_requests.to_string(),
                ].join(",")
            }),


            self.total_storage_used.as_ref().map(|total_storage_used| {
                [
                    "totalStorageUsed".to_string(),
                    total_storage_used.to_string(),
                ].join(",")
            }),


            self.average_response_time.as_ref().map(|average_response_time| {
                [
                    "averageResponseTime".to_string(),
                    average_response_time.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tenant value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tenant {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub display_name: Vec<String>,
            pub description: Vec<String>,
            pub organization: Vec<models::Organization>,
            pub api_base_url: Vec<String>,
            pub environment_variables: Vec<std::collections::HashMap<String, String>>,
            pub allowed_origins: Vec<Vec<String>>,
            pub storage_quota: Vec<String>,
            pub monthly_request_limit: Vec<String>,
            pub max_concurrent_jobs: Vec<i32>,
            pub enable_caching: Vec<bool>,
            pub enable_rate_limiting: Vec<bool>,
            pub enable_request_logging: Vec<bool>,
            pub accounts: Vec<Vec<models::Account>>,
            pub api_keys: Vec<Vec<models::TenantApiKey>>,
            pub total_requests: Vec<String>,
            pub total_storage_used: Vec<String>,
            pub average_response_time: Vec<f32>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::V1PeriodStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Tenant".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "displayName" => intermediate_rep.display_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organization" => intermediate_rep.organization.push(<models::Organization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apiBaseUrl" => intermediate_rep.api_base_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environmentVariables" => return std::result::Result::Err("Parsing a container in this style is not supported in Tenant".to_string()),
                    "allowedOrigins" => return std::result::Result::Err("Parsing a container in this style is not supported in Tenant".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "storageQuota" => intermediate_rep.storage_quota.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "monthlyRequestLimit" => intermediate_rep.monthly_request_limit.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxConcurrentJobs" => intermediate_rep.max_concurrent_jobs.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enableCaching" => intermediate_rep.enable_caching.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enableRateLimiting" => intermediate_rep.enable_rate_limiting.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enableRequestLogging" => intermediate_rep.enable_request_logging.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "accounts" => return std::result::Result::Err("Parsing a container in this style is not supported in Tenant".to_string()),
                    "apiKeys" => return std::result::Result::Err("Parsing a container in this style is not supported in Tenant".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "totalRequests" => intermediate_rep.total_requests.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalStorageUsed" => intermediate_rep.total_storage_used.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageResponseTime" => intermediate_rep.average_response_time.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::V1PeriodStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Tenant".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tenant {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            display_name: intermediate_rep.display_name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            organization: intermediate_rep.organization.into_iter().next(),
            api_base_url: intermediate_rep.api_base_url.into_iter().next(),
            environment_variables: intermediate_rep.environment_variables.into_iter().next(),
            allowed_origins: intermediate_rep.allowed_origins.into_iter().next(),
            storage_quota: intermediate_rep.storage_quota.into_iter().next(),
            monthly_request_limit: intermediate_rep.monthly_request_limit.into_iter().next(),
            max_concurrent_jobs: intermediate_rep.max_concurrent_jobs.into_iter().next(),
            enable_caching: intermediate_rep.enable_caching.into_iter().next(),
            enable_rate_limiting: intermediate_rep.enable_rate_limiting.into_iter().next(),
            enable_request_logging: intermediate_rep.enable_request_logging.into_iter().next(),
            accounts: intermediate_rep.accounts.into_iter().next(),
            api_keys: intermediate_rep.api_keys.into_iter().next(),
            total_requests: intermediate_rep.total_requests.into_iter().next(),
            total_storage_used: intermediate_rep.total_storage_used.into_iter().next(),
            average_response_time: intermediate_rep.average_response_time.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tenant> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tenant>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Tenant>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Tenant - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tenant> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Tenant as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Tenant - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TenantApiKey {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "keyHash")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_hash: Option<String>,

    #[serde(rename = "keyPrefix")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_prefix: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::V1PeriodStatus>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<models::TenantApiKeyScope>>,

    #[serde(rename = "maxUses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_uses: Option<i32>,

    #[serde(rename = "allowedIps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_ips: Option<Vec<String>>,

    #[serde(rename = "useCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_count: Option<i32>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl TenantApiKey {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TenantApiKey {
        TenantApiKey {
            id: None,
            key_hash: None,
            key_prefix: None,
            name: None,
            description: None,
            status: None,
            scopes: None,
            max_uses: None,
            allowed_ips: None,
            use_count: None,
            expires_at: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
        }
    }
}

/// Converts the TenantApiKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TenantApiKey {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.key_hash.as_ref().map(|key_hash| {
                [
                    "keyHash".to_string(),
                    key_hash.to_string(),
                ].join(",")
            }),


            self.key_prefix.as_ref().map(|key_prefix| {
                [
                    "keyPrefix".to_string(),
                    key_prefix.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping scopes in query parameter serialization


            self.max_uses.as_ref().map(|max_uses| {
                [
                    "maxUses".to_string(),
                    max_uses.to_string(),
                ].join(",")
            }),


            self.allowed_ips.as_ref().map(|allowed_ips| {
                [
                    "allowedIps".to_string(),
                    allowed_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.use_count.as_ref().map(|use_count| {
                [
                    "useCount".to_string(),
                    use_count.to_string(),
                ].join(",")
            }),

            // Skipping expiresAt in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TenantApiKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TenantApiKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub key_hash: Vec<String>,
            pub key_prefix: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub status: Vec<models::V1PeriodStatus>,
            pub scopes: Vec<Vec<models::TenantApiKeyScope>>,
            pub max_uses: Vec<i32>,
            pub allowed_ips: Vec<Vec<String>>,
            pub use_count: Vec<i32>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TenantApiKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyHash" => intermediate_rep.key_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyPrefix" => intermediate_rep.key_prefix.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::V1PeriodStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "scopes" => return std::result::Result::Err("Parsing a container in this style is not supported in TenantApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "maxUses" => intermediate_rep.max_uses.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedIps" => return std::result::Result::Err("Parsing a container in this style is not supported in TenantApiKey".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "useCount" => intermediate_rep.use_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TenantApiKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TenantApiKey {
            id: intermediate_rep.id.into_iter().next(),
            key_hash: intermediate_rep.key_hash.into_iter().next(),
            key_prefix: intermediate_rep.key_prefix.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
            max_uses: intermediate_rep.max_uses.into_iter().next(),
            allowed_ips: intermediate_rep.allowed_ips.into_iter().next(),
            use_count: intermediate_rep.use_count.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TenantApiKey> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TenantApiKey>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TenantApiKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TenantApiKey - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TenantApiKey> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TenantApiKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TenantApiKey - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Usage: - Multiple scopes can be assigned to a single key - Scopes follow a hierarchical pattern - More specific scopes take precedence over general ones   - TENANT_API_KEY_SCOPE_UNSPECIFIED: Default state, should not be used explicitly  - TENANT_API_KEY_SCOPE_READ_JOBS: Read-only access scopes  View scraping jobs  - TENANT_API_KEY_SCOPE_READ_LEADS: View scraped leads  - TENANT_API_KEY_SCOPE_READ_WORKFLOWS: View workflow configurations  - TENANT_API_KEY_SCOPE_READ_ANALYTICS: View analytics and metrics  - TENANT_API_KEY_SCOPE_READ_SETTINGS: View tenant settings  - TENANT_API_KEY_SCOPE_WRITE_JOBS: Write access scopes  Create/modify scraping jobs  - TENANT_API_KEY_SCOPE_WRITE_LEADS: Modify lead data  - TENANT_API_KEY_SCOPE_WRITE_WORKFLOWS: Create/modify workflows  - TENANT_API_KEY_SCOPE_WRITE_SETTINGS: Modify tenant settings  - TENANT_API_KEY_SCOPE_DELETE_JOBS: Delete access scopes  Delete scraping jobs  - TENANT_API_KEY_SCOPE_DELETE_LEADS: Delete lead data  - TENANT_API_KEY_SCOPE_DELETE_WORKFLOWS: Delete workflows  - TENANT_API_KEY_SCOPE_EXPORT_DATA: Special access scopes  Export data in various formats  - TENANT_API_KEY_SCOPE_MANAGE_KEYS: Manage other API keys  - TENANT_API_KEY_SCOPE_BILLING_READ: View billing information  - TENANT_API_KEY_SCOPE_BILLING_WRITE: Modify billing settings  - TENANT_API_KEY_SCOPE_ADMIN: Full access scopes  Full administrative access
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TenantApiKeyScope {
    #[serde(rename = "TENANT_API_KEY_SCOPE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "TENANT_API_KEY_SCOPE_READ_JOBS")]
    ReadJobs,
    #[serde(rename = "TENANT_API_KEY_SCOPE_READ_LEADS")]
    ReadLeads,
    #[serde(rename = "TENANT_API_KEY_SCOPE_READ_WORKFLOWS")]
    ReadWorkflows,
    #[serde(rename = "TENANT_API_KEY_SCOPE_READ_ANALYTICS")]
    ReadAnalytics,
    #[serde(rename = "TENANT_API_KEY_SCOPE_READ_SETTINGS")]
    ReadSettings,
    #[serde(rename = "TENANT_API_KEY_SCOPE_WRITE_JOBS")]
    WriteJobs,
    #[serde(rename = "TENANT_API_KEY_SCOPE_WRITE_LEADS")]
    WriteLeads,
    #[serde(rename = "TENANT_API_KEY_SCOPE_WRITE_WORKFLOWS")]
    WriteWorkflows,
    #[serde(rename = "TENANT_API_KEY_SCOPE_WRITE_SETTINGS")]
    WriteSettings,
    #[serde(rename = "TENANT_API_KEY_SCOPE_DELETE_JOBS")]
    DeleteJobs,
    #[serde(rename = "TENANT_API_KEY_SCOPE_DELETE_LEADS")]
    DeleteLeads,
    #[serde(rename = "TENANT_API_KEY_SCOPE_DELETE_WORKFLOWS")]
    DeleteWorkflows,
    #[serde(rename = "TENANT_API_KEY_SCOPE_EXPORT_DATA")]
    ExportData,
    #[serde(rename = "TENANT_API_KEY_SCOPE_MANAGE_KEYS")]
    ManageKeys,
    #[serde(rename = "TENANT_API_KEY_SCOPE_BILLING_READ")]
    BillingRead,
    #[serde(rename = "TENANT_API_KEY_SCOPE_BILLING_WRITE")]
    BillingWrite,
    #[serde(rename = "TENANT_API_KEY_SCOPE_ADMIN")]
    Admin,
}

impl std::fmt::Display for TenantApiKeyScope {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TenantApiKeyScope::Unspecified => write!(f, "TENANT_API_KEY_SCOPE_UNSPECIFIED"),
            TenantApiKeyScope::ReadJobs => write!(f, "TENANT_API_KEY_SCOPE_READ_JOBS"),
            TenantApiKeyScope::ReadLeads => write!(f, "TENANT_API_KEY_SCOPE_READ_LEADS"),
            TenantApiKeyScope::ReadWorkflows => write!(f, "TENANT_API_KEY_SCOPE_READ_WORKFLOWS"),
            TenantApiKeyScope::ReadAnalytics => write!(f, "TENANT_API_KEY_SCOPE_READ_ANALYTICS"),
            TenantApiKeyScope::ReadSettings => write!(f, "TENANT_API_KEY_SCOPE_READ_SETTINGS"),
            TenantApiKeyScope::WriteJobs => write!(f, "TENANT_API_KEY_SCOPE_WRITE_JOBS"),
            TenantApiKeyScope::WriteLeads => write!(f, "TENANT_API_KEY_SCOPE_WRITE_LEADS"),
            TenantApiKeyScope::WriteWorkflows => write!(f, "TENANT_API_KEY_SCOPE_WRITE_WORKFLOWS"),
            TenantApiKeyScope::WriteSettings => write!(f, "TENANT_API_KEY_SCOPE_WRITE_SETTINGS"),
            TenantApiKeyScope::DeleteJobs => write!(f, "TENANT_API_KEY_SCOPE_DELETE_JOBS"),
            TenantApiKeyScope::DeleteLeads => write!(f, "TENANT_API_KEY_SCOPE_DELETE_LEADS"),
            TenantApiKeyScope::DeleteWorkflows => write!(f, "TENANT_API_KEY_SCOPE_DELETE_WORKFLOWS"),
            TenantApiKeyScope::ExportData => write!(f, "TENANT_API_KEY_SCOPE_EXPORT_DATA"),
            TenantApiKeyScope::ManageKeys => write!(f, "TENANT_API_KEY_SCOPE_MANAGE_KEYS"),
            TenantApiKeyScope::BillingRead => write!(f, "TENANT_API_KEY_SCOPE_BILLING_READ"),
            TenantApiKeyScope::BillingWrite => write!(f, "TENANT_API_KEY_SCOPE_BILLING_WRITE"),
            TenantApiKeyScope::Admin => write!(f, "TENANT_API_KEY_SCOPE_ADMIN"),
        }
    }
}

impl std::str::FromStr for TenantApiKeyScope {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TENANT_API_KEY_SCOPE_UNSPECIFIED" => std::result::Result::Ok(TenantApiKeyScope::Unspecified),
            "TENANT_API_KEY_SCOPE_READ_JOBS" => std::result::Result::Ok(TenantApiKeyScope::ReadJobs),
            "TENANT_API_KEY_SCOPE_READ_LEADS" => std::result::Result::Ok(TenantApiKeyScope::ReadLeads),
            "TENANT_API_KEY_SCOPE_READ_WORKFLOWS" => std::result::Result::Ok(TenantApiKeyScope::ReadWorkflows),
            "TENANT_API_KEY_SCOPE_READ_ANALYTICS" => std::result::Result::Ok(TenantApiKeyScope::ReadAnalytics),
            "TENANT_API_KEY_SCOPE_READ_SETTINGS" => std::result::Result::Ok(TenantApiKeyScope::ReadSettings),
            "TENANT_API_KEY_SCOPE_WRITE_JOBS" => std::result::Result::Ok(TenantApiKeyScope::WriteJobs),
            "TENANT_API_KEY_SCOPE_WRITE_LEADS" => std::result::Result::Ok(TenantApiKeyScope::WriteLeads),
            "TENANT_API_KEY_SCOPE_WRITE_WORKFLOWS" => std::result::Result::Ok(TenantApiKeyScope::WriteWorkflows),
            "TENANT_API_KEY_SCOPE_WRITE_SETTINGS" => std::result::Result::Ok(TenantApiKeyScope::WriteSettings),
            "TENANT_API_KEY_SCOPE_DELETE_JOBS" => std::result::Result::Ok(TenantApiKeyScope::DeleteJobs),
            "TENANT_API_KEY_SCOPE_DELETE_LEADS" => std::result::Result::Ok(TenantApiKeyScope::DeleteLeads),
            "TENANT_API_KEY_SCOPE_DELETE_WORKFLOWS" => std::result::Result::Ok(TenantApiKeyScope::DeleteWorkflows),
            "TENANT_API_KEY_SCOPE_EXPORT_DATA" => std::result::Result::Ok(TenantApiKeyScope::ExportData),
            "TENANT_API_KEY_SCOPE_MANAGE_KEYS" => std::result::Result::Ok(TenantApiKeyScope::ManageKeys),
            "TENANT_API_KEY_SCOPE_BILLING_READ" => std::result::Result::Ok(TenantApiKeyScope::BillingRead),
            "TENANT_API_KEY_SCOPE_BILLING_WRITE" => std::result::Result::Ok(TenantApiKeyScope::BillingWrite),
            "TENANT_API_KEY_SCOPE_ADMIN" => std::result::Result::Ok(TenantApiKeyScope::Admin),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Timezone {
    #[serde(rename = "TIMEZONE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "TIMEZONE_UTC")]
    Utc,
    #[serde(rename = "TIMEZONE_EST")]
    Est,
    #[serde(rename = "TIMEZONE_CST")]
    Cst,
    #[serde(rename = "TIMEZONE_MST")]
    Mst,
    #[serde(rename = "TIMEZONE_PST")]
    Pst,
    #[serde(rename = "TIMEZONE_GMT")]
    Gmt,
    #[serde(rename = "TIMEZONE_CET")]
    Cet,
    #[serde(rename = "TIMEZONE_IST")]
    Ist,
    #[serde(rename = "TIMEZONE_JST")]
    Jst,
    #[serde(rename = "TIMEZONE_AEST")]
    Aest,
}

impl std::fmt::Display for Timezone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Timezone::Unspecified => write!(f, "TIMEZONE_UNSPECIFIED"),
            Timezone::Utc => write!(f, "TIMEZONE_UTC"),
            Timezone::Est => write!(f, "TIMEZONE_EST"),
            Timezone::Cst => write!(f, "TIMEZONE_CST"),
            Timezone::Mst => write!(f, "TIMEZONE_MST"),
            Timezone::Pst => write!(f, "TIMEZONE_PST"),
            Timezone::Gmt => write!(f, "TIMEZONE_GMT"),
            Timezone::Cet => write!(f, "TIMEZONE_CET"),
            Timezone::Ist => write!(f, "TIMEZONE_IST"),
            Timezone::Jst => write!(f, "TIMEZONE_JST"),
            Timezone::Aest => write!(f, "TIMEZONE_AEST"),
        }
    }
}

impl std::str::FromStr for Timezone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TIMEZONE_UNSPECIFIED" => std::result::Result::Ok(Timezone::Unspecified),
            "TIMEZONE_UTC" => std::result::Result::Ok(Timezone::Utc),
            "TIMEZONE_EST" => std::result::Result::Ok(Timezone::Est),
            "TIMEZONE_CST" => std::result::Result::Ok(Timezone::Cst),
            "TIMEZONE_MST" => std::result::Result::Ok(Timezone::Mst),
            "TIMEZONE_PST" => std::result::Result::Ok(Timezone::Pst),
            "TIMEZONE_GMT" => std::result::Result::Ok(Timezone::Gmt),
            "TIMEZONE_CET" => std::result::Result::Ok(Timezone::Cet),
            "TIMEZONE_IST" => std::result::Result::Ok(Timezone::Ist),
            "TIMEZONE_JST" => std::result::Result::Ok(Timezone::Jst),
            "TIMEZONE_AEST" => std::result::Result::Ok(Timezone::Aest),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TokenInfo {
    #[serde(rename = "tokenId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_id: Option<String>,

    #[serde(rename = "tokenType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_type: Option<String>,

    #[serde(rename = "expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiry: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "issuer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub issuer: Option<String>,

    #[serde(rename = "audiences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audiences: Option<Vec<String>>,

}


impl TokenInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TokenInfo {
        TokenInfo {
            token_id: None,
            token_type: None,
            expiry: None,
            issuer: None,
            audiences: None,
        }
    }
}

/// Converts the TokenInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TokenInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.token_id.as_ref().map(|token_id| {
                [
                    "tokenId".to_string(),
                    token_id.to_string(),
                ].join(",")
            }),


            self.token_type.as_ref().map(|token_type| {
                [
                    "tokenType".to_string(),
                    token_type.to_string(),
                ].join(",")
            }),

            // Skipping expiry in query parameter serialization


            self.issuer.as_ref().map(|issuer| {
                [
                    "issuer".to_string(),
                    issuer.to_string(),
                ].join(",")
            }),


            self.audiences.as_ref().map(|audiences| {
                [
                    "audiences".to_string(),
                    audiences.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TokenInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TokenInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub token_id: Vec<String>,
            pub token_type: Vec<String>,
            pub expiry: Vec<chrono::DateTime::<chrono::Utc>>,
            pub issuer: Vec<String>,
            pub audiences: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TokenInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tokenId" => intermediate_rep.token_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tokenType" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiry" => intermediate_rep.expiry.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "issuer" => intermediate_rep.issuer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "audiences" => return std::result::Result::Err("Parsing a container in this style is not supported in TokenInfo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TokenInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TokenInfo {
            token_id: intermediate_rep.token_id.into_iter().next(),
            token_type: intermediate_rep.token_type.into_iter().next(),
            expiry: intermediate_rep.expiry.into_iter().next(),
            issuer: intermediate_rep.issuer.into_iter().next(),
            audiences: intermediate_rep.audiences.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TokenInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TokenInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TokenInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TokenInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TokenInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TokenInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TokenInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Indicates that the server is unwilling to risk processing a request that might be replayed
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TooEarlyErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl TooEarlyErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TooEarlyErrorMessageResponse {
        TooEarlyErrorMessageResponse {
            code: None,
            message: None,
            error_response: None,
        }
    }
}

/// Converts the TooEarlyErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TooEarlyErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TooEarlyErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TooEarlyErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TooEarlyErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TooEarlyErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TooEarlyErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TooEarlyErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TooEarlyErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TooEarlyErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TooEarlyErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TooEarlyErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TooEarlyErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TooEarlyErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TriggerEvent {
    #[serde(rename = "TRIGGER_EVENT_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "TRIGGER_EVENT_JOB_STARTED")]
    JobStarted,
    #[serde(rename = "TRIGGER_EVENT_JOB_COMPLETED")]
    JobCompleted,
    #[serde(rename = "TRIGGER_EVENT_JOB_FAILED")]
    JobFailed,
    #[serde(rename = "TRIGGER_EVENT_LEAD_FOUND")]
    LeadFound,
    #[serde(rename = "TRIGGER_EVENT_QUOTA_EXCEEDED")]
    QuotaExceeded,
    #[serde(rename = "TRIGGER_EVENT_ERROR_THRESHOLD_REACHED")]
    ErrorThresholdReached,
    #[serde(rename = "TRIGGER_EVENT_RATE_LIMIT_REACHED")]
    RateLimitReached,
    #[serde(rename = "TRIGGER_EVENT_DATA_VALIDATION_FAILED")]
    DataValidationFailed,
    #[serde(rename = "TRIGGER_EVENT_NEW_PROXY_NEEDED")]
    NewProxyNeeded,
    #[serde(rename = "TRIGGER_EVENT_SCHEDULED_MAINTENANCE")]
    ScheduledMaintenance,
}

impl std::fmt::Display for TriggerEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TriggerEvent::Unspecified => write!(f, "TRIGGER_EVENT_UNSPECIFIED"),
            TriggerEvent::JobStarted => write!(f, "TRIGGER_EVENT_JOB_STARTED"),
            TriggerEvent::JobCompleted => write!(f, "TRIGGER_EVENT_JOB_COMPLETED"),
            TriggerEvent::JobFailed => write!(f, "TRIGGER_EVENT_JOB_FAILED"),
            TriggerEvent::LeadFound => write!(f, "TRIGGER_EVENT_LEAD_FOUND"),
            TriggerEvent::QuotaExceeded => write!(f, "TRIGGER_EVENT_QUOTA_EXCEEDED"),
            TriggerEvent::ErrorThresholdReached => write!(f, "TRIGGER_EVENT_ERROR_THRESHOLD_REACHED"),
            TriggerEvent::RateLimitReached => write!(f, "TRIGGER_EVENT_RATE_LIMIT_REACHED"),
            TriggerEvent::DataValidationFailed => write!(f, "TRIGGER_EVENT_DATA_VALIDATION_FAILED"),
            TriggerEvent::NewProxyNeeded => write!(f, "TRIGGER_EVENT_NEW_PROXY_NEEDED"),
            TriggerEvent::ScheduledMaintenance => write!(f, "TRIGGER_EVENT_SCHEDULED_MAINTENANCE"),
        }
    }
}

impl std::str::FromStr for TriggerEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TRIGGER_EVENT_UNSPECIFIED" => std::result::Result::Ok(TriggerEvent::Unspecified),
            "TRIGGER_EVENT_JOB_STARTED" => std::result::Result::Ok(TriggerEvent::JobStarted),
            "TRIGGER_EVENT_JOB_COMPLETED" => std::result::Result::Ok(TriggerEvent::JobCompleted),
            "TRIGGER_EVENT_JOB_FAILED" => std::result::Result::Ok(TriggerEvent::JobFailed),
            "TRIGGER_EVENT_LEAD_FOUND" => std::result::Result::Ok(TriggerEvent::LeadFound),
            "TRIGGER_EVENT_QUOTA_EXCEEDED" => std::result::Result::Ok(TriggerEvent::QuotaExceeded),
            "TRIGGER_EVENT_ERROR_THRESHOLD_REACHED" => std::result::Result::Ok(TriggerEvent::ErrorThresholdReached),
            "TRIGGER_EVENT_RATE_LIMIT_REACHED" => std::result::Result::Ok(TriggerEvent::RateLimitReached),
            "TRIGGER_EVENT_DATA_VALIDATION_FAILED" => std::result::Result::Ok(TriggerEvent::DataValidationFailed),
            "TRIGGER_EVENT_NEW_PROXY_NEEDED" => std::result::Result::Ok(TriggerEvent::NewProxyNeeded),
            "TRIGGER_EVENT_SCHEDULED_MAINTENANCE" => std::result::Result::Ok(TriggerEvent::ScheduledMaintenance),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TriggerWorkflowBody {
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<std::collections::HashMap<String, String>>,

}


impl TriggerWorkflowBody {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TriggerWorkflowBody {
        TriggerWorkflowBody {
            parameters: None,
        }
    }
}

/// Converts the TriggerWorkflowBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TriggerWorkflowBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping parameters in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TriggerWorkflowBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TriggerWorkflowBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub parameters: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TriggerWorkflowBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in TriggerWorkflowBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TriggerWorkflowBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TriggerWorkflowBody {
            parameters: intermediate_rep.parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TriggerWorkflowBody> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TriggerWorkflowBody>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TriggerWorkflowBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TriggerWorkflowBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TriggerWorkflowBody> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TriggerWorkflowBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TriggerWorkflowBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TriggerWorkflowResponse {
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub job_id: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BackgroundJobStatus>,

}


impl TriggerWorkflowResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TriggerWorkflowResponse {
        TriggerWorkflowResponse {
            job_id: None,
            status: None,
        }
    }
}

/// Converts the TriggerWorkflowResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TriggerWorkflowResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.job_id.as_ref().map(|job_id| {
                [
                    "jobId".to_string(),
                    job_id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TriggerWorkflowResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TriggerWorkflowResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub job_id: Vec<String>,
            pub status: Vec<models::BackgroundJobStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TriggerWorkflowResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jobId" => intermediate_rep.job_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::BackgroundJobStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TriggerWorkflowResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TriggerWorkflowResponse {
            job_id: intermediate_rep.job_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TriggerWorkflowResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TriggerWorkflowResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TriggerWorkflowResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TriggerWorkflowResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TriggerWorkflowResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TriggerWorkflowResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TriggerWorkflowResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Represents errors when the server understands the content type but cannot process the instructions
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnprocessableEntityErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::FieldError>>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl UnprocessableEntityErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UnprocessableEntityErrorMessageResponse {
        UnprocessableEntityErrorMessageResponse {
            code: None,
            message: None,
            errors: None,
            error_response: None,
        }
    }
}

/// Converts the UnprocessableEntityErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UnprocessableEntityErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping errors in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UnprocessableEntityErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UnprocessableEntityErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub errors: Vec<Vec<models::FieldError>>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UnprocessableEntityErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in UnprocessableEntityErrorMessageResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UnprocessableEntityErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UnprocessableEntityErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UnprocessableEntityErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UnprocessableEntityErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UnprocessableEntityErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UnprocessableEntityErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UnprocessableEntityErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UnprocessableEntityErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UnprocessableEntityErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateAccountRequest {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account1>,

}


impl UpdateAccountRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateAccountRequest {
        UpdateAccountRequest {
            account: None,
        }
    }
}

/// Converts the UpdateAccountRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateAccountRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateAccountRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateAccountRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateAccountRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateAccountRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateAccountRequest {
            account: intermediate_rep.account.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateAccountRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateAccountRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateAccountRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateAccountRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateAccountRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateAccountRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateAccountRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateAccountResponse {
    #[serde(rename = "account")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<models::Account1>,

}


impl UpdateAccountResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateAccountResponse {
        UpdateAccountResponse {
            account: None,
        }
    }
}

/// Converts the UpdateAccountResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateAccountResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping account in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateAccountResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateAccountResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account: Vec<models::Account1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateAccountResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account" => intermediate_rep.account.push(<models::Account1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateAccountResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateAccountResponse {
            account: intermediate_rep.account.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateAccountResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateAccountResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateAccountResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateAccountResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateAccountResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateAccountResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateAccountResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateAccountSettingsRequest {
    #[serde(rename = "settings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub settings: Option<models::AccountSettings>,

}


impl UpdateAccountSettingsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateAccountSettingsRequest {
        UpdateAccountSettingsRequest {
            settings: None,
        }
    }
}

/// Converts the UpdateAccountSettingsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateAccountSettingsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping settings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateAccountSettingsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateAccountSettingsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub settings: Vec<models::AccountSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateAccountSettingsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "settings" => intermediate_rep.settings.push(<models::AccountSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateAccountSettingsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateAccountSettingsRequest {
            settings: intermediate_rep.settings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateAccountSettingsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateAccountSettingsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateAccountSettingsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateAccountSettingsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateAccountSettingsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateAccountSettingsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateAccountSettingsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateAccountSettingsResponse {
    #[serde(rename = "settings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub settings: Option<models::AccountSettings>,

}


impl UpdateAccountSettingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateAccountSettingsResponse {
        UpdateAccountSettingsResponse {
            settings: None,
        }
    }
}

/// Converts the UpdateAccountSettingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateAccountSettingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping settings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateAccountSettingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateAccountSettingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub settings: Vec<models::AccountSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateAccountSettingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "settings" => intermediate_rep.settings.push(<models::AccountSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateAccountSettingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateAccountSettingsResponse {
            settings: intermediate_rep.settings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateAccountSettingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateAccountSettingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateAccountSettingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateAccountSettingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateAccountSettingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateAccountSettingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateAccountSettingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateApiKeyRequest {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::ApiKey>,

}


impl UpdateApiKeyRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateApiKeyRequest {
        UpdateApiKeyRequest {
            api_key: None,
        }
    }
}

/// Converts the UpdateApiKeyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateApiKeyRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateApiKeyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateApiKeyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::ApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateApiKeyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::ApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateApiKeyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateApiKeyRequest {
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateApiKeyRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateApiKeyRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateApiKeyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateApiKeyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateApiKeyRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateApiKeyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateApiKeyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateApiKeyResponse {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::ApiKey>,

}


impl UpdateApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateApiKeyResponse {
        UpdateApiKeyResponse {
            api_key: None,
        }
    }
}

/// Converts the UpdateApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::ApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::ApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateApiKeyResponse {
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrganizationRequest {
    #[serde(rename = "organization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<models::Organization>,

}


impl UpdateOrganizationRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOrganizationRequest {
        UpdateOrganizationRequest {
            organization: None,
        }
    }
}

/// Converts the UpdateOrganizationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrganizationRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping organization in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrganizationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrganizationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization: Vec<models::Organization>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrganizationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organization" => intermediate_rep.organization.push(<models::Organization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrganizationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrganizationRequest {
            organization: intermediate_rep.organization.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrganizationRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrganizationRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrganizationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrganizationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrganizationRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrganizationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrganizationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrganizationResponse {
    #[serde(rename = "organization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<models::Organization>,

}


impl UpdateOrganizationResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOrganizationResponse {
        UpdateOrganizationResponse {
            organization: None,
        }
    }
}

/// Converts the UpdateOrganizationResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrganizationResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping organization in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrganizationResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrganizationResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organization: Vec<models::Organization>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrganizationResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organization" => intermediate_rep.organization.push(<models::Organization as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrganizationResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrganizationResponse {
            organization: intermediate_rep.organization.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrganizationResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrganizationResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrganizationResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrganizationResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrganizationResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrganizationResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrganizationResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateTenantApiKeyRequest {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::TenantApiKey>,

}


impl UpdateTenantApiKeyRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateTenantApiKeyRequest {
        UpdateTenantApiKeyRequest {
            api_key: None,
        }
    }
}

/// Converts the UpdateTenantApiKeyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateTenantApiKeyRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateTenantApiKeyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateTenantApiKeyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::TenantApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateTenantApiKeyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::TenantApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateTenantApiKeyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateTenantApiKeyRequest {
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateTenantApiKeyRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateTenantApiKeyRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateTenantApiKeyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateTenantApiKeyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateTenantApiKeyRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateTenantApiKeyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateTenantApiKeyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateTenantApiKeyResponse {
    #[serde(rename = "apiKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::TenantApiKey>,

}


impl UpdateTenantApiKeyResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateTenantApiKeyResponse {
        UpdateTenantApiKeyResponse {
            api_key: None,
        }
    }
}

/// Converts the UpdateTenantApiKeyResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateTenantApiKeyResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping apiKey in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateTenantApiKeyResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateTenantApiKeyResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_key: Vec<models::TenantApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateTenantApiKeyResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiKey" => intermediate_rep.api_key.push(<models::TenantApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateTenantApiKeyResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateTenantApiKeyResponse {
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateTenantApiKeyResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateTenantApiKeyResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateTenantApiKeyResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateTenantApiKeyResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateTenantApiKeyResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateTenantApiKeyResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateTenantApiKeyResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateTenantRequest {
    #[serde(rename = "tenant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant: Option<models::Tenant>,

}


impl UpdateTenantRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateTenantRequest {
        UpdateTenantRequest {
            tenant: None,
        }
    }
}

/// Converts the UpdateTenantRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateTenantRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tenant in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateTenantRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateTenantRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant: Vec<models::Tenant>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateTenantRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tenant" => intermediate_rep.tenant.push(<models::Tenant as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateTenantRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateTenantRequest {
            tenant: intermediate_rep.tenant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateTenantRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateTenantRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateTenantRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateTenantRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateTenantRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateTenantRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateTenantRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateTenantResponse {
    #[serde(rename = "tenant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant: Option<models::Tenant>,

}


impl UpdateTenantResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateTenantResponse {
        UpdateTenantResponse {
            tenant: None,
        }
    }
}

/// Converts the UpdateTenantResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateTenantResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tenant in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateTenantResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateTenantResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tenant: Vec<models::Tenant>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateTenantResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tenant" => intermediate_rep.tenant.push(<models::Tenant as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateTenantResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateTenantResponse {
            tenant: intermediate_rep.tenant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateTenantResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateTenantResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateTenantResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateTenantResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateTenantResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateTenantResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateTenantResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWebhookRequest {
    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<models::WebhookConfig>,

}


impl UpdateWebhookRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWebhookRequest {
        UpdateWebhookRequest {
            webhook: None,
        }
    }
}

/// Converts the UpdateWebhookRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWebhookRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping webhook in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWebhookRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWebhookRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub webhook: Vec<models::WebhookConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWebhookRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "webhook" => intermediate_rep.webhook.push(<models::WebhookConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWebhookRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWebhookRequest {
            webhook: intermediate_rep.webhook.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWebhookRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWebhookRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWebhookRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWebhookRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWebhookRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWebhookRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWebhookRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWebhookResponse {
    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<models::WebhookConfig>,

}


impl UpdateWebhookResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWebhookResponse {
        UpdateWebhookResponse {
            webhook: None,
        }
    }
}

/// Converts the UpdateWebhookResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWebhookResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping webhook in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWebhookResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWebhookResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub webhook: Vec<models::WebhookConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWebhookResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "webhook" => intermediate_rep.webhook.push(<models::WebhookConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWebhookResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWebhookResponse {
            webhook: intermediate_rep.webhook.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWebhookResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWebhookResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWebhookResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWebhookResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWebhookResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWebhookResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWebhookResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWorkflowRequest {
    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::ScrapingWorkflow>,

}


impl UpdateWorkflowRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWorkflowRequest {
        UpdateWorkflowRequest {
            workflow: None,
        }
    }
}

/// Converts the UpdateWorkflowRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWorkflowRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWorkflowRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWorkflowRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflow: Vec<models::ScrapingWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWorkflowRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::ScrapingWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWorkflowRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWorkflowRequest {
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWorkflowRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWorkflowRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWorkflowRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWorkflowRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWorkflowRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWorkflowRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWorkflowRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWorkflowResponse {
    #[serde(rename = "workflow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<models::ScrapingWorkflow>,

}


impl UpdateWorkflowResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWorkflowResponse {
        UpdateWorkflowResponse {
            workflow: None,
        }
    }
}

/// Converts the UpdateWorkflowResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWorkflowResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workflow in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWorkflowResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWorkflowResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workflow: Vec<models::ScrapingWorkflow>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWorkflowResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workflow" => intermediate_rep.workflow.push(<models::ScrapingWorkflow as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWorkflowResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWorkflowResponse {
            workflow: intermediate_rep.workflow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWorkflowResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWorkflowResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWorkflowResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWorkflowResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWorkflowResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWorkflowResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWorkflowResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWorkspaceRequest {
    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace1>,

}


impl UpdateWorkspaceRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWorkspaceRequest {
        UpdateWorkspaceRequest {
            workspace: None,
        }
    }
}

/// Converts the UpdateWorkspaceRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWorkspaceRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspace in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWorkspaceRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWorkspaceRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspace: Vec<models::Workspace1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWorkspaceRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWorkspaceRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWorkspaceRequest {
            workspace: intermediate_rep.workspace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWorkspaceRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWorkspaceRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWorkspaceRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWorkspaceRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWorkspaceRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWorkspaceRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWorkspaceRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWorkspaceResponse {
    #[serde(rename = "workspace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace: Option<models::Workspace1>,

}


impl UpdateWorkspaceResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWorkspaceResponse {
        UpdateWorkspaceResponse {
            workspace: None,
        }
    }
}

/// Converts the UpdateWorkspaceResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWorkspaceResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping workspace in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWorkspaceResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWorkspaceResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub workspace: Vec<models::Workspace1>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWorkspaceResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workspace" => intermediate_rep.workspace.push(<models::Workspace1 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWorkspaceResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWorkspaceResponse {
            workspace: intermediate_rep.workspace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWorkspaceResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWorkspaceResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWorkspaceResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWorkspaceResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWorkspaceResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWorkspaceResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWorkspaceResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWorkspaceSharingRequest {
    #[serde(rename = "sharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharing: Option<models::WorkspaceSharing>,

}


impl UpdateWorkspaceSharingRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWorkspaceSharingRequest {
        UpdateWorkspaceSharingRequest {
            sharing: None,
        }
    }
}

/// Converts the UpdateWorkspaceSharingRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWorkspaceSharingRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sharing in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWorkspaceSharingRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWorkspaceSharingRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sharing: Vec<models::WorkspaceSharing>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWorkspaceSharingRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sharing" => intermediate_rep.sharing.push(<models::WorkspaceSharing as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWorkspaceSharingRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWorkspaceSharingRequest {
            sharing: intermediate_rep.sharing.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWorkspaceSharingRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWorkspaceSharingRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWorkspaceSharingRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWorkspaceSharingRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWorkspaceSharingRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWorkspaceSharingRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWorkspaceSharingRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateWorkspaceSharingResponse {
    #[serde(rename = "sharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharing: Option<models::WorkspaceSharing>,

}


impl UpdateWorkspaceSharingResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateWorkspaceSharingResponse {
        UpdateWorkspaceSharingResponse {
            sharing: None,
        }
    }
}

/// Converts the UpdateWorkspaceSharingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateWorkspaceSharingResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sharing in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateWorkspaceSharingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateWorkspaceSharingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sharing: Vec<models::WorkspaceSharing>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateWorkspaceSharingResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sharing" => intermediate_rep.sharing.push(<models::WorkspaceSharing as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateWorkspaceSharingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateWorkspaceSharingResponse {
            sharing: intermediate_rep.sharing.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateWorkspaceSharingResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateWorkspaceSharingResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateWorkspaceSharingResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateWorkspaceSharingResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateWorkspaceSharingResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateWorkspaceSharingResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateWorkspaceSharingResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserActivity {
    #[serde(rename = "userId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<String>,

    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

    #[serde(rename = "fileOperations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_operations: Option<i32>,

    #[serde(rename = "commentsMade")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_made: Option<i32>,

    #[serde(rename = "documentsProcessed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub documents_processed: Option<i32>,

}


impl UserActivity {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UserActivity {
        UserActivity {
            user_id: None,
            email: None,
            file_operations: None,
            comments_made: None,
            documents_processed: None,
        }
    }
}

/// Converts the UserActivity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserActivity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.user_id.as_ref().map(|user_id| {
                [
                    "userId".to_string(),
                    user_id.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.file_operations.as_ref().map(|file_operations| {
                [
                    "fileOperations".to_string(),
                    file_operations.to_string(),
                ].join(",")
            }),


            self.comments_made.as_ref().map(|comments_made| {
                [
                    "commentsMade".to_string(),
                    comments_made.to_string(),
                ].join(",")
            }),


            self.documents_processed.as_ref().map(|documents_processed| {
                [
                    "documentsProcessed".to_string(),
                    documents_processed.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserActivity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserActivity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_id: Vec<String>,
            pub email: Vec<String>,
            pub file_operations: Vec<i32>,
            pub comments_made: Vec<i32>,
            pub documents_processed: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserActivity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fileOperations" => intermediate_rep.file_operations.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "commentsMade" => intermediate_rep.comments_made.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "documentsProcessed" => intermediate_rep.documents_processed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserActivity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserActivity {
            user_id: intermediate_rep.user_id.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            file_operations: intermediate_rep.file_operations.into_iter().next(),
            comments_made: intermediate_rep.comments_made.into_iter().next(),
            documents_processed: intermediate_rep.documents_processed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserActivity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserActivity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserActivity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserActivity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserActivity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserActivity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserActivity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum V1PeriodStatus {
    #[serde(rename = "STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "STATUS_ACTIVE")]
    Active,
    #[serde(rename = "STATUS_SUSPENDED")]
    Suspended,
    #[serde(rename = "STATUS_PENDING_VERIFICATION")]
    PendingVerification,
    #[serde(rename = "STATUS_REVOKED")]
    Revoked,
    #[serde(rename = "STATUS_EXPIRED")]
    Expired,
    #[serde(rename = "STATUS_RATE_LIMITED")]
    RateLimited,
    #[serde(rename = "STATUS_PENDING_REVIEW")]
    PendingReview,
    #[serde(rename = "STATUS_DEPRECATED")]
    Deprecated,
    #[serde(rename = "STATUS_MAINTENANCE")]
    Maintenance,
}

impl std::fmt::Display for V1PeriodStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            V1PeriodStatus::Unspecified => write!(f, "STATUS_UNSPECIFIED"),
            V1PeriodStatus::Active => write!(f, "STATUS_ACTIVE"),
            V1PeriodStatus::Suspended => write!(f, "STATUS_SUSPENDED"),
            V1PeriodStatus::PendingVerification => write!(f, "STATUS_PENDING_VERIFICATION"),
            V1PeriodStatus::Revoked => write!(f, "STATUS_REVOKED"),
            V1PeriodStatus::Expired => write!(f, "STATUS_EXPIRED"),
            V1PeriodStatus::RateLimited => write!(f, "STATUS_RATE_LIMITED"),
            V1PeriodStatus::PendingReview => write!(f, "STATUS_PENDING_REVIEW"),
            V1PeriodStatus::Deprecated => write!(f, "STATUS_DEPRECATED"),
            V1PeriodStatus::Maintenance => write!(f, "STATUS_MAINTENANCE"),
        }
    }
}

impl std::str::FromStr for V1PeriodStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "STATUS_UNSPECIFIED" => std::result::Result::Ok(V1PeriodStatus::Unspecified),
            "STATUS_ACTIVE" => std::result::Result::Ok(V1PeriodStatus::Active),
            "STATUS_SUSPENDED" => std::result::Result::Ok(V1PeriodStatus::Suspended),
            "STATUS_PENDING_VERIFICATION" => std::result::Result::Ok(V1PeriodStatus::PendingVerification),
            "STATUS_REVOKED" => std::result::Result::Ok(V1PeriodStatus::Revoked),
            "STATUS_EXPIRED" => std::result::Result::Ok(V1PeriodStatus::Expired),
            "STATUS_RATE_LIMITED" => std::result::Result::Ok(V1PeriodStatus::RateLimited),
            "STATUS_PENDING_REVIEW" => std::result::Result::Ok(V1PeriodStatus::PendingReview),
            "STATUS_DEPRECATED" => std::result::Result::Ok(V1PeriodStatus::Deprecated),
            "STATUS_MAINTENANCE" => std::result::Result::Ok(V1PeriodStatus::Maintenance),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// - VALIDATION_ERROR: General validation errors  - AUTHORIZATION_MODEL_NOT_FOUND: Resource not found errors  - INVALID_CONTINUATION_TOKEN: Input errors  - DUPLICATE_ENTRY: Conflict errors  - INVALID_SCHEMA_VERSION: Schema errors  - INVALID_FORMAT: New validation error codes  General invalid format  - INVALID_EMAIL_FORMAT: Email format is invalid  - INVALID_PASSWORD_STRENGTH: Password does not meet strength requirements  - FIELD_TOO_SHORT: Field value is too short  - FIELD_TOO_LONG: Field value is too long  - UNSUPPORTED_MEDIA_TYPE: Media type is not supported
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ValidationErrorCode {
    #[serde(rename = "NO_ERROR")]
    NoError,
    #[serde(rename = "VALIDATION_ERROR")]
    ValidationError,
    #[serde(rename = "INVALID_WRITE_INPUT")]
    InvalidWriteInput,
    #[serde(rename = "INVALID_CHECK_INPUT")]
    InvalidCheckInput,
    #[serde(rename = "INVALID_EXPAND_INPUT")]
    InvalidExpandInput,
    #[serde(rename = "INVALID_OBJECT_FORMAT")]
    InvalidObjectFormat,
    #[serde(rename = "INVALID_USER")]
    InvalidUser,
    #[serde(rename = "INVALID_TUPLE")]
    InvalidTuple,
    #[serde(rename = "AUTHORIZATION_MODEL_NOT_FOUND")]
    AuthorizationModelNotFound,
    #[serde(rename = "TYPE_NOT_FOUND")]
    TypeNotFound,
    #[serde(rename = "RELATION_NOT_FOUND")]
    RelationNotFound,
    #[serde(rename = "STORE_ID_INVALID_LENGTH")]
    StoreIdInvalidLength,
    #[serde(rename = "ID_TOO_LONG")]
    IdTooLong,
    #[serde(rename = "INVALID_CONTINUATION_TOKEN")]
    InvalidContinuationToken,
    #[serde(rename = "PAGE_SIZE_INVALID")]
    PageSizeInvalid,
    #[serde(rename = "PARAM_MISSING_VALUE")]
    ParamMissingValue,
    #[serde(rename = "EXCEEDED_ENTITY_LIMIT")]
    ExceededEntityLimit,
    #[serde(rename = "DUPLICATE_ENTRY")]
    DuplicateEntry,
    #[serde(rename = "CANNOT_ALLOW_DUPLICATE_TUPLES")]
    CannotAllowDuplicateTuples,
    #[serde(rename = "CANNOT_ALLOW_DUPLICATE_TYPES")]
    CannotAllowDuplicateTypes,
    #[serde(rename = "INVALID_SCHEMA_VERSION")]
    InvalidSchemaVersion,
    #[serde(rename = "INVALID_TYPE_PATTERN")]
    InvalidTypePattern,
    #[serde(rename = "INVALID_RELATION_PATTERN")]
    InvalidRelationPattern,
    #[serde(rename = "INVALID_OBJECT_PATTERN")]
    InvalidObjectPattern,
    #[serde(rename = "INVALID_FORMAT")]
    InvalidFormat,
    #[serde(rename = "INVALID_EMAIL_FORMAT")]
    InvalidEmailFormat,
    #[serde(rename = "INVALID_PASSWORD_STRENGTH")]
    InvalidPasswordStrength,
    #[serde(rename = "FIELD_TOO_SHORT")]
    FieldTooShort,
    #[serde(rename = "FIELD_TOO_LONG")]
    FieldTooLong,
    #[serde(rename = "UNSUPPORTED_MEDIA_TYPE")]
    UnsupportedMediaType,
}

impl std::fmt::Display for ValidationErrorCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ValidationErrorCode::NoError => write!(f, "NO_ERROR"),
            ValidationErrorCode::ValidationError => write!(f, "VALIDATION_ERROR"),
            ValidationErrorCode::InvalidWriteInput => write!(f, "INVALID_WRITE_INPUT"),
            ValidationErrorCode::InvalidCheckInput => write!(f, "INVALID_CHECK_INPUT"),
            ValidationErrorCode::InvalidExpandInput => write!(f, "INVALID_EXPAND_INPUT"),
            ValidationErrorCode::InvalidObjectFormat => write!(f, "INVALID_OBJECT_FORMAT"),
            ValidationErrorCode::InvalidUser => write!(f, "INVALID_USER"),
            ValidationErrorCode::InvalidTuple => write!(f, "INVALID_TUPLE"),
            ValidationErrorCode::AuthorizationModelNotFound => write!(f, "AUTHORIZATION_MODEL_NOT_FOUND"),
            ValidationErrorCode::TypeNotFound => write!(f, "TYPE_NOT_FOUND"),
            ValidationErrorCode::RelationNotFound => write!(f, "RELATION_NOT_FOUND"),
            ValidationErrorCode::StoreIdInvalidLength => write!(f, "STORE_ID_INVALID_LENGTH"),
            ValidationErrorCode::IdTooLong => write!(f, "ID_TOO_LONG"),
            ValidationErrorCode::InvalidContinuationToken => write!(f, "INVALID_CONTINUATION_TOKEN"),
            ValidationErrorCode::PageSizeInvalid => write!(f, "PAGE_SIZE_INVALID"),
            ValidationErrorCode::ParamMissingValue => write!(f, "PARAM_MISSING_VALUE"),
            ValidationErrorCode::ExceededEntityLimit => write!(f, "EXCEEDED_ENTITY_LIMIT"),
            ValidationErrorCode::DuplicateEntry => write!(f, "DUPLICATE_ENTRY"),
            ValidationErrorCode::CannotAllowDuplicateTuples => write!(f, "CANNOT_ALLOW_DUPLICATE_TUPLES"),
            ValidationErrorCode::CannotAllowDuplicateTypes => write!(f, "CANNOT_ALLOW_DUPLICATE_TYPES"),
            ValidationErrorCode::InvalidSchemaVersion => write!(f, "INVALID_SCHEMA_VERSION"),
            ValidationErrorCode::InvalidTypePattern => write!(f, "INVALID_TYPE_PATTERN"),
            ValidationErrorCode::InvalidRelationPattern => write!(f, "INVALID_RELATION_PATTERN"),
            ValidationErrorCode::InvalidObjectPattern => write!(f, "INVALID_OBJECT_PATTERN"),
            ValidationErrorCode::InvalidFormat => write!(f, "INVALID_FORMAT"),
            ValidationErrorCode::InvalidEmailFormat => write!(f, "INVALID_EMAIL_FORMAT"),
            ValidationErrorCode::InvalidPasswordStrength => write!(f, "INVALID_PASSWORD_STRENGTH"),
            ValidationErrorCode::FieldTooShort => write!(f, "FIELD_TOO_SHORT"),
            ValidationErrorCode::FieldTooLong => write!(f, "FIELD_TOO_LONG"),
            ValidationErrorCode::UnsupportedMediaType => write!(f, "UNSUPPORTED_MEDIA_TYPE"),
        }
    }
}

impl std::str::FromStr for ValidationErrorCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NO_ERROR" => std::result::Result::Ok(ValidationErrorCode::NoError),
            "VALIDATION_ERROR" => std::result::Result::Ok(ValidationErrorCode::ValidationError),
            "INVALID_WRITE_INPUT" => std::result::Result::Ok(ValidationErrorCode::InvalidWriteInput),
            "INVALID_CHECK_INPUT" => std::result::Result::Ok(ValidationErrorCode::InvalidCheckInput),
            "INVALID_EXPAND_INPUT" => std::result::Result::Ok(ValidationErrorCode::InvalidExpandInput),
            "INVALID_OBJECT_FORMAT" => std::result::Result::Ok(ValidationErrorCode::InvalidObjectFormat),
            "INVALID_USER" => std::result::Result::Ok(ValidationErrorCode::InvalidUser),
            "INVALID_TUPLE" => std::result::Result::Ok(ValidationErrorCode::InvalidTuple),
            "AUTHORIZATION_MODEL_NOT_FOUND" => std::result::Result::Ok(ValidationErrorCode::AuthorizationModelNotFound),
            "TYPE_NOT_FOUND" => std::result::Result::Ok(ValidationErrorCode::TypeNotFound),
            "RELATION_NOT_FOUND" => std::result::Result::Ok(ValidationErrorCode::RelationNotFound),
            "STORE_ID_INVALID_LENGTH" => std::result::Result::Ok(ValidationErrorCode::StoreIdInvalidLength),
            "ID_TOO_LONG" => std::result::Result::Ok(ValidationErrorCode::IdTooLong),
            "INVALID_CONTINUATION_TOKEN" => std::result::Result::Ok(ValidationErrorCode::InvalidContinuationToken),
            "PAGE_SIZE_INVALID" => std::result::Result::Ok(ValidationErrorCode::PageSizeInvalid),
            "PARAM_MISSING_VALUE" => std::result::Result::Ok(ValidationErrorCode::ParamMissingValue),
            "EXCEEDED_ENTITY_LIMIT" => std::result::Result::Ok(ValidationErrorCode::ExceededEntityLimit),
            "DUPLICATE_ENTRY" => std::result::Result::Ok(ValidationErrorCode::DuplicateEntry),
            "CANNOT_ALLOW_DUPLICATE_TUPLES" => std::result::Result::Ok(ValidationErrorCode::CannotAllowDuplicateTuples),
            "CANNOT_ALLOW_DUPLICATE_TYPES" => std::result::Result::Ok(ValidationErrorCode::CannotAllowDuplicateTypes),
            "INVALID_SCHEMA_VERSION" => std::result::Result::Ok(ValidationErrorCode::InvalidSchemaVersion),
            "INVALID_TYPE_PATTERN" => std::result::Result::Ok(ValidationErrorCode::InvalidTypePattern),
            "INVALID_RELATION_PATTERN" => std::result::Result::Ok(ValidationErrorCode::InvalidRelationPattern),
            "INVALID_OBJECT_PATTERN" => std::result::Result::Ok(ValidationErrorCode::InvalidObjectPattern),
            "INVALID_FORMAT" => std::result::Result::Ok(ValidationErrorCode::InvalidFormat),
            "INVALID_EMAIL_FORMAT" => std::result::Result::Ok(ValidationErrorCode::InvalidEmailFormat),
            "INVALID_PASSWORD_STRENGTH" => std::result::Result::Ok(ValidationErrorCode::InvalidPasswordStrength),
            "FIELD_TOO_SHORT" => std::result::Result::Ok(ValidationErrorCode::FieldTooShort),
            "FIELD_TOO_LONG" => std::result::Result::Ok(ValidationErrorCode::FieldTooLong),
            "UNSUPPORTED_MEDIA_TYPE" => std::result::Result::Ok(ValidationErrorCode::UnsupportedMediaType),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents data validation and business logic errors
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ValidationErrorMessageResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::ValidationErrorCode>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "fieldViolations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field_violations: Option<Vec<models::FieldViolation>>,

    #[serde(rename = "schemaValidation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub schema_validation: Option<models::SchemaValidation>,

    #[serde(rename = "resourceValidation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_validation: Option<models::ResourceValidation>,

    #[serde(rename = "errorResponse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_response: Option<models::ErrorResponse>,

}


impl ValidationErrorMessageResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ValidationErrorMessageResponse {
        ValidationErrorMessageResponse {
            code: None,
            message: None,
            field_violations: None,
            schema_validation: None,
            resource_validation: None,
            error_response: None,
        }
    }
}

/// Converts the ValidationErrorMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ValidationErrorMessageResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping fieldViolations in query parameter serialization

            // Skipping schemaValidation in query parameter serialization

            // Skipping resourceValidation in query parameter serialization

            // Skipping errorResponse in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ValidationErrorMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ValidationErrorMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::ValidationErrorCode>,
            pub message: Vec<String>,
            pub field_violations: Vec<Vec<models::FieldViolation>>,
            pub schema_validation: Vec<models::SchemaValidation>,
            pub resource_validation: Vec<models::ResourceValidation>,
            pub error_response: Vec<models::ErrorResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ValidationErrorMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::ValidationErrorCode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "fieldViolations" => return std::result::Result::Err("Parsing a container in this style is not supported in ValidationErrorMessageResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "schemaValidation" => intermediate_rep.schema_validation.push(<models::SchemaValidation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resourceValidation" => intermediate_rep.resource_validation.push(<models::ResourceValidation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorResponse" => intermediate_rep.error_response.push(<models::ErrorResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ValidationErrorMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ValidationErrorMessageResponse {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            field_violations: intermediate_rep.field_violations.into_iter().next(),
            schema_validation: intermediate_rep.schema_validation.into_iter().next(),
            resource_validation: intermediate_rep.resource_validation.into_iter().next(),
            error_response: intermediate_rep.error_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ValidationErrorMessageResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ValidationErrorMessageResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ValidationErrorMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ValidationErrorMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ValidationErrorMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ValidationErrorMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ValidationErrorMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WebhookConfig {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

    /// e.g., \"basic\", \"bearer\", \"custom\"
    #[serde(rename = "authType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth_type: Option<String>,

    #[serde(rename = "authToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth_token: Option<String>,

    #[serde(rename = "customHeaders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_headers: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "maxRetries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_retries: Option<i32>,

    #[serde(rename = "retryInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retry_interval: Option<String>,

    #[serde(rename = "triggerEvents")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub trigger_events: Option<Vec<models::TriggerEvent>>,

    #[serde(rename = "includedFields")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub included_fields: Option<Vec<models::IncludedField>>,

    #[serde(rename = "includeFullResults")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_full_results: Option<bool>,

    #[serde(rename = "payloadFormat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload_format: Option<models::PayloadFormat>,

    #[serde(rename = "verifySsl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verify_ssl: Option<bool>,

    #[serde(rename = "signingSecret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signing_secret: Option<String>,

    #[serde(rename = "rateLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limit: Option<i32>,

    #[serde(rename = "rateLimitInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limit_interval: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "lastTriggeredAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_triggered_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "successfulCalls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub successful_calls: Option<i32>,

    #[serde(rename = "failedCalls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_calls: Option<i32>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<serde_json::Value>,

    #[serde(rename = "webhookName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_name: Option<String>,

}


impl WebhookConfig {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WebhookConfig {
        WebhookConfig {
            id: None,
            url: None,
            auth_type: None,
            auth_token: None,
            custom_headers: None,
            max_retries: None,
            retry_interval: None,
            trigger_events: None,
            included_fields: None,
            include_full_results: None,
            payload_format: None,
            verify_ssl: None,
            signing_secret: None,
            rate_limit: None,
            rate_limit_interval: None,
            created_at: None,
            updated_at: None,
            last_triggered_at: None,
            successful_calls: None,
            failed_calls: None,
            metadata: None,
            webhook_name: None,
        }
    }
}

/// Converts the WebhookConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WebhookConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),


            self.auth_type.as_ref().map(|auth_type| {
                [
                    "authType".to_string(),
                    auth_type.to_string(),
                ].join(",")
            }),


            self.auth_token.as_ref().map(|auth_token| {
                [
                    "authToken".to_string(),
                    auth_token.to_string(),
                ].join(",")
            }),

            // Skipping customHeaders in query parameter serialization


            self.max_retries.as_ref().map(|max_retries| {
                [
                    "maxRetries".to_string(),
                    max_retries.to_string(),
                ].join(",")
            }),


            self.retry_interval.as_ref().map(|retry_interval| {
                [
                    "retryInterval".to_string(),
                    retry_interval.to_string(),
                ].join(",")
            }),

            // Skipping triggerEvents in query parameter serialization

            // Skipping includedFields in query parameter serialization


            self.include_full_results.as_ref().map(|include_full_results| {
                [
                    "includeFullResults".to_string(),
                    include_full_results.to_string(),
                ].join(",")
            }),

            // Skipping payloadFormat in query parameter serialization


            self.verify_ssl.as_ref().map(|verify_ssl| {
                [
                    "verifySsl".to_string(),
                    verify_ssl.to_string(),
                ].join(",")
            }),


            self.signing_secret.as_ref().map(|signing_secret| {
                [
                    "signingSecret".to_string(),
                    signing_secret.to_string(),
                ].join(",")
            }),


            self.rate_limit.as_ref().map(|rate_limit| {
                [
                    "rateLimit".to_string(),
                    rate_limit.to_string(),
                ].join(",")
            }),


            self.rate_limit_interval.as_ref().map(|rate_limit_interval| {
                [
                    "rateLimitInterval".to_string(),
                    rate_limit_interval.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping lastTriggeredAt in query parameter serialization


            self.successful_calls.as_ref().map(|successful_calls| {
                [
                    "successfulCalls".to_string(),
                    successful_calls.to_string(),
                ].join(",")
            }),


            self.failed_calls.as_ref().map(|failed_calls| {
                [
                    "failedCalls".to_string(),
                    failed_calls.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.webhook_name.as_ref().map(|webhook_name| {
                [
                    "webhookName".to_string(),
                    webhook_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WebhookConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WebhookConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub url: Vec<String>,
            pub auth_type: Vec<String>,
            pub auth_token: Vec<String>,
            pub custom_headers: Vec<std::collections::HashMap<String, String>>,
            pub max_retries: Vec<i32>,
            pub retry_interval: Vec<String>,
            pub trigger_events: Vec<Vec<models::TriggerEvent>>,
            pub included_fields: Vec<Vec<models::IncludedField>>,
            pub include_full_results: Vec<bool>,
            pub payload_format: Vec<models::PayloadFormat>,
            pub verify_ssl: Vec<bool>,
            pub signing_secret: Vec<String>,
            pub rate_limit: Vec<i32>,
            pub rate_limit_interval: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub last_triggered_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub successful_calls: Vec<i32>,
            pub failed_calls: Vec<i32>,
            pub metadata: Vec<serde_json::Value>,
            pub webhook_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WebhookConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authType" => intermediate_rep.auth_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "authToken" => intermediate_rep.auth_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "customHeaders" => return std::result::Result::Err("Parsing a container in this style is not supported in WebhookConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "maxRetries" => intermediate_rep.max_retries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retryInterval" => intermediate_rep.retry_interval.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "triggerEvents" => return std::result::Result::Err("Parsing a container in this style is not supported in WebhookConfig".to_string()),
                    "includedFields" => return std::result::Result::Err("Parsing a container in this style is not supported in WebhookConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "includeFullResults" => intermediate_rep.include_full_results.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "payloadFormat" => intermediate_rep.payload_format.push(<models::PayloadFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "verifySsl" => intermediate_rep.verify_ssl.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signingSecret" => intermediate_rep.signing_secret.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rateLimit" => intermediate_rep.rate_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rateLimitInterval" => intermediate_rep.rate_limit_interval.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastTriggeredAt" => intermediate_rep.last_triggered_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "successfulCalls" => intermediate_rep.successful_calls.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failedCalls" => intermediate_rep.failed_calls.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<serde_json::Value as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "webhookName" => intermediate_rep.webhook_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WebhookConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WebhookConfig {
            id: intermediate_rep.id.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            auth_type: intermediate_rep.auth_type.into_iter().next(),
            auth_token: intermediate_rep.auth_token.into_iter().next(),
            custom_headers: intermediate_rep.custom_headers.into_iter().next(),
            max_retries: intermediate_rep.max_retries.into_iter().next(),
            retry_interval: intermediate_rep.retry_interval.into_iter().next(),
            trigger_events: intermediate_rep.trigger_events.into_iter().next(),
            included_fields: intermediate_rep.included_fields.into_iter().next(),
            include_full_results: intermediate_rep.include_full_results.into_iter().next(),
            payload_format: intermediate_rep.payload_format.into_iter().next(),
            verify_ssl: intermediate_rep.verify_ssl.into_iter().next(),
            signing_secret: intermediate_rep.signing_secret.into_iter().next(),
            rate_limit: intermediate_rep.rate_limit.into_iter().next(),
            rate_limit_interval: intermediate_rep.rate_limit_interval.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            last_triggered_at: intermediate_rep.last_triggered_at.into_iter().next(),
            successful_calls: intermediate_rep.successful_calls.into_iter().next(),
            failed_calls: intermediate_rep.failed_calls.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            webhook_name: intermediate_rep.webhook_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WebhookConfig> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WebhookConfig>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WebhookConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WebhookConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WebhookConfig> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WebhookConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WebhookConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// WorkflowStatus represents the current state of a scraping workflow. This enum tracks the lifecycle of automated, recurring scraping configurations.  State transitions: 1. DRAFT -> ACTIVE/ARCHIVED 2. ACTIVE -> PAUSED/FAILED/COMPLETED/ARCHIVED 3. PAUSED -> ACTIVE/ARCHIVED 4. FAILED -> ACTIVE/ARCHIVED   - WORKFLOW_STATUS_UNSPECIFIED: Default state, should not be used explicitly  - WORKFLOW_STATUS_DRAFT: Initial draft state before activation  - WORKFLOW_STATUS_ACTIVE: Workflow is actively running on schedule  - WORKFLOW_STATUS_PAUSED: Workflow is temporarily suspended  - WORKFLOW_STATUS_FAILED: Workflow encountered an error  - WORKFLOW_STATUS_COMPLETED: Workflow completed all scheduled runs  - WORKFLOW_STATUS_ARCHIVED: Workflow is archived (soft-deleted)  - WORKFLOW_STATUS_PENDING_APPROVAL: Workflow is pending approval  - WORKFLOW_STATUS_VALIDATING: Workflow is being validated  - WORKFLOW_STATUS_QUOTA_EXCEEDED: Workflow exceeded resource quotas  - WORKFLOW_STATUS_WARNING: Workflow is running but with warnings
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum WorkflowStatus {
    #[serde(rename = "WORKFLOW_STATUS_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "WORKFLOW_STATUS_DRAFT")]
    Draft,
    #[serde(rename = "WORKFLOW_STATUS_ACTIVE")]
    Active,
    #[serde(rename = "WORKFLOW_STATUS_PAUSED")]
    Paused,
    #[serde(rename = "WORKFLOW_STATUS_FAILED")]
    Failed,
    #[serde(rename = "WORKFLOW_STATUS_COMPLETED")]
    Completed,
    #[serde(rename = "WORKFLOW_STATUS_ARCHIVED")]
    Archived,
    #[serde(rename = "WORKFLOW_STATUS_PENDING_APPROVAL")]
    PendingApproval,
    #[serde(rename = "WORKFLOW_STATUS_VALIDATING")]
    Validating,
    #[serde(rename = "WORKFLOW_STATUS_QUOTA_EXCEEDED")]
    QuotaExceeded,
    #[serde(rename = "WORKFLOW_STATUS_WARNING")]
    Warning,
}

impl std::fmt::Display for WorkflowStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            WorkflowStatus::Unspecified => write!(f, "WORKFLOW_STATUS_UNSPECIFIED"),
            WorkflowStatus::Draft => write!(f, "WORKFLOW_STATUS_DRAFT"),
            WorkflowStatus::Active => write!(f, "WORKFLOW_STATUS_ACTIVE"),
            WorkflowStatus::Paused => write!(f, "WORKFLOW_STATUS_PAUSED"),
            WorkflowStatus::Failed => write!(f, "WORKFLOW_STATUS_FAILED"),
            WorkflowStatus::Completed => write!(f, "WORKFLOW_STATUS_COMPLETED"),
            WorkflowStatus::Archived => write!(f, "WORKFLOW_STATUS_ARCHIVED"),
            WorkflowStatus::PendingApproval => write!(f, "WORKFLOW_STATUS_PENDING_APPROVAL"),
            WorkflowStatus::Validating => write!(f, "WORKFLOW_STATUS_VALIDATING"),
            WorkflowStatus::QuotaExceeded => write!(f, "WORKFLOW_STATUS_QUOTA_EXCEEDED"),
            WorkflowStatus::Warning => write!(f, "WORKFLOW_STATUS_WARNING"),
        }
    }
}

impl std::str::FromStr for WorkflowStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "WORKFLOW_STATUS_UNSPECIFIED" => std::result::Result::Ok(WorkflowStatus::Unspecified),
            "WORKFLOW_STATUS_DRAFT" => std::result::Result::Ok(WorkflowStatus::Draft),
            "WORKFLOW_STATUS_ACTIVE" => std::result::Result::Ok(WorkflowStatus::Active),
            "WORKFLOW_STATUS_PAUSED" => std::result::Result::Ok(WorkflowStatus::Paused),
            "WORKFLOW_STATUS_FAILED" => std::result::Result::Ok(WorkflowStatus::Failed),
            "WORKFLOW_STATUS_COMPLETED" => std::result::Result::Ok(WorkflowStatus::Completed),
            "WORKFLOW_STATUS_ARCHIVED" => std::result::Result::Ok(WorkflowStatus::Archived),
            "WORKFLOW_STATUS_PENDING_APPROVAL" => std::result::Result::Ok(WorkflowStatus::PendingApproval),
            "WORKFLOW_STATUS_VALIDATING" => std::result::Result::Ok(WorkflowStatus::Validating),
            "WORKFLOW_STATUS_QUOTA_EXCEEDED" => std::result::Result::Ok(WorkflowStatus::QuotaExceeded),
            "WORKFLOW_STATUS_WARNING" => std::result::Result::Ok(WorkflowStatus::Warning),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Workspace {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "industry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub industry: Option<String>,

    #[serde(rename = "domain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domain: Option<String>,

    #[serde(rename = "gdprCompliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gdpr_compliant: Option<bool>,

    #[serde(rename = "hipaaCompliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hipaa_compliant: Option<bool>,

    #[serde(rename = "soc2Compliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub soc2_compliant: Option<bool>,

    /// in bytes
    #[serde(rename = "storageQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_quota: Option<String>,

    #[serde(rename = "usedStorage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub used_storage: Option<String>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "workflows")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<Vec<models::ScrapingWorkflow>>,

    #[serde(rename = "jobsRunThisMonth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_run_this_month: Option<i32>,

    #[serde(rename = "workspaceJobLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub workspace_job_limit: Option<i32>,

    #[serde(rename = "dailyJobQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_job_quota: Option<i32>,

    #[serde(rename = "activeScrapers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_scrapers: Option<i32>,

    #[serde(rename = "totalLeadsCollected")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_leads_collected: Option<i32>,

    #[serde(rename = "lastJobRun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_job_run: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "scrapingJobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scraping_jobs: Option<Vec<models::ScrapingJob>>,

    #[serde(rename = "apiKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_keys: Option<Vec<models::ApiKey>>,

    #[serde(rename = "webhooks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhooks: Option<Vec<models::WebhookConfig>>,

}


impl Workspace {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Workspace {
        Workspace {
            id: None,
            name: None,
            industry: None,
            domain: None,
            gdpr_compliant: None,
            hipaa_compliant: None,
            soc2_compliant: None,
            storage_quota: None,
            used_storage: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            workflows: None,
            jobs_run_this_month: None,
            workspace_job_limit: None,
            daily_job_quota: None,
            active_scrapers: None,
            total_leads_collected: None,
            last_job_run: None,
            scraping_jobs: None,
            api_keys: None,
            webhooks: None,
        }
    }
}

/// Converts the Workspace value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Workspace {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.industry.as_ref().map(|industry| {
                [
                    "industry".to_string(),
                    industry.to_string(),
                ].join(",")
            }),


            self.domain.as_ref().map(|domain| {
                [
                    "domain".to_string(),
                    domain.to_string(),
                ].join(",")
            }),


            self.gdpr_compliant.as_ref().map(|gdpr_compliant| {
                [
                    "gdprCompliant".to_string(),
                    gdpr_compliant.to_string(),
                ].join(",")
            }),


            self.hipaa_compliant.as_ref().map(|hipaa_compliant| {
                [
                    "hipaaCompliant".to_string(),
                    hipaa_compliant.to_string(),
                ].join(",")
            }),


            self.soc2_compliant.as_ref().map(|soc2_compliant| {
                [
                    "soc2Compliant".to_string(),
                    soc2_compliant.to_string(),
                ].join(",")
            }),


            self.storage_quota.as_ref().map(|storage_quota| {
                [
                    "storageQuota".to_string(),
                    storage_quota.to_string(),
                ].join(",")
            }),


            self.used_storage.as_ref().map(|used_storage| {
                [
                    "usedStorage".to_string(),
                    used_storage.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping workflows in query parameter serialization


            self.jobs_run_this_month.as_ref().map(|jobs_run_this_month| {
                [
                    "jobsRunThisMonth".to_string(),
                    jobs_run_this_month.to_string(),
                ].join(",")
            }),


            self.workspace_job_limit.as_ref().map(|workspace_job_limit| {
                [
                    "workspaceJobLimit".to_string(),
                    workspace_job_limit.to_string(),
                ].join(",")
            }),


            self.daily_job_quota.as_ref().map(|daily_job_quota| {
                [
                    "dailyJobQuota".to_string(),
                    daily_job_quota.to_string(),
                ].join(",")
            }),


            self.active_scrapers.as_ref().map(|active_scrapers| {
                [
                    "activeScrapers".to_string(),
                    active_scrapers.to_string(),
                ].join(",")
            }),


            self.total_leads_collected.as_ref().map(|total_leads_collected| {
                [
                    "totalLeadsCollected".to_string(),
                    total_leads_collected.to_string(),
                ].join(",")
            }),

            // Skipping lastJobRun in query parameter serialization

            // Skipping scrapingJobs in query parameter serialization

            // Skipping apiKeys in query parameter serialization

            // Skipping webhooks in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Workspace value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Workspace {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub industry: Vec<String>,
            pub domain: Vec<String>,
            pub gdpr_compliant: Vec<bool>,
            pub hipaa_compliant: Vec<bool>,
            pub soc2_compliant: Vec<bool>,
            pub storage_quota: Vec<String>,
            pub used_storage: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub workflows: Vec<Vec<models::ScrapingWorkflow>>,
            pub jobs_run_this_month: Vec<i32>,
            pub workspace_job_limit: Vec<i32>,
            pub daily_job_quota: Vec<i32>,
            pub active_scrapers: Vec<i32>,
            pub total_leads_collected: Vec<i32>,
            pub last_job_run: Vec<chrono::DateTime::<chrono::Utc>>,
            pub scraping_jobs: Vec<Vec<models::ScrapingJob>>,
            pub api_keys: Vec<Vec<models::ApiKey>>,
            pub webhooks: Vec<Vec<models::WebhookConfig>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Workspace".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "industry" => intermediate_rep.industry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "domain" => intermediate_rep.domain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gdprCompliant" => intermediate_rep.gdpr_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hipaaCompliant" => intermediate_rep.hipaa_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "soc2Compliant" => intermediate_rep.soc2_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageQuota" => intermediate_rep.storage_quota.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usedStorage" => intermediate_rep.used_storage.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "workflows" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "jobsRunThisMonth" => intermediate_rep.jobs_run_this_month.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workspaceJobLimit" => intermediate_rep.workspace_job_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dailyJobQuota" => intermediate_rep.daily_job_quota.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "activeScrapers" => intermediate_rep.active_scrapers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalLeadsCollected" => intermediate_rep.total_leads_collected.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastJobRun" => intermediate_rep.last_job_run.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "scrapingJobs" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace".to_string()),
                    "apiKeys" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace".to_string()),
                    "webhooks" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Workspace".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Workspace {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            industry: intermediate_rep.industry.into_iter().next(),
            domain: intermediate_rep.domain.into_iter().next(),
            gdpr_compliant: intermediate_rep.gdpr_compliant.into_iter().next(),
            hipaa_compliant: intermediate_rep.hipaa_compliant.into_iter().next(),
            soc2_compliant: intermediate_rep.soc2_compliant.into_iter().next(),
            storage_quota: intermediate_rep.storage_quota.into_iter().next(),
            used_storage: intermediate_rep.used_storage.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            workflows: intermediate_rep.workflows.into_iter().next(),
            jobs_run_this_month: intermediate_rep.jobs_run_this_month.into_iter().next(),
            workspace_job_limit: intermediate_rep.workspace_job_limit.into_iter().next(),
            daily_job_quota: intermediate_rep.daily_job_quota.into_iter().next(),
            active_scrapers: intermediate_rep.active_scrapers.into_iter().next(),
            total_leads_collected: intermediate_rep.total_leads_collected.into_iter().next(),
            last_job_run: intermediate_rep.last_job_run.into_iter().next(),
            scraping_jobs: intermediate_rep.scraping_jobs.into_iter().next(),
            api_keys: intermediate_rep.api_keys.into_iter().next(),
            webhooks: intermediate_rep.webhooks.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Workspace> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Workspace>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Workspace>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Workspace - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Workspace> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Workspace as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Workspace - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Workspace1 {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "uniqueIdentifier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unique_identifier: Option<String>,

    #[serde(rename = "s3BucketName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_bucket_name: Option<String>,

    #[serde(rename = "s3FolderPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub s3_folder_path: Option<String>,

    #[serde(rename = "storageQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_quota: Option<String>,

    #[serde(rename = "usedStorage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub used_storage: Option<String>,

    #[serde(rename = "allowPublicSharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_public_sharing: Option<bool>,

    #[serde(rename = "requireApproval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_approval: Option<bool>,

    #[serde(rename = "gdprCompliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gdpr_compliant: Option<bool>,

    #[serde(rename = "hipaaCompliant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hipaa_compliant: Option<bool>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "deletedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "folders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub folders: Option<Vec<models::FolderMetadata>>,

    #[serde(rename = "templates")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub templates: Option<Vec<models::DocumentTemplate>>,

    #[serde(rename = "sharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharing: Option<Vec<models::WorkspaceSharing>>,

    #[serde(rename = "activities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub activities: Option<Vec<models::WorkspaceActivity>>,

    #[serde(rename = "compliance")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance: Option<Vec<models::WorkspaceCompliance>>,

    #[serde(rename = "installedApps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub installed_apps: Option<Vec<models::MarketplaceApp>>,

}


impl Workspace1 {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Workspace1 {
        Workspace1 {
            id: None,
            name: None,
            unique_identifier: None,
            s3_bucket_name: None,
            s3_folder_path: None,
            storage_quota: None,
            used_storage: None,
            allow_public_sharing: None,
            require_approval: None,
            gdpr_compliant: None,
            hipaa_compliant: None,
            created_at: None,
            updated_at: None,
            deleted_at: None,
            folders: None,
            templates: None,
            sharing: None,
            activities: None,
            compliance: None,
            installed_apps: None,
        }
    }
}

/// Converts the Workspace1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Workspace1 {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.unique_identifier.as_ref().map(|unique_identifier| {
                [
                    "uniqueIdentifier".to_string(),
                    unique_identifier.to_string(),
                ].join(",")
            }),


            self.s3_bucket_name.as_ref().map(|s3_bucket_name| {
                [
                    "s3BucketName".to_string(),
                    s3_bucket_name.to_string(),
                ].join(",")
            }),


            self.s3_folder_path.as_ref().map(|s3_folder_path| {
                [
                    "s3FolderPath".to_string(),
                    s3_folder_path.to_string(),
                ].join(",")
            }),


            self.storage_quota.as_ref().map(|storage_quota| {
                [
                    "storageQuota".to_string(),
                    storage_quota.to_string(),
                ].join(",")
            }),


            self.used_storage.as_ref().map(|used_storage| {
                [
                    "usedStorage".to_string(),
                    used_storage.to_string(),
                ].join(",")
            }),


            self.allow_public_sharing.as_ref().map(|allow_public_sharing| {
                [
                    "allowPublicSharing".to_string(),
                    allow_public_sharing.to_string(),
                ].join(",")
            }),


            self.require_approval.as_ref().map(|require_approval| {
                [
                    "requireApproval".to_string(),
                    require_approval.to_string(),
                ].join(",")
            }),


            self.gdpr_compliant.as_ref().map(|gdpr_compliant| {
                [
                    "gdprCompliant".to_string(),
                    gdpr_compliant.to_string(),
                ].join(",")
            }),


            self.hipaa_compliant.as_ref().map(|hipaa_compliant| {
                [
                    "hipaaCompliant".to_string(),
                    hipaa_compliant.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping deletedAt in query parameter serialization

            // Skipping folders in query parameter serialization

            // Skipping templates in query parameter serialization

            // Skipping sharing in query parameter serialization

            // Skipping activities in query parameter serialization

            // Skipping compliance in query parameter serialization

            // Skipping installedApps in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Workspace1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Workspace1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub unique_identifier: Vec<String>,
            pub s3_bucket_name: Vec<String>,
            pub s3_folder_path: Vec<String>,
            pub storage_quota: Vec<String>,
            pub used_storage: Vec<String>,
            pub allow_public_sharing: Vec<bool>,
            pub require_approval: Vec<bool>,
            pub gdpr_compliant: Vec<bool>,
            pub hipaa_compliant: Vec<bool>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub deleted_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub folders: Vec<Vec<models::FolderMetadata>>,
            pub templates: Vec<Vec<models::DocumentTemplate>>,
            pub sharing: Vec<Vec<models::WorkspaceSharing>>,
            pub activities: Vec<Vec<models::WorkspaceActivity>>,
            pub compliance: Vec<Vec<models::WorkspaceCompliance>>,
            pub installed_apps: Vec<Vec<models::MarketplaceApp>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Workspace1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uniqueIdentifier" => intermediate_rep.unique_identifier.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3BucketName" => intermediate_rep.s3_bucket_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "s3FolderPath" => intermediate_rep.s3_folder_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageQuota" => intermediate_rep.storage_quota.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usedStorage" => intermediate_rep.used_storage.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allowPublicSharing" => intermediate_rep.allow_public_sharing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requireApproval" => intermediate_rep.require_approval.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gdprCompliant" => intermediate_rep.gdpr_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hipaaCompliant" => intermediate_rep.hipaa_compliant.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletedAt" => intermediate_rep.deleted_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "folders" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace1".to_string()),
                    "templates" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace1".to_string()),
                    "sharing" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace1".to_string()),
                    "activities" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace1".to_string()),
                    "compliance" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace1".to_string()),
                    "installedApps" => return std::result::Result::Err("Parsing a container in this style is not supported in Workspace1".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Workspace1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Workspace1 {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            unique_identifier: intermediate_rep.unique_identifier.into_iter().next(),
            s3_bucket_name: intermediate_rep.s3_bucket_name.into_iter().next(),
            s3_folder_path: intermediate_rep.s3_folder_path.into_iter().next(),
            storage_quota: intermediate_rep.storage_quota.into_iter().next(),
            used_storage: intermediate_rep.used_storage.into_iter().next(),
            allow_public_sharing: intermediate_rep.allow_public_sharing.into_iter().next(),
            require_approval: intermediate_rep.require_approval.into_iter().next(),
            gdpr_compliant: intermediate_rep.gdpr_compliant.into_iter().next(),
            hipaa_compliant: intermediate_rep.hipaa_compliant.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            deleted_at: intermediate_rep.deleted_at.into_iter().next(),
            folders: intermediate_rep.folders.into_iter().next(),
            templates: intermediate_rep.templates.into_iter().next(),
            sharing: intermediate_rep.sharing.into_iter().next(),
            activities: intermediate_rep.activities.into_iter().next(),
            compliance: intermediate_rep.compliance.into_iter().next(),
            installed_apps: intermediate_rep.installed_apps.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Workspace1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Workspace1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Workspace1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Workspace1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Workspace1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Workspace1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Workspace1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WorkspaceActivity {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "activityType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub activity_type: Option<String>,

    #[serde(rename = "userId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl WorkspaceActivity {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WorkspaceActivity {
        WorkspaceActivity {
            id: None,
            activity_type: None,
            user_id: None,
            description: None,
            metadata: None,
            created_at: None,
        }
    }
}

/// Converts the WorkspaceActivity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WorkspaceActivity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.activity_type.as_ref().map(|activity_type| {
                [
                    "activityType".to_string(),
                    activity_type.to_string(),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "userId".to_string(),
                    user_id.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization

            // Skipping createdAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WorkspaceActivity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WorkspaceActivity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub activity_type: Vec<String>,
            pub user_id: Vec<String>,
            pub description: Vec<String>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WorkspaceActivity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "activityType" => intermediate_rep.activity_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userId" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in WorkspaceActivity".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WorkspaceActivity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WorkspaceActivity {
            id: intermediate_rep.id.into_iter().next(),
            activity_type: intermediate_rep.activity_type.into_iter().next(),
            user_id: intermediate_rep.user_id.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WorkspaceActivity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WorkspaceActivity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WorkspaceActivity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WorkspaceActivity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WorkspaceActivity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WorkspaceActivity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WorkspaceActivity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WorkspaceCompliance {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "complianceType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub compliance_type: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "certificationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certification_id: Option<String>,

    #[serde(rename = "validUntil")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub valid_until: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl WorkspaceCompliance {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WorkspaceCompliance {
        WorkspaceCompliance {
            id: None,
            compliance_type: None,
            status: None,
            certification_id: None,
            valid_until: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the WorkspaceCompliance value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WorkspaceCompliance {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.compliance_type.as_ref().map(|compliance_type| {
                [
                    "complianceType".to_string(),
                    compliance_type.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.certification_id.as_ref().map(|certification_id| {
                [
                    "certificationId".to_string(),
                    certification_id.to_string(),
                ].join(",")
            }),

            // Skipping validUntil in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WorkspaceCompliance value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WorkspaceCompliance {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub compliance_type: Vec<String>,
            pub status: Vec<String>,
            pub certification_id: Vec<String>,
            pub valid_until: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WorkspaceCompliance".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "complianceType" => intermediate_rep.compliance_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certificationId" => intermediate_rep.certification_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validUntil" => intermediate_rep.valid_until.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WorkspaceCompliance".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WorkspaceCompliance {
            id: intermediate_rep.id.into_iter().next(),
            compliance_type: intermediate_rep.compliance_type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            certification_id: intermediate_rep.certification_id.into_iter().next(),
            valid_until: intermediate_rep.valid_until.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WorkspaceCompliance> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WorkspaceCompliance>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WorkspaceCompliance>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WorkspaceCompliance - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WorkspaceCompliance> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WorkspaceCompliance as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WorkspaceCompliance - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WorkspaceSharing {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "sharedWithEmail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_with_email: Option<String>,

    #[serde(rename = "permissionLevel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission_level: Option<String>,

    #[serde(rename = "expiresAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl WorkspaceSharing {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WorkspaceSharing {
        WorkspaceSharing {
            id: None,
            shared_with_email: None,
            permission_level: None,
            expires_at: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the WorkspaceSharing value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WorkspaceSharing {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.shared_with_email.as_ref().map(|shared_with_email| {
                [
                    "sharedWithEmail".to_string(),
                    shared_with_email.to_string(),
                ].join(",")
            }),


            self.permission_level.as_ref().map(|permission_level| {
                [
                    "permissionLevel".to_string(),
                    permission_level.to_string(),
                ].join(",")
            }),

            // Skipping expiresAt in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WorkspaceSharing value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WorkspaceSharing {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub shared_with_email: Vec<String>,
            pub permission_level: Vec<String>,
            pub expires_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WorkspaceSharing".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sharedWithEmail" => intermediate_rep.shared_with_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "permissionLevel" => intermediate_rep.permission_level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiresAt" => intermediate_rep.expires_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WorkspaceSharing".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WorkspaceSharing {
            id: intermediate_rep.id.into_iter().next(),
            shared_with_email: intermediate_rep.shared_with_email.into_iter().next(),
            permission_level: intermediate_rep.permission_level.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WorkspaceSharing> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WorkspaceSharing>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WorkspaceSharing>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WorkspaceSharing - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WorkspaceSharing> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WorkspaceSharing as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WorkspaceSharing - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

